global proc shelf_RiggymcRiggerson () {
    global string $gBuffStr;
    global string $gBuffStr0;
    global string $gBuffStr1;


    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Select an object(s)" 
        -enableBackground 0
        -align "center" 
        -label "Center Pivot" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "CP" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.25 
        -image "menuIconModify.png" 
        -image1 "menuIconModify.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "CenterPivot" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Joint tool options" 
        -enableBackground 0
        -align "center" 
        -label "skeletonDialogItem" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.25 
        -image "kinJoint.png" 
        -image1 "kinJoint.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "JointToolOptions" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Insert new joints into a joint chain" 
        -enableBackground 0
        -align "center" 
        -label "Insert Joint Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.25 
        -image "kinInsert.png" 
        -image1 "kinInsert.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "InsertJointTool" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "IK handle tool options" 
        -enableBackground 0
        -align "center" 
        -label "handleDialogItem" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.25 
        -image "kinHandle.png" 
        -image1 "kinHandle.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "IKHandleToolOptions" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "IK spline handle tool options" 
        -enableBackground 0
        -align "center" 
        -label "handleSplineDialogItem" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.25 
        -image "kinSplineHandle.png" 
        -image1 "kinSplineHandle.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "IKSplineHandleToolOptions" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Paint skin weights tool options" 
        -enableBackground 0
        -align "center" 
        -label "skinWeightPaintDialogItem" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.25 
        -image "paintSkinWeights.png" 
        -image1 "paintSkinWeights.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "ArtPaintSkinWeightsToolOptions" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Mirror skin weights options" 
        -enableBackground 0
        -align "center" 
        -label "mirrorSkinWeightsDialog" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.25 
        -image "mirrorSkinWeight.png" 
        -image1 "mirrorSkinWeight.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "MirrorSkinWeightsOptions" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "List the objects in the scene" 
        -enableBackground 0
        -align "center" 
        -label "Outliner" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "Outl" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.25 
        -image "menuIconWindow.png" 
        -image1 "menuIconWindow.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "OutlinerWindow" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Edit various component values for the selected object(s)" 
        -enableBackground 0
        -align "center" 
        -label "Component Editor" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "CpEd" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.25 
        -image "menuIconWindow.png" 
        -image1 "menuIconWindow.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "ComponentEditor" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Make connections between object attributes" 
        -enableBackground 0
        -align "center" 
        -label "Connection Editor" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "CE" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.25 
        -image "menuIconWindow.png" 
        -image1 "menuIconWindow.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "ConnectionEditor" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Edit animation curves" 
        -enableBackground 0
        -align "center" 
        -label "Graph Editor" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "GE" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "menuIconWindow.png" 
        -image1 "menuIconWindow.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "GraphEditor" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Create a NURBS circle on the grid" 
        -enableBackground 0
        -align "center" 
        -label "Circle" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.25 
        -image "circle.png" 
        -image1 "circle.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 1; objectMoveCommand" 
        -sourceType "mel" 
        -doubleClickCommand "CreateNURBSCircleOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Create a locator object on the grid" 
        -enableBackground 0
        -align "center" 
        -label "Locator" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.25 
        -image "locator.png" 
        -image1 "locator.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "CreateLocator" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Cluster" 
        -enableBackground 0
        -align "center" 
        -label "Cluster" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "cluster.png" 
        -image1 "cluster.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "CreateCluster" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Unlocks all hidden elements on an object/control" 
        -enableBackground 0
        -align "center" 
        -label "string $selectedList[] = `ls -sl`;\n\nstring $currentObject;\n\nfor ..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "Unlock & Unhide" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "commandButton.png" 
        -image1 "commandButton.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "string $selectedList[] = `ls -sl`;\n\nstring $currentObject;\n\nfor ($currentObject in $selectedList)\n\n{\nsetAttr -lock false -keyable true {$currentObject + \".tx\"};\nsetAttr -lock false -keyable true {$currentObject + \".ty\"};\nsetAttr -lock false -keyable true {$currentObject + \".tz\"};\nsetAttr -lock false -keyable true {$currentObject + \".rx\"};\nsetAttr -lock false -keyable true {$currentObject + \".ry\"};\nsetAttr -lock false -keyable true {$currentObject + \".rz\"};\nsetAttr -lock false -keyable true {$currentObject + \".sx\"};\nsetAttr -lock false -keyable true {$currentObject + \".sy\"};\nsetAttr -lock false -keyable true {$currentObject + \".sz\"};\nsetAttr -lock false -keyable true {$currentObject + \".v\"};\n}" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "//Query selection...\nstring $selJnt[] = `ls -sl`;\n\n//For loop - for any joints in selection, zero out their orientation...\nfor ($joints in $selJnt) {\nsetAttr ($joints + \".jointOrientX\") 0;\nsetAttr ($joints + \".jointOrientY\") 0;\nsetAttr ($joints + \".jointOrientZ\") 0;\n}" 
        -enableBackground 0
        -align "center" 
        -label "Orient Joint to none" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "OJ" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "commandButton.png" 
        -image1 "commandButton.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "//Query selection...\nstring $selJnt[] = `ls -sl`;\n\n//For loop - for any joints in selection, zero out their orientation...\nfor ($joints in $selJnt) {\nsetAttr ($joints + \".jointOrientX\") 0;\nsetAttr ($joints + \".jointOrientY\") 0;\nsetAttr ($joints + \".jointOrientZ\") 0;\n}" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Toggle local rotation axis visibility" 
        -enableBackground 0
        -align "center" 
        -label "Local Rotation Axes" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "LRA" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.25 
        -image "menuIconDisplay.png" 
        -image1 "menuIconDisplay.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "ToggleLocalRotationAxes" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Customize the joint scale" 
        -enableBackground 0
        -align "center" 
        -label "Joint Size..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "JS" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.25 
        -image "menuIconDisplay.png" 
        -image1 "menuIconDisplay.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "jdsWin" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "CV curve tool options" 
        -enableBackground 0
        -align "center" 
        -label "menuItem604" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.25 
        -image "curveCV.png" 
        -image1 "curveCV.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "CVCurveToolOptions" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Create a curve on the grid or live surface specifying edit points" 
        -enableBackground 0
        -align "center" 
        -label "EP Curve Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.25 
        -image "curveEP.png" 
        -image1 "curveEP.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "EPCurveTool" 
        -sourceType "mel" 
        -doubleClickCommand "EPCurveToolOptions" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Measure distance between two points" 
        -enableBackground 0
        -align "center" 
        -label "Distance Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.25 
        -image "distanceDim.png" 
        -image1 "distanceDim.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "DistanceTool" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Creates the Arc Length info node for an IK spline." 
        -enableBackground 0
        -align "center" 
        -label "arclen -ch 1" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "ARCLEN" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "commandButton.png" 
        -image1 "commandButton.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "arclen -ch 1" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Splits Joints Equally into segments" 
        -enableBackground 0
        -align "center" 
        -label "/* This file downloaded from Highend3d.com\n'' \n''  Highend3d.com..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "SPLIT" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "commandButton.png" 
        -image1 "commandButton.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "/* This file downloaded from Highend3d.com\n'' \n''  Highend3d.com File Information:\n'' \n''    Script Name: Joint Splitter\n''    Author: \n''    Last Updated: Mar 13, 2007\n''    Update/Change this file at:\n''    http://Highend3d.com/maya/downloads/mel_scripts/character/3711.html\n'' \n''  Please do not alter any information above this line\n''  it is generated dynamically by Highend3d.com and will\n''  be changed automatically on any updates.\n*/\n/****************************************************************************\nName: Smart JointSpit\nVersion: 1.0.1\nPurpose: Adds additional joint between a joint chain. Joint Quanity slider\n        allows between 1-10 joints. Fieled limit is 50. The joints can be\n        splitted with and without an interface. The interface allows\n        joints to be positioned using sliders. Source to run.\nIssues: Undo while interface is open is not supported. Solution is reload\n        start joint and re-create interface.\nHistory:\nVersion 1.0.1 March 13, 2007: Adjusted script to work in 8.5\nVersion 1.0 Aug 30, 2005\nCreated by: Brian Escribano\nContact: brian@meljunky.com\nVisit: meljunky.com\n\n*****************************************************************************/\nif (`window -exists beJsWindow`) deleteUI beJsWindow;\nwindow -t \"Joint Splitter\" beJsWindow;\ncolumnLayout;\nrowColumnLayout -nr 6 -rh 1 18 -rh 3 40 -rh 5 20 -rh 6 100 beJsRCL;\n        radioButtonGrp -nrb 2 -la2 \"Auto-Parent\" \"Independent\" -sl 1 beJsParentRBG;\n    button -l \"Select Start Joint\" -c \"beJsSelStartJnt\";\n    rowColumnLayout -nc 2 -cw 1 115 -cw 2 115;\n        text \"            Start Joint\";\n        text \"             End Joint\";\n        textField -ed 0 beJsStartJnt;\n        textField -ed 0 beJsEndJnt;\n    setParent..;\n     intSliderGrp -label \" Jnt Qty:\" -field true -cl3 \"left\" \"left\" \"left\" -cw3 49 25 20\n         -minValue 1 -maxValue 10 -fieldMinValue 1 -fieldMaxValue 50 -value 1 beJsJntQty;\n        frameLayout -cll 1 -cl 1 -h 200 -en 1 -l \"Joint Slider Control\" -fn \"plainLabelFont\"\n                        -cc \"rowColumnLayout -e -rh 5 20 beJsRCL; window -e -wh 245 190 beJsWindow;\"\n                        -ec \"rowColumnLayout -e -rh 5 120 beJsRCL; window -e -wh 245 290 beJsWindow;\"beJsSplitJntFL;\n                scrollLayout -horizontalScrollBarThickness 0 -h 200 beJsSplitJntSL;\n                        columnLayout -h 200 -columnAttach \"left\" 5 beJsSplitJntCL;\n                        //Sliders Created Here\n                        setParent..;\n                setParent..;\n     setParent..;\n        rowColumnLayout -nc 2 -cw 1 115 -cw 2 115;\n        button -l \"Split Joints\" -c \"beJsBeginSplit 1\" -en 0 beJsBN;\n        button -l  \"Create Interface\" -c \"beJsBeginSplit 2\" -en 0 beJsCiBN;\n        //These fields are hidden from the viewer used to pass arrays through buttom command\n        textScrollList -h 50 -vis 0 beJsJntListTSL;\n    setParent..;\nsetParent..;\nsetParent..;\nscriptJob -uid beJsWindow beJsRemoveNodes;\nwindow -e -wh 245 190 beJsWindow;\nshowWindow beJsWindow;\nglobal proc beJsBeginSplit (int $type){\nbutton -e -c \"beJsBeginSplit 1\" beJsBN;\nbeJsRemoveNodes;\nint $error = 0;\nstring $start = `textField -q -tx beJsStartJnt`;\nstring $end = `textField -q -tx beJsEndJnt`;\nif ($start == \"\"){\n    error \"Please select start joint.\";\n    $error = 1;\n}else{\n    string $child[] = `listRelatives $start`;\n    if ($end != $child[0]){\n        error ($end + \" is no longer child of \" + $start + \". Please select start joint.\");\n        $error = 1; }\n    if ($end == \"\") {\n        error (\"No end joint selected\");\n        $error = 1;}\n\nif ($error == 0){\n    if ($type == 1)\n        beJsCreateJoints;\n    else\n        beJsCreateInterface;}\n}\n}//end proc\n\n//Purpose: Populates Start joint and End Joint Field\nglobal proc beJsSelStartJnt(){\nstring $child[];\nstring $sel[] = `ls -sl -type joint`;\nif ($sel[0] == \"\")\n        error \"Please select start joint.\";\nelse {\n        $child = `listRelatives -type joint $sel[0]`;\n        if (`nodeType $child[0]` == \"joint\"){\n        textField -e -tx $sel[0] beJsStartJnt;\n        textField -e -tx $child[0] beJsEndJnt;\n        button -e -en 1 beJsCiBN;\n        button -e -en 1 beJsBN;}\n        else\n        error \"Child of start joint is not a joint\";\n}\n}\n\n//joint Spit Now\nglobal proc beJsCreateJoints(){\nstring $locList[];\nstring $jntList[];\nint $firstJnt;\nint $k;\n$locList = `beJsCreateLoc 1`;          //Creates Locators Only\n$jntList = `beJsAddJoints $locList`;    //Add Joints Only\nbeJsParentJnt $jntList `radioButtonGrp -q -sl beJsParentRBG`;            //PArents Joints Only\nbeJsCleanUp;                   //Cleans up nodes\n}//end proc\n\n//Later\nglobal proc beJsCreateInterface(){\nstring $locList[];\nstring $jntList[];\nstring $attrName[];\nstring $textName[];\n\n$locList = `beJsCreateLoc 2`;          //Creates Locators Only\n$jntList = `beJsAddJoints $locList`;    //Add Joints Only                                     \n$textName = `columnLayout -q -ca beJsSplitJntCL`;    //Name takes off \".\" need label name\nfor ($i=0;$i<size($textName); $i++){\n$attrName[$i] = `text -q -l $textName[$i]`;}\ndeleteUI $textName;                     //Make room for sliders\n\nfor ($i=0; $i< size($locList); $i++){\n        textScrollList -e -a $jntList[$i] beJsJntListTSL;\n        beJsCreateSlider $jntList[$i] $attrName[$i];}\n\nframeLayout -e -cl 0 beJsSplitJntFL;\nrowColumnLayout -e -rh 5 120 beJsRCL;\nwindow -e -wh 245 290 beJsWindow;\nbutton -e -en 0 beJsCiBN;\nbutton -e -c (\"beJsParentJnt `textScrollList -q -ai beJsJntListTSL` `radioButtonGrp -q -sl beJsParentRBG`; beJsCleanUp\") beJsBN;\n\n}\n\nglobal proc beJsCreateSlider(string $jntList, string $attrName){\nsetParent beJsSplitJntCL;\n        attrFieldSliderGrp -l $jntList -min 0 -max 1\n                -cal 1 left -cal 2 left -cal 3 left -pre 3 -cw 1 65 -cw 2 40 -cw 3 100 -at $attrName;}\n\nglobal proc beJsParentJnt (string $jntList[], int $type){\nif ($type == 1){\nstring $start = `textField -q -tx beJsStartJnt`;\nstring $end = `textField -q -tx beJsEndJnt`;\n$firstJnt = `size($jntList)`-1;\nfor ($i=1; $i<size($jntList); $i++){\n    $k = $i-1;\n    parent $jntList[$k] $jntList[$i];}\nparent $jntList[$firstJnt] $start;\nparent $end $jntList[0];\n}else{\nfor ($eval in $jntList){\nparent -w  $eval; }\n}//end else\n}\n\n//Joints have not been created\nglobal proc string[] beJsCreateLoc (int $type){\nint $qty = `intSliderGrp -q -v beJsJntQty`;\nstring $start = `textField -q -tx beJsStartJnt`;\nstring $end = `textField -q -tx beJsEndJnt`;\nfloat $i;\nfloat $sWeight;\nfloat $eWeight;\nstring $pointName[];\nstring $locList[];\nfor ($i=1; $i <= $qty; $i++){\n        $locName = `spaceLocator -p 0 0 0 -n (\"beJsTempLoc\" + $i)`;\n        $locList[size($locList)] = $locName[0];\n        orientConstraint -offset 0 0 0 -weight 1 $start $locName;\n        $sWeight = $i/($qty +1);\n        $eWeight = 1 - $sWeight;\n        $pointName = `pointConstraint -offset 0 0 0 -weight $sWeight $start $locName`;\n        pointConstraint -offset 0 0 0 -weight $eWeight $end $locName;\n        if ($type == 2){\n           //create math connection\n               beCreateSubstractConnect $pointName[0] $start $end;\n        }//end if\n}//end for\nreturn $locList;\n}//end proc\n\nglobal proc string[] beJsAddJoints(string $locList[]){\nstring $start = `textField -q -tx beJsStartJnt`;\nstring $end = `textField -q -tx beJsEndJnt`;\nstring $jntName[];\nstring $jntTempName[];\nint $j;\nfloat $radius = (`getAttr ($start + \".radius\")` + `getAttr ($end + \".radius\")`)/2;\nparent -w $end ; //Jnt is dulpicated without parent\n\nfor ($i=0; $i<size($locList); $i++){\n        $j = $i + 1;\n\n        $jntTempName = `duplicate -rc -n (\"split\" + $j + \"_JNT\") $start`;\n        $jntName[$i] = $jntTempName[0];\n       \n        parent $jntName[$i] $locList[$i];\n        setAttr ($jntName[$i] + \".translateX\") 0;\n        setAttr ($jntName[$i] + \".translateY\") 0;\n        setAttr ($jntName[$i] + \".translateZ\") 0;\n        setAttr ($jntName[$i] + \".jointOrientX\") 0;\n        setAttr ($jntName[$i] + \".jointOrientY\") 0;\n        setAttr ($jntName[$i] + \".jointOrientZ\") 0;}//for\nparent $end $start;\nreturn $jntName;\n}//end proc\n\nglobal proc beCreateSubstractConnect (string $pointName, string $start, string $end){\nstring $minusNode;\n$minusNode = `shadingNode -asUtility plusMinusAverage -n ($pointName + \"_beJsMinus\")`;\nsetAttr ($minusNode + \".operation\") 2;\naddAttr -ln startPoint -at double  -dv 1 $minusNode;\nconnectAttr -f ($pointName + \".\" + $start + \"W0\") ($minusNode + \".input1D[1]\");\nconnectAttr -f ($minusNode + \".startPoint\") ($minusNode + \".input1D[0]\");\nconnectAttr -f ($minusNode + \".output1D\") ($pointName + \".\" + $end + \"W1\");\nsetParent beJsSplitJntCL;\n        text -l ($pointName + \".\" + $start + \"W0\") ($pointName + \".\" + $start + \"W0\");}\n\nglobal proc beJsCleanUp(){\nrowColumnLayout -e -rh 5 20 beJsRCL;\nwindow -e -wh 245 190 beJsWindow;\nframeLayout -e -cl 1 beJsSplitJntFL;\ntextScrollList -e -ra beJsJntListTSL;\nbeJsRemoveNodes;\nbutton -e -c \"beJsBeginSplit 1\" beJsBN;\nbutton -e  -en 1 beJsCiBN;\n}\n\nglobal proc beJsRemoveNodes(){\n//Deletes any sliders that are left over\nif (`columnLayout -q -ex beJsSplitJntCL`){\n        string $delListUI[] = `columnLayout -q -ca beJsSplitJntCL`;\n    for ($delUI in $delListUI){\n        deleteUI $delUI;}}\n//Deletes any minus nodes that are left over\nstring $delSubNode[] = `ls  -type plusMinusAverage \"beJsTempLoc*\"`;\n    for ($delSub in $delSubNode){\n        delete $delSub;}\n//Deletes any locators that are left over\nstring $delLocNode[] = `ls -type locator \"beJsTempLoc*\"`;\n    for ($delLoc in $delLocNode){\n        delete `listRelatives -s -p $delLoc`;}\n}" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Combine any number of curves into 1 selectable curve." 
        -enableBackground 0
        -align "center" 
        -label "list=cmds.ls(sl=True)\nfor x in range(len(list)-1):\n\tcmds.makeIde..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "COMB" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "pythonFamily.png" 
        -image1 "pythonFamily.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "list=cmds.ls(sl=True)\nfor x in range(len(list)-1):\n\tcmds.makeIdentity(list[x+1], apply=True, t=1, r=1, s=1, n=0)\n\tshapeNode = cmds.listRelatives(list[x+1], shapes=True)\n\tcmds.parent(shapeNode, list[0], add=True, s=True)\n\tcmds.delete(list[x+1])\ncmds.select(list[0])" 
        -sourceType "python" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Make Controls automatically." 
        -enableBackground 0
        -align "center" 
        -label "'''A rigging GUI that aids the creation of controls.'''\n\nimport ..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "CTRL" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "pythonFamily.png" 
        -image1 "pythonFamily.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "'''A rigging GUI that aids the creation of controls.'''\n\nimport maya.cmds as cmds\n\ndef curveColour(colour):\n    selectedCurves = cmds.ls(sl=True)\n    for object in selectedCurves:\n        cmds.setAttr(object + '.overrideEnabled', 1)\n        cmds.setAttr(object + '.overrideColor', colour)\n\ndef makesphere():\n    spherelist = []\n    spherelist.append(cmds.curve( p =[(0.78361162489122504, 0.0, -0.78361162489122371), (-1.2643170607829324e-16, 0.0, -1.1081941875543877), (-0.78361162489122427, 0.0, -0.78361162489122416), (-1.1081941875543879, 0.0, 0.0), (-0.78361162489122449, 0.0, 0.78361162489122371), (-3.3392053635905195e-16, 0.0, 1.1081941875543881), (0.78361162489122382, 0.0, 0.7836116248912246), (1.1081941875543879, 0.0, 8.8817841970012523e-16), (0.78361162489122504, 0.0, -0.78361162489122371), (-1.2643170607829324e-16, 0.0, -1.1081941875543877), (-0.78361162489122427, 0.0, -0.78361162489122416)],per = True, d=3, k=[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    spherelist.append(cmds.curve( p =[(0.78361162489122504, 0.78361162489122194, 0.0), (-1.2643170607829324e-16, 1.1081941875543748, 0.0), (-0.78361162489122427, 0.78361162489122194, 0.0), (-1.1081941875543879, 0.0, 0.0), (-0.78361162489122449, -0.78361162489122194, 0.0), (-3.3392053635905195e-16, -1.1081941875543748, 0.0), (0.78361162489122382, -0.78361162489122194, 0.0), (1.1081941875543879, 0.0, 0.0), (0.78361162489122504, 0.78361162489122194, 0.0), (-1.2643170607829324e-16, 1.1081941875543748, 0.0), (-0.78361162489122427, 0.78361162489122194, 0.0)],per = True, d=3, k=[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    spherelist.append(cmds.curve( p =[(1.2601436025374959e-16, 0.78361162489122194, -0.78361162489122371), (-6.7857323231109159e-17, 0.0, -1.1081941875543877), (-2.219791070735184e-16, -0.78361162489122194, -0.78361162489122416), (-2.4606854055572997e-16, -1.1081941875543748, 0.0), (-1.2601436025374919e-16, -0.78361162489122194, 0.78361162489122371), (6.7857323231108764e-17, 0.0, 1.1081941875543881), (2.219791070735184e-16, 0.78361162489122194, 0.7836116248912246), (2.4606854055573036e-16, 1.1081941875543748, 8.8817841970012523e-16), (1.2601436025374959e-16, 0.78361162489122194, -0.78361162489122371), (-6.7857323231109159e-17, 0.0, -1.1081941875543877), (-2.219791070735184e-16, -0.78361162489122194, -0.78361162489122416)],per = True, d=3, k=[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    for x in range(len(spherelist)-1):\n    \tcmds.makeIdentity(spherelist[x+1], apply=True, t=1, r=1, s=1, n=0)\n    \tshapeNode = cmds.listRelatives(spherelist[x+1], shapes=True)\n        cmds.parent(shapeNode, spherelist[0], add=True, s=True)\n    \tcmds.delete(spherelist[x+1])\n    return spherelist[0]\n\n\ndef maketranslate():\n    translatelist = []\n    translatelist.append(cmds.curve( p =[(-0.38399386349022863, 4.2573685351256776e-17, -0.69528104561900206), (-0.44931793443791412, 4.0380835015313633e-17, -0.65946908191697962), (-0.56996546699308825, 3.4900319246073857e-17, -0.56996546711056317), (-0.65946908181691422, 2.7512788518703874e-17, -0.44931793457279839), (-0.69528104549888847, 2.3512842804192566e-17, -0.38399386370932614)],per = False, d=3, k=[0, 0, 0, 1, 2, 2, 2]))\n    translatelist.append(cmds.curve( p =[(-1.1519815904477793, 0.0, -0.38399386348259285), (-1.1519815904477793, 0.0, -0.76798772696518569), (-1.9199693174129653, 0.0, 0.0), (-1.1519815904477793, 0.0, 0.76798772696518569), (-1.1519815904477793, 0.0, 0.38399386348259285), (-0.69528104554589998, 0.0, 0.38399386348259285)],per = False, d=1, k=[0, 1, 2, 3, 4, 5]))\n    translatelist.append(cmds.curve( p =[(-0.69528104549888869, -2.3512842804192541e-17, 0.38399386370932576), (-0.65946908181691444, -2.7512788518703853e-17, 0.44931793457279806), (-0.56996546704312112, -3.4900319241944207e-17, 0.5699654670431209), (-0.44931793457279851, -4.0380835009186402e-17, 0.65946908181691422), (-0.38399386370932614, -4.2573685343901955e-17, 0.69528104549888847)],per = False, d=3, k=[0, 0, 0, 1, 2, 2, 2]))\n    translatelist.append(cmds.curve( p =[(0.38399386370932587, -4.2573685343901949e-17, 0.69528104549888847), (0.44931793457279817, -4.0380835009186402e-17, 0.65946908181691433), (0.56996546704312068, -3.4900319241944226e-17, 0.56996546704312101), (0.65946908181691399, -2.7512788518703884e-17, 0.44931793457279862), (0.69528104549888825, -2.3512842804192578e-17, 0.38399386370932637)],per = False, d=3, k=[0, 0, 0, 1, 2, 2, 2]))\n    translatelist.append(cmds.curve( p =[(0.69528104549888869, 2.3512842804192541e-17, -0.3839938637093257), (0.65946908181691455, 2.751278851870385e-17, -0.44931793457279795), (0.56996546704312134, 3.4900319241944195e-17, -0.56996546704312057), (0.44931793457279867, 4.0380835009186384e-17, -0.65946908181691399), (0.38399386370932637, 4.2573685343901936e-17, -0.69528104549888825)],per = False, d=3, k=[0, 0, 0, 1, 2, 2, 2]))\n    translatelist.append(cmds.curve( p =[(-0.38399386348259307, 0.0, 0.69528104554589942), (-0.38399386348259307, 0.0, 1.1519815904477788), (-0.76798772696518613, 0.0, 1.1519815904477788), (0.0, 0.0, 1.9199693174129639), (0.76798772696518613, 0.0, 1.1519815904477788), (0.38399386348259307, 0.0, 1.1519815904477788), (0.38399386348259307, 0.0, 0.69528104631388721)],per = False, d=1, k=[0, 1, 2, 3, 4, 5, 6]))\n    translatelist.append(cmds.curve( p =[(0.69528104631388776, 0.0, 0.38399386348259285), (1.1519815904477793, 0.0, 0.38399386348259285), (1.1519815904477793, 0.0, 0.76798772696518569), (1.9199693174129653, 0.0, 0.0), (1.1519815904477793, 0.0, -0.76798772696518569), (1.1519815904477793, 0.0, -0.38399386348259285), (0.69528104631388776, 0.0, -0.38399386348259285)],per = False, d=1, k=[0, 1, 2, 3, 4, 5, 6]))\n    translatelist.append(cmds.curve( p =[(0.38399386348259307, 0.0, -0.69528104631388721), (0.38399386348259307, 0.0, -1.1519815904477788), (0.76798772696518613, 0.0, -1.1519815904477788), (0.0, 0.0, -1.9199693174129639), (-0.76798772696518613, 0.0, -1.1519815904477788), (-0.38399386348259307, 0.0, -1.1519815904477788), (-0.38399386348259307, 0.0, -0.69528104631388721)],per = False, d=1, k=[0, 1, 2, 3, 4, 5, 6]))\n    translatelist.append(cmds.curve( p =[(-0.69528104631388776, 0.0, -0.38399386348259285), (-1.1519815904477793, 0.0, -0.38399386348259285)],per = False, d=1, k=[0, 1]))\n    for x in range(len(translatelist)-1):\n        cmds.makeIdentity(translatelist[x+1], apply=True, t=1, r=1, s=1, n=0)\n        shapeNode = cmds.listRelatives(translatelist[x+1], shapes=True)\n        cmds.parent(shapeNode, translatelist[0], add=True, s=True)\n        cmds.delete(translatelist[x+1])\n    return translatelist[0]\n\n\ndef curveCreation(desiredCurve):\n    selectedJoints = cmds.ls(sl=True)#,type='joint')\n    selectedCurve = cmds.ls(sl=True)\n    spherelist=[]\n\n    #SQUARE#\n    if desiredCurve == \"square\":\n        if len(selectedCurve) == 0:\n            cmds.curve(n='squareCurve',d=1, p = [(-1, 0, 1), (-1, 0, -1), (1, 0, -1), (1, 0, 1), (-1, 0, 1)])\n        else:\n            for joints in selectedJoints:\n                cmds.curve(n=joints+'_ctrl',d=1, p = [(-1, 0, 1), (-1, 0, -1), (1, 0, -1), (1, 0, 1), (-1, 0, 1)])\n                cmds.CenterPivot()\n                cmds.group(n=joints+'_ctrl_sdk')\n                cmds.CenterPivot()\n                cmds.group(n=joints+'_ctrl_offset')\n                cmds.CenterPivot()\n                a = cmds.pointConstraint(joints,joints+'_ctrl_offset')\n                b = cmds.parentConstraint(joints,joints+'_ctrl_offset')\n                cmds.delete(a)\n                cmds.delete(b)\n                cmds.parentConstraint(joints+'_ctrl',joints)\n\n    #CIRCLE#\n    if desiredCurve == \"circle\":\n        if len(selectedCurve) == 0:\n            cmds.circle(n='circleCurve')\n        else:\n            for joints in selectedJoints:\n                cmds.circle(n=joints+'_ctrl')\n                cmds.CenterPivot()\n                cmds.group(n=joints+'_ctrl_sdk')\n                cmds.CenterPivot()\n                cmds.group(n=joints+'_ctrl_offset')\n                cmds.CenterPivot()\n                a = cmds.pointConstraint(joints,joints+'_ctrl_offset')\n                b = cmds.parentConstraint(joints,joints+'_ctrl_offset')\n                cmds.delete(a)\n                cmds.delete(b)\n                cmds.parentConstraint(joints+'_ctrl',joints)\n \n    #SPHERE#\n    if desiredCurve == \"sphere\":\n        if len(selectedCurve) == 0:\n            makesphere()\n        else:\n            for joints in selectedJoints:\n                print joints\n                spherecontrol = makesphere()\n                renamedsphere = cmds.rename(spherecontrol,joints+'_ctrl')\n                cmds.select(renamedsphere)\n                print '1'\n                cmds.CenterPivot()\n                print '2',joints\n                cmds.group(n=joints+'_ctrl_sdk')\n                print '3'\n                cmds.CenterPivot()\n                print '4'\n                cmds.group(n=joints+'_ctrl_offset')\n                cmds.CenterPivot()\n                a = cmds.pointConstraint(joints,joints+'_ctrl_offset')\n                b = cmds.parentConstraint(joints,joints+'_ctrl_offset')\n                cmds.delete(a)\n                cmds.delete(b)\n                cmds.parentConstraint(joints+'_ctrl',joints)\n\n\n    #ARROW#\n    if desiredCurve == \"arrow\":\n        if len(selectedCurve) == 0:\n            cmds.curve(n='arrow',d=1,p =[(-1.0, 0.0, 0.0), (-1.0, 0.0, 2.0), (1.0, 0.0, 2.0), (1.0, 0.0, 0.0), (2.0, 0.0, 0.0), (0.0, 0.0, -2.0), (-2.0, 0.0, 0.0), (-1.0, 0.0, 0.0)])\n        else:\n            for joints in selectedJoints:\n                cmds.curve(n=joints+'_ctrl',d=1,p =[(-1.0, 0.0, 0.0), (-1.0, 0.0, 2.0), (1.0, 0.0, 2.0), (1.0, 0.0, 0.0), (2.0, 0.0, 0.0), (0.0, 0.0, -2.0), (-2.0, 0.0, 0.0), (-1.0, 0.0, 0.0)])\n                cmds.CenterPivot()\n                cmds.group(n=joints+'_ctrl_sdk')\n                cmds.CenterPivot()\n                cmds.group(n=joints+'_ctrl_offset')\n                cmds.CenterPivot()\n                a = cmds.pointConstraint(joints,joints+'_ctrl_offset')\n                b = cmds.parentConstraint(joints,joints+'_ctrl_offset')\n                cmds.delete(a)\n                cmds.delete(b)\n                cmds.parentConstraint(joints+'_ctrl',joints)\n\n    #TRANSLATE#\n    if desiredCurve == \"translate\":\n        if len(selectedCurve) == 0:\n            maketranslate()\n        else:\n            for joints in selectedJoints:\n                translater = maketranslate()\n                renamedtranslater = cmds.rename(translater,joints+'_ctrl')\n                cmds.select(renamedtranslater)\n                cmds.group(n=joints+'_ctrl_sdk')\n                cmds.CenterPivot()\n                cmds.group(n=joints+'_ctrl_offset')\n                cmds.CenterPivot()\n                a = cmds.pointConstraint(joints,joints+'_ctrl_offset')\n                b = cmds.parentConstraint(joints,joints+'_ctrl_offset')\n                cmds.delete(a)\n                cmds.delete(b)\n                cmds.parentConstraint(joints+'_ctrl',joints)\n\n    #ORIENT#\n    if desiredCurve == \"orient\":\n        if len(selectedCurve) == 0:\n            cmds.curve(n='orientCurve',p= [(0.0959835, 0.604001, -0.0987656 ), ( 0.500783, 0.500458, -0.0987656 ), ( 0.751175, 0.327886, -0.0987656 ), ( 0.751175, 0.327886, -0.0987656 ), ( 0.751175, 0.327886, -0.336638 ), ( 0.751175, 0.327886, -0.336638 ), ( 1.001567, 0, 0 ), ( 1.001567, 0, 0 ), ( 0.751175, 0.327886, 0.336638 ), ( 0.751175, 0.327886, 0.336638 ), ( 0.751175, 0.327886, 0.0987656 ), ( 0.751175, 0.327886, 0.0987656 ), ( 0.500783, 0.500458, 0.0987656 ), ( 0.0959835, 0.604001, 0.0987656 ), ( 0.0959835, 0.604001, 0.0987656 ), ( 0.0959835, 0.500458, 0.500783 ), ( 0.0959835, 0.327886, 0.751175 ), ( 0.0959835, 0.327886, 0.751175 ), ( 0.336638, 0.327886, 0.751175 ), ( 0.336638, 0.327886, 0.751175 ), ( 0, 0, 1.001567 ), ( 0, 0, 1.001567 ), ( -0.336638, 0.327886, 0.751175 ), ( -0.336638, 0.327886, 0.751175 ), ( -0.0959835, 0.327886, 0.751175 ), ( -0.0959835, 0.327886, 0.751175 ), ( -0.0959835, 0.500458, 0.500783 ), ( -0.0959835, 0.604001, 0.0987656 ), ( -0.0959835, 0.604001, 0.0987656 ), ( -0.500783, 0.500458, 0.0987656 ), ( -0.751175, 0.327886, 0.0987656 ), ( -0.751175, 0.327886, 0.0987656 ), ( -0.751175, 0.327886, 0.336638 ), ( -0.751175, 0.327886, 0.336638 ), ( -1.001567, 0, 0 ), ( -1.001567, 0, 0 ), ( -0.751175, 0.327886, -0.336638 ), ( -0.751175, 0.327886, -0.336638 ), ( -0.751175, 0.327886, -0.0987656 ), ( -0.751175, 0.327886, -0.0987656 ), ( -0.500783, 0.500458, -0.0987656 ), ( -0.0959835, 0.604001, -0.0987656 ), ( -0.0959835, 0.604001, -0.0987656 ), ( -0.0959835, 0.500458, -0.500783 ), ( -0.0959835, 0.327886, -0.751175 ), ( -0.0959835, 0.327886, -0.751175 ), ( -0.336638, 0.327886, -0.751175 ), ( -0.336638, 0.327886, -0.751175 ), ( 0, 0, -1.001567 ), ( 0, 0, -1.001567 ), ( 0.336638, 0.327886, -0.751175 ), ( 0.336638, 0.327886, -0.751175 ), ( 0.0959835, 0.327886, -0.751175 ), ( 0.0959835, 0.327886, -0.751175 ), ( 0.0959835, 0.500458, -0.500783 ), ( 0.0959835, 0.604001, -0.0987656)])\n        else:\n            for joints in selectedJoints:\n                cmds.curve(n=joints+'_ctrl',p= [(0.0959835, 0.604001, -0.0987656 ), ( 0.500783, 0.500458, -0.0987656 ), ( 0.751175, 0.327886, -0.0987656 ), ( 0.751175, 0.327886, -0.0987656 ), ( 0.751175, 0.327886, -0.336638 ), ( 0.751175, 0.327886, -0.336638 ), ( 1.001567, 0, 0 ), ( 1.001567, 0, 0 ), ( 0.751175, 0.327886, 0.336638 ), ( 0.751175, 0.327886, 0.336638 ), ( 0.751175, 0.327886, 0.0987656 ), ( 0.751175, 0.327886, 0.0987656 ), ( 0.500783, 0.500458, 0.0987656 ), ( 0.0959835, 0.604001, 0.0987656 ), ( 0.0959835, 0.604001, 0.0987656 ), ( 0.0959835, 0.500458, 0.500783 ), ( 0.0959835, 0.327886, 0.751175 ), ( 0.0959835, 0.327886, 0.751175 ), ( 0.336638, 0.327886, 0.751175 ), ( 0.336638, 0.327886, 0.751175 ), ( 0, 0, 1.001567 ), ( 0, 0, 1.001567 ), ( -0.336638, 0.327886, 0.751175 ), ( -0.336638, 0.327886, 0.751175 ), ( -0.0959835, 0.327886, 0.751175 ), ( -0.0959835, 0.327886, 0.751175 ), ( -0.0959835, 0.500458, 0.500783 ), ( -0.0959835, 0.604001, 0.0987656 ), ( -0.0959835, 0.604001, 0.0987656 ), ( -0.500783, 0.500458, 0.0987656 ), ( -0.751175, 0.327886, 0.0987656 ), ( -0.751175, 0.327886, 0.0987656 ), ( -0.751175, 0.327886, 0.336638 ), ( -0.751175, 0.327886, 0.336638 ), ( -1.001567, 0, 0 ), ( -1.001567, 0, 0 ), ( -0.751175, 0.327886, -0.336638 ), ( -0.751175, 0.327886, -0.336638 ), ( -0.751175, 0.327886, -0.0987656 ), ( -0.751175, 0.327886, -0.0987656 ), ( -0.500783, 0.500458, -0.0987656 ), ( -0.0959835, 0.604001, -0.0987656 ), ( -0.0959835, 0.604001, -0.0987656 ), ( -0.0959835, 0.500458, -0.500783 ), ( -0.0959835, 0.327886, -0.751175 ), ( -0.0959835, 0.327886, -0.751175 ), ( -0.336638, 0.327886, -0.751175 ), ( -0.336638, 0.327886, -0.751175 ), ( 0, 0, -1.001567 ), ( 0, 0, -1.001567 ), ( 0.336638, 0.327886, -0.751175 ), ( 0.336638, 0.327886, -0.751175 ), ( 0.0959835, 0.327886, -0.751175 ), ( 0.0959835, 0.327886, -0.751175 ), ( 0.0959835, 0.500458, -0.500783 ), ( 0.0959835, 0.604001, -0.0987656)]) \n                cmds.CenterPivot()\n                cmds.group(n=joints+'_ctrl_sdk')\n                cmds.CenterPivot()\n                cmds.group(n=joints+'_ctrl_offset')\n                cmds.CenterPivot()\n                a = cmds.pointConstraint(joints,joints+'_ctrl_offset')\n                b = cmds.parentConstraint(joints,joints+'_ctrl_offset')\n                cmds.delete(a)\n                cmds.delete(b)\n                cmds.parentConstraint(joints+'_ctrl',joints)\n\n    #CUBE#\n    if desiredCurve == \"cube\":\n        if len(selectedCurve) == 0:\n            cmds.curve(n='cubeCurve',d=1,p= [(-0.5, 0.5, 0.5 ), ( 0.5, 0.5, 0.5 ), ( 0.5, 0.5, -0.5 ), ( -0.5, 0.5, -0.5 ), ( -0.5, 0.5, 0.5 ), ( -0.5, -0.5, 0.5 ), ( -0.5, -0.5, -0.5 ), ( 0.5, -0.5, -0.5 ), ( 0.5, -0.5, 0.5 ), ( -0.5, -0.5, 0.5 ), ( 0.5, -0.5, 0.5 ), ( 0.5, 0.5, 0.5 ), ( 0.5, 0.5, -0.5 ), ( 0.5, -0.5, -0.5 ), ( -0.5, -0.5, -0.5 ), ( -0.5, 0.5, -0.5)])\n        else:\n            for joints in selectedJoints:\n                cmds.curve(n=joints+'_ctrl',d=1,p= [(-0.5, 0.5, 0.5 ), ( 0.5, 0.5, 0.5 ), ( 0.5, 0.5, -0.5 ), ( -0.5, 0.5, -0.5 ), ( -0.5, 0.5, 0.5 ), ( -0.5, -0.5, 0.5 ), ( -0.5, -0.5, -0.5 ), ( 0.5, -0.5, -0.5 ), ( 0.5, -0.5, 0.5 ), ( -0.5, -0.5, 0.5 ), ( 0.5, -0.5, 0.5 ), ( 0.5, 0.5, 0.5 ), ( 0.5, 0.5, -0.5 ), ( 0.5, -0.5, -0.5 ), ( -0.5, -0.5, -0.5 ), ( -0.5, 0.5, -0.5)])\n                cmds.CenterPivot()\n                cmds.group(n=joints+'_ctrl_sdk')\n                cmds.CenterPivot()\n                cmds.group(n=joints+'_ctrl_offset')\n                cmds.CenterPivot()\n                a = cmds.pointConstraint(joints,joints+'_ctrl_offset')\n                b = cmds.parentConstraint(joints,joints+'_ctrl_offset')\n                cmds.delete(a)\n                cmds.delete(b)\n                cmds.parentConstraint(joints+'_ctrl',joints)\n\n    #DIAMOND\n    if desiredCurve == \"diamond\":\n        if len(selectedCurve) == 0:\n            cmds.curve(n='diamond', p =[(0.0, -0.2016202582919906, 0.10123448014461145), (0.0, 1.4256710834104069e-07, 0.30285488100370994), (0.20162040085909805, 1.4256710834104069e-07, 0.10123448014461189), (0.0, -0.2016202582919906, 0.10123448014461145), (-0.20162040085909827, 1.4256710834104069e-07, 0.10123448014461189), (0.0, 1.4256710834104069e-07, 0.30285488100370994), (0.0, 0.20162025829198971, 0.10123448014461189), (-0.20162040085909827, 1.4256710834104069e-07, 0.10123448014461189), (0.0, 0.20162025829198971, 0.10123448014461189), (0.20162040085909805, 1.4256710834104069e-07, 0.10123448014461189), (0.0, 1.4256710834104069e-07, 0.30285488100370994), (0.0, 0.20162025829198971, 0.10123448014461189), (0.0, 0.20162025829198971, -0.10134995950254133), (0.20162040085909805, -1.4256710922921911e-07, -0.10123448014461101), (0.0, -0.00011562192503866697, -0.3028548810037095), (0.0, -0.2016202582919906, -0.10111900078668068), (0.20162040085909805, -1.4256710922921911e-07, -0.10123448014461101), (0.20162040085909805, 1.4256710834104069e-07, 0.10123448014461189), (0.0, -0.2016202582919906, 0.10123448014461145), (0.0, -0.2016202582919906, -0.10111900078668068), (-0.20162040085909827, -1.4256710922921911e-07, -0.10123448014461101), (-0.20162040085909827, 1.4256710834104069e-07, 0.10123448014461189), (-0.20162040085909827, -1.4256710922921911e-07, -0.10123448014461101), (0.0, 0.20162025829198971, -0.10134995950254133), (0.20162040085909805, -1.4256710922921911e-07, -0.10123448014461101), (0.0, -0.2016202582919906, -0.10111900078668068), (-0.20162040085909827, -1.4256710922921911e-07, -0.10123448014461101), (0.0, -0.00011562192503866697, -0.3028548810037095), (0.0, -0.2016202582919906, -0.10111900078668068), (0.20162040085909805, -1.4256710922921911e-07, -0.10123448014461101), (0.0, -0.00011562192503866697, -0.3028548810037095), (0.0, 0.20162025829198971, -0.10134995950254133), (-0.20162040085909827, -1.4256710922921911e-07, -0.10123448014461101), (0.0, -0.00011562192503866697, -0.3028548810037095)],per = False, d=1, k=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33])\n        else:\n            for joints in selectedJoints:\n                cmds.curve(n=joints+'_ctrl', p =[(0.0, -0.2016202582919906, 0.10123448014461145), (0.0, 1.4256710834104069e-07, 0.30285488100370994), (0.20162040085909805, 1.4256710834104069e-07, 0.10123448014461189), (0.0, -0.2016202582919906, 0.10123448014461145), (-0.20162040085909827, 1.4256710834104069e-07, 0.10123448014461189), (0.0, 1.4256710834104069e-07, 0.30285488100370994), (0.0, 0.20162025829198971, 0.10123448014461189), (-0.20162040085909827, 1.4256710834104069e-07, 0.10123448014461189), (0.0, 0.20162025829198971, 0.10123448014461189), (0.20162040085909805, 1.4256710834104069e-07, 0.10123448014461189), (0.0, 1.4256710834104069e-07, 0.30285488100370994), (0.0, 0.20162025829198971, 0.10123448014461189), (0.0, 0.20162025829198971, -0.10134995950254133), (0.20162040085909805, -1.4256710922921911e-07, -0.10123448014461101), (0.0, -0.00011562192503866697, -0.3028548810037095), (0.0, -0.2016202582919906, -0.10111900078668068), (0.20162040085909805, -1.4256710922921911e-07, -0.10123448014461101), (0.20162040085909805, 1.4256710834104069e-07, 0.10123448014461189), (0.0, -0.2016202582919906, 0.10123448014461145), (0.0, -0.2016202582919906, -0.10111900078668068), (-0.20162040085909827, -1.4256710922921911e-07, -0.10123448014461101), (-0.20162040085909827, 1.4256710834104069e-07, 0.10123448014461189), (-0.20162040085909827, -1.4256710922921911e-07, -0.10123448014461101), (0.0, 0.20162025829198971, -0.10134995950254133), (0.20162040085909805, -1.4256710922921911e-07, -0.10123448014461101), (0.0, -0.2016202582919906, -0.10111900078668068), (-0.20162040085909827, -1.4256710922921911e-07, -0.10123448014461101), (0.0, -0.00011562192503866697, -0.3028548810037095), (0.0, -0.2016202582919906, -0.10111900078668068), (0.20162040085909805, -1.4256710922921911e-07, -0.10123448014461101), (0.0, -0.00011562192503866697, -0.3028548810037095), (0.0, 0.20162025829198971, -0.10134995950254133), (-0.20162040085909827, -1.4256710922921911e-07, -0.10123448014461101), (0.0, -0.00011562192503866697, -0.3028548810037095)],per = False, d=1, k=[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33])\n                cmds.CenterPivot()\n                cmds.group(n=joints+'_ctrl_sdk')\n                cmds.CenterPivot()\n                cmds.group(n=joints+'_ctrl_offset')\n                cmds.CenterPivot()\n                a = cmds.pointConstraint(joints,joints+'_ctrl_offset')\n                b = cmds.parentConstraint(joints,joints+'_ctrl_offset')\n                cmds.delete(a)\n                cmds.delete(b)\n                cmds.parentConstraint(joints+'_ctrl',joints)\n    \n    \n    #POINTER#\n    if desiredCurve == \"pointer\":\n        if len(selectedCurve) == 0:\n            cmds.curve(n='pointerCurve',p = [(3, 0, 6), (4, 0, 5), (3, 0, 4), (2, 0, 5), (3, 0, 6)])\n            cmds.CenterPivot('pointerCurve')\n            cmds.xform('pointerCurve',t=[-3,0,-5],ws=True)\n            cmds.makeIdentity('pointerCurve',apply = True, t=1,r=1,s=1,n=0,pn=1)\n        else:\n            for joints in selectedJoints:\n                cmds.curve(n=joints+'_ctrl',p = [(3, 0, 6), (4, 0, 5), (3, 0, 4), (2, 0, 5), (3, 0, 6)])\n                cmds.CenterPivot()\n                cmds.group(n=joints+'_ctrl_sdk')\n                cmds.CenterPivot()\n                cmds.group(n=joints+'_ctrl_offset')\n                cmds.CenterPivot()\n                a = cmds.pointConstraint(joints,joints+'_ctrl_offset')\n                b = cmds.parentConstraint(joints,joints+'_ctrl_offset')\n                cmds.delete(a)\n                cmds.delete(b)\n                cmds.parentConstraint(joints+'_ctrl',joints)\n\n    #LOCATOR#\n    if desiredCurve == \"locator\":\n        if len(selectedCurve) == 0:\n            cmds.spaceLocator(n='locator')\n        else:\n            for joints in selectedJoints:\n                cmds.spaceLocator(n=joints+'_ctrl')\n                cmds.CenterPivot()\n                cmds.group(n=joints+'_ctrl_sdk')\n                cmds.CenterPivot()\n                cmds.group(n=joints+'_ctrl_offset')\n                cmds.CenterPivot()\n                a = cmds.pointConstraint(joints,joints+'_ctrl_offset')\n                b = cmds.parentConstraint(joints,joints+'_ctrl_offset')\n                cmds.delete(a)\n                cmds.delete(b)\n                cmds.parentConstraint(joints+'_ctrl',joints)\n\n    #OWNCURVE#\n    if desiredCurve == \"owncurve\":\n        selectedJoints = (cmds.ls(sl=True)[1:])\n        for joints in selectedJoints:\n            cmds.select(selectedCurve[0])\n            copy = cmds.duplicate()\n            cmds.rename(copy,joints+'_ctrl')\n            cmds.makeIdentity(apply = True, t=1,r=1,s=1,n=0,pn=1)\n            cmds.CenterPivot()\n            cmds.group(n=joints+'_ctrl_sdk')\n            cmds.CenterPivot()\n            cmds.group(n=joints+'_ctrl_offset')\n            cmds.CenterPivot()\n            a = cmds.pointConstraint(joints,joints+'_ctrl_offset')\n            b = cmds.parentConstraint(joints,joints+'_ctrl_offset')\n            cmds.delete(a)\n            cmds.delete(b)\n            cmds.parentConstraint(joints+'_ctrl',joints)\n        cmds.delete(selectedCurve[0])\n\n\ndef UI():\n    \n    if cmds.window(\"ctrl_crtr\", exists = True):\n        cmds.deleteUI(\"ctrl_crtr\")\n    ctrl_window = cmds.window(\"ctrl_crtr\", title = \"Control Creator\", w = 300, h = 400, mnb = False, mxb = False, sizeable=False)\n    cmds.columnLayout(columnAlign=('center'), columnAttach=('both', 0), columnWidth=(140) )\n    cmds.text('Select Joint(s), then select desired curve. Colour after curve creation.',ww=True,h=40)\n\n\n    #CURVES#\n    cmds.frameLayout(l='Curves',mh=10,mw=10)\n    cmds.iconTextButton(h = 19, l = \"Square\",  style = \"iconAndTextHorizontal\", image = 'mp_square.xpm',c='curveCreation(\"square\")')\n    cmds.iconTextButton(h = 19, l = \"Circle\",  style = \"iconAndTextHorizontal\", image = 'mp_circle.xpm',c='curveCreation(\"circle\")')\n    cmds.iconTextButton(h = 19, l = \"Sphere\",  style = \"iconAndTextHorizontal\", image = 'mp_sphere.xpm',c='curveCreation(\"sphere\")')\n    cmds.iconTextButton(h = 19, l = \"Arrow\",  style = \"iconAndTextHorizontal\", image = 'mp_arrow.xpm',c='curveCreation(\"arrow\")')\n    cmds.iconTextButton(h = 19, l = \"Translate\",  style = \"iconAndTextHorizontal\", image = 'translate.jpg',c='curveCreation(\"translate\")')\n    cmds.iconTextButton(h = 19, l = \"Rotate\",  style = \"iconAndTextHorizontal\", image = 'mp_orient.xpm',c='curveCreation(\"orient\")')\n    cmds.iconTextButton(h = 19, l = \"Cube\",  style = \"iconAndTextHorizontal\", image = 'mp_cube.xpm',c='curveCreation(\"cube\")')\n    cmds.iconTextButton(h = 19, l = \"Diamond\",  style = \"iconAndTextHorizontal\", image = 'diamond.jpg',c='curveCreation(\"diamond\")')\n    cmds.iconTextButton(h = 19, l = \"Pointer\",  style = \"iconAndTextHorizontal\", image = 'pointer.jpg',c='curveCreation(\"pointer\")')\n    cmds.iconTextButton(h = 19, l = \"Locator\",  style = \"iconAndTextHorizontal\", image = 'locator.xpm',c='curveCreation(\"locator\")')\n    cmds.separator(style='singleDash')\n    cmds.text('To use own curve, select curve first then joints, then hit this button.',ww=True,)\n    cmds.iconTextButton(h = 19, l = \"Use own curve\",  style = \"iconAndTextHorizontal\", image = 'owncurve.jpg',c='curveCreation(\"owncurve\")')\n    cmds.separator(style='in')\n\n\n    #COLOURS#\n    cmds.frameLayout(l='Colour')\n    cmds.gridLayout(cellWidthHeight=(19,19),nr=6,nc=6)\n    #// Yellow//#\n    cmds.iconTextButton(h = 19, l = \"17\",  style = \"iconOnly\", image = '17.jpg',c='curveColour(17)')\n    cmds.iconTextButton(h = 19, l = \"22\",  style = \"iconOnly\", image = '22.jpg',c='curveColour(22)')\n    cmds.iconTextButton(h = 19, l = \"25\",  style = \"iconOnly\", image = '25.jpg',c='curveColour(25)')\n    cmds.iconTextButton(h = 19, l = \"21\",  style = \"iconOnly\", image = '21.jpg',c='curveColour(21)')\n    cmds.iconTextButton(h = 19, l = \"24\",  style = \"iconOnly\", image = '24.jpg',c='curveColour(24)')\n    cmds.iconTextButton(h = 19, l = \"10\",  style = \"iconOnly\", image = '10.jpg',c='curveColour(10)')\n    #//Green//#\n    cmds.iconTextButton(h = 19, l = \"14\",  style = \"iconOnly\", image = '14.jpg',c='curveColour(14)')\n    cmds.iconTextButton(h = 19, l = \"19\",  style = \"iconOnly\", image = '19.jpg',c='curveColour(19)')\n    cmds.iconTextButton(h = 19, l = \"27\",  style = \"iconOnly\", image = '27.jpg',c='curveColour(27)')\n    cmds.iconTextButton(h = 19, l = \"23\",  style = \"iconOnly\", image = '23.jpg',c='curveColour(23)')\n    cmds.iconTextButton(h = 19, l = \"26\",  style = \"iconOnly\", image = '26.jpg',c='curveColour(26)')\n    cmds.iconTextButton(h = 19, l = \"7\",  style = \"iconOnly\", image = '7.jpg',c='curveColour(7)')\n    #//Blue//#\n    cmds.iconTextButton(h = 19, l = \"18\",  style = \"iconOnly\", image = '18.jpg',c='curveColour(18)')\n    cmds.iconTextButton(h = 19, l = \"28\",  style = \"iconOnly\", image = '28.jpg',c='curveColour(28)')\n    cmds.iconTextButton(h = 19, l = \"29\",  style = \"iconOnly\", image = '29.jpg',c='curveColour(29)')\n    cmds.iconTextButton(h = 19, l = \"15\",  style = \"iconOnly\", image = '15.jpg',c='curveColour(15)')\n    cmds.iconTextButton(h = 19, l = \"6\",  style = \"iconOnly\", image = '6.jpg',c='curveColour(6)')\n    cmds.iconTextButton(h = 19, l = \"5\",  style = \"iconOnly\", image = '5.jpg',c='curveColour(5)')\n    #//Red//#\n    cmds.iconTextButton(h = 19, l = \"20\",  style = \"iconOnly\", image = '20.jpg',c='curveColour(20)')\n    cmds.iconTextButton(h = 19, l = \"13\",  style = \"iconOnly\", image = '13.jpg',c='curveColour(13)')\n    cmds.iconTextButton(h = 19, l = \"4\",  style = \"iconOnly\", image = '4.jpg',c='curveColour(4)')\n    cmds.iconTextButton(h = 19, l = \"32\",  style = \"iconOnly\", image = '32.jpg',c='curveColour(32)')\n    cmds.iconTextButton(h = 19, l = \"12\",  style = \"iconOnly\", image = '12.jpg',c='curveColour(12)')\n    cmds.iconTextButton(h = 19, l = \"11\",  style = \"iconOnly\", image = '11.jpg',c='curveColour(11)') \n    #//Greyscale//#\n    cmds.iconTextButton(h = 19, l = \"1\",  style = \"iconOnly\", image = '1.jpg',c='curveColour(1)')\n    cmds.iconTextButton(h = 19, l = \"2\",  style = \"iconOnly\", image = '3.jpg',c='curveColour(3)')\n    cmds.iconTextButton(h = 19, l = \"3\",  style = \"iconOnly\", image = '16.jpg',c='curveColour(16)')\n    #//Pinks//#\n    cmds.iconTextButton(h = 19, l = \"8\",  style = \"iconOnly\", image = '8.jpg',c='curveColour(8)')\n    cmds.iconTextButton(h = 19, l = \"31\",  style = \"iconOnly\", image = '31.jpg',c='curveColour(31)')\n    cmds.iconTextButton(h = 19, l = \"9\",  style = \"iconOnly\", image = '9.jpg',c='curveColour(9)')\n\n\n    cmds.showWindow(ctrl_window)\nUI()" 
        -sourceType "python" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Move joints on smooth bound skins without affecting the skinning." 
        -enableBackground 0
        -align "center" 
        -label "Move Skinned Joints Tool" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.25 
        -image "moveSkinnedJoint.png" 
        -image1 "moveSkinnedJoint.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "MoveSkinJointsTool" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Expand the quickhelp in the script editor." 
        -enableBackground 0
        -align "center" 
        -label "////////////////////////////////////////////////////////////////..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "QHLP" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "commandButton.png" 
        -image1 "commandButton.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n///                                                                                              ///\n///               -= LoneWolf Productions =-                          __.....__                  ///\n///               --------------------------                       .-'         '-.               ///\n///                                                              .'               '.             ///\n///                                                             /                   \\            ///\n///                      Script Editor                         /        |\\           \\           ///\n///                Quick Help Window Resizer                  ;        |V \\_          ;          ///\n///                                                           |        |  ' \\         ;          ///\n///                        Autodesk                           ;        )   ,_\\        |          ///\n///                          Maya                             ;       /    |          ;          ///\n///                          2012                              \\     /      \\        /           ///\n///                         Script                              \\    |       \\      /            ///\n///                                                              '.   \\       \\   .'             ///\n///                                                                '-._|       \\-'               ///\n///         Created By : Caers Jouri aka Lone Wolf                     | |\\     |                ///\n///                     CopyRight 2011                         __lwp___/ |_'.   /______          ///\n///                                                                                              ///\n////////////////////////////////////////////////////////////////////////////////////////////////////\n///                      2011 Lone Wolf Productions.  All rights reserved.                      ///\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n///                                        Important Note                                        ///\n///                                        ==============                                        ///\n///                    !!!This script is accessing maya defined variables!!!                     ///\n///                                   Change at your own risk!                                   ///\n///                                                                                              ///\n///                  The script is not permanent, the settings will reset when,                  ///\n///                                 Quick help or Maya is closed                                 ///\n///                   this is only guaranteed if the script is used unmodified                   ///\n///                                                                                              ///\n////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////\n\nif(`window -exists quickHelpUserResizeWindow`)\n\t{\n\t\tdeleteUI -window quickHelpUserResizeWindow;\t\n\t}\n\t\nproc okQuickHelpUserResize()\n\t{\n\t\tglobal string $gCommandExecuterSideBar;\n\t\tint $newWidthQuickHelpUserResize = `intSliderGrp -q -v newQuickHelpUserResize`;\n\t\ttabLayout  -e -visible true -width $newWidthQuickHelpUserResize $gCommandExecuterSideBar;\n\t\tdeleteUI -window quickHelpUserResizeWindow;\t\t\n\t}\nproc applyQuickHelpUserResize()\n\t{\n\t\tglobal string $gCommandExecuterSideBar;\n\t\tint $newWidthQuickHelpUserResize = `intSliderGrp -q -v newQuickHelpUserResize`;\n\t\tif ($newWidthQuickHelpUserResize < 120) \n\t\t{\n\t\t\t$newWidthQuickHelpUserResize = 120;\n\t\t\tintSliderGrp -e -v 120 newQuickHelpUserResize;\n\t\t}\t\t\n\t\ttabLayout  -e -visible true -width $newWidthQuickHelpUserResize $gCommandExecuterSideBar;\n\t}\nproc resetQuickHelpUserResize()\n\t{\n\t\tglobal string $gCommandExecuterSideBar;\n\t\tintSliderGrp -e -v 120 newQuickHelpUserResize;\n\t\ttabLayout  -e -visible true -width 120 $gCommandExecuterSideBar;\n\t}\n\t\nstring $quickHelpUserResizeWindow = `window -title \"Script Editor Quick Help Resizer\" -wh 500 100  quickHelpUserResizeWindow`;\n\ncolumnLayout -w 300;\nintSliderGrp -label \"Quick Help Frame Size\" -field true\n\t\t\t\t\t\t-cal 1 \"center\"\n\t\t\t\t\t\t-v 120\n\t\t\t\t\t\t-cc applyQuickHelpUserResize\n\t\t\t\t\t\t-dc applyQuickHelpUserResize\n\t\t\t\t\t\t-minValue 120 -maxValue 500\n\t\t\t\t\t\t-fieldMinValue 0 -fieldMaxValue 500\n\t\t\t\t\t\tnewQuickHelpUserResize;\n\nseparator;\n\n\nrowColumnLayout -nc 2 -cw 1 200 -cw 2 200;\nbutton -label \"Ok\" -c okQuickHelpUserResize;\nbutton -label \"Reset\" -c resetQuickHelpUserResize;\n\n\n\nint $quickHelpResizerDisclaimerConfirmationPass;\nstring $quickHelpResizerDisclaimerConfirmation;\nstring $quickHelpResizerDisclaimer = \"Disclaimer.\"+\"\\n\"+\n\t\t\t\t\t\t\t\t\t \"\\n\"+\n\t\t\t\t\t\t\t\t\t \"You agree that you use these script on your own responsibility.\"+\"\\n\"+\n\t\t\t\t\t\t\t\t\t \"\\n\"+\n\t\t\t\t\t\t\t\t\t \" You are aware that the script may not work below Maya 2012.\"+\"\\n\"+\n\t\t\t\t\t\t\t\t\t \"\\n\"+\n\t\t\t\t\t\t\t\t\t \"These scripts will never make modifications to your system settings, as long as they are used unaltered. Any change you make, you make on your own responsibility.\"+\"\\n\"+\n\t\t\t\t\t\t\t\t\t \"\\n\"+\n\t\t\t\t\t\t\t\t\t \"Feedback and bug reports can reported on the forum where you have found this script, or at the following email address.\"+\"\\n\"+\n\t\t\t\t\t\t\t\t\t \"\\n\"+\n\t\t\t\t\t\t\t\t\t \"feedback.lone.wolf.productions@dommel.be\"+\"\\n\"+\n\t\t\t\t\t\t\t\t\t \"\\n\"+\n\t\t\t\t\t\t\t\t\t \"\\n\"+\n\t\t\t\t\t\t\t\t\t \"By pressing the OK button, you agree to the disclaimer above.\"+\"\\n\"+\n\t\t\t\t\t\t\t\t\t \"\\n\"+\n\t\t\t\t\t\t\t\t\t \"Lone Wolf Productions.\"+\"\\n\";\n\n$quickHelpResizerDisclaimerConfirmation = `confirmDialog -title \"Quick Help Resizer- Disclaimer.\"\n\t\t\t\t\t\t\t\t                         -message $quickHelpResizerDisclaimer\n\t\t\t\t\t\t\t\t                         -button \"Ok\"\n\t\t\t\t\t\t\t\t                         -button \"Cancel\"\n\t\t\t\t\t\t\t\t                         -defaultButton \"Ok\"\n\t\t\t\t\t\t\t\t                         -cancelButton \"Cancel\"\n\t\t\t\t\t\t\t\t                         -dismissString \"Cancel\"\n\t\t\t\t\t\t\t\t                         -icon \"information\"`;\nif($quickHelpResizerDisclaimerConfirmation == \"Ok\")\n\t{\n\t\tshowWindow $quickHelpUserResizeWindow;\n\t\twindow -e -wh 405 52 quickHelpUserResizeWindow;\n\t}" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Re-order custom attributes" 
        -enableBackground 0
        -align "center" 
        -label "import sk_attrShift as skattr\nskattr.sk_attrShiftUI()" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "ATTR" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "pythonFamily.png" 
        -image1 "pythonFamily.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "import sk_attrShift as skattr\nskattr.sk_attrShiftUI()" 
        -sourceType "python" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "AutoLeg" 
        -enableBackground 0
        -align "center" 
        -label "#Select upper leg joint and run.\n\nimport maya.cmds as cmds\n\ncmds..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "LEG" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "pythonFamily.png" 
        -image1 "pythonFamily.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "#Select upper leg joint and run.\n\nimport maya.cmds as cmds\n\ncmds.select(hi=True)\nbindchain = cmds.ls(sl=True)\n\n#Name bind joints\ncmds.rename(bindchain[0],'bind_upperLeg_jnt')\ncmds.rename(bindchain[1],'bind_lowerLeg_jnt')\ncmds.rename(bindchain[2],'bind_foot_jnt')\ncmds.rename(bindchain[3],'bind_footroll_jnt')\ncmds.rename(bindchain[4],'bind_toe_end')\nbindchain = cmds.ls(sl=True)\n\n#Make FK chain\ncopy = cmds.duplicate(bindchain[0],rc=True)\nfkchain = []\nfor i in copy:\n    newname = i.replace(\"bind\",\"fk\")\n    fkchain.append(cmds.rename(i,newname[0:-1]))\n\n#Make IK chain\ncopy = cmds.duplicate(bindchain[0],rc=True)\nikchain = []\nfor i in copy:\n    newname = i.replace(\"bind\",\"ik\")\n    ikchain.append(cmds.rename(i,newname[0:-1]))\n    \n#Make IK handles\ncmds.ikHandle(n='leg_IK',sj=ikchain[0],ee=ikchain[2],pw=0,sol='ikRPsolver',s='sticky')\ncmds.ikHandle(n='footroll_IK',sj=ikchain[2],ee=ikchain[3],pw=0,sol='ikSCsolver',s='sticky')\ncmds.ikHandle(n='toepivot_IK',sj=ikchain[3],ee=ikchain[4],pw=0,sol='ikSCsolver',s='sticky')\n\n#Make parent Constrains\nconstraints = []\nincr = 0\nfor i in copy:\n    fkandik = [ikchain[incr],fkchain[incr]]\n    constraints.append(cmds.parentConstraint(fkandik,i[:-1]))\n    print constraints\n    incr = incr+1\n\n#Make foot attribute control\ncmds.curve(n='foot_attribute_ctrl',d=1,p =[(-1.0, 0.0, 0.0), (-1.0, 0.0, 2.0), (1.0, 0.0, 2.0), (1.0, 0.0, 0.0), (2.0, 0.0, 0.0), (0.0, 0.0, -2.0), (-2.0, 0.0, 0.0), (-1.0, 0.0, 0.0)])\ncmds.addAttr(shortName='FKIK', niceName='FK/IK Switch', defaultValue=1.0, minValue=0.0, maxValue=1.0 )\ncmds.setAttr('foot_attribute_ctrl.FKIK',keyable=True)\n\ncmds.setAttr( \"foot_attribute_ctrl.tx\",lock = True, keyable = False, channelBox = False)\ncmds.setAttr( \"foot_attribute_ctrl.ty\",lock = True, keyable = False, channelBox = False)\ncmds.setAttr( \"foot_attribute_ctrl.tz\",lock = True, keyable = False, channelBox = False)\ncmds.setAttr( \"foot_attribute_ctrl.rx\",lock = True, keyable = False, channelBox = False)\ncmds.setAttr( \"foot_attribute_ctrl.ry\",lock = True, keyable = False, channelBox = False)\ncmds.setAttr( \"foot_attribute_ctrl.rz\",lock = True, keyable = False, channelBox = False)\ncmds.setAttr( \"foot_attribute_ctrl.sx\",lock = True, keyable = False, channelBox = False)\ncmds.setAttr( \"foot_attribute_ctrl.sy\",lock = True, keyable = False, channelBox = False)\ncmds.setAttr( \"foot_attribute_ctrl.sz\",lock = True, keyable = False, channelBox = False)\ncmds.setAttr( \"foot_attribute_ctrl.v\",lock = True, keyable = False, channelBox = False)\n\n#Make IK control\n\nikControl = cmds.curve(n='leg_IK_ctrl',d=1,p= [(-0.5, 0.5, 0.5 ), ( 0.5, 0.5, 0.5 ), ( 0.5, 0.5, -0.5 ), ( -0.5, 0.5, -0.5 ), ( -0.5, 0.5, 0.5 ), ( -0.5, -0.5, 0.5 ), ( -0.5, -0.5, -0.5 ), ( 0.5, -0.5, -0.5 ), ( 0.5, -0.5, 0.5 ), ( -0.5, -0.5, 0.5 ), ( 0.5, -0.5, 0.5 ), ( 0.5, 0.5, 0.5 ), ( 0.5, 0.5, -0.5 ), ( 0.5, -0.5, -0.5 ), ( -0.5, -0.5, -0.5 ), ( -0.5, 0.5, -0.5)])\ncmds.CenterPivot()\ncmds.group(n='leg_IK_ctrl_sdk')\ncmds.CenterPivot()\ncmds.group(n='leg_IK_ctrl_offset')\ncmds.CenterPivot()\na = cmds.parentConstraint('leg_IK','leg_IK_ctrl_offset')\ncmds.delete(a)\ncmds.select(ikControl)\n\ncmds.addAttr(shortName='Divider1', niceName='---', at = \"enum\", en = \"---:\")\ncmds.setAttr(str(ikControl)+'.Divider1',keyable=True)\n\ncmds.addAttr(shortName='footRoll', niceName='Foot Roll', defaultValue=0.0, minValue=-10.0, maxValue=10.0 )\ncmds.setAttr(str(ikControl)+'.footRoll',keyable=True)\n\ncmds.addAttr(shortName='toePivot', niceName='Toe Pivot', defaultValue=0.0, minValue=-10.0, maxValue=10.0 )\ncmds.setAttr(str(ikControl)+'.toePivot',keyable=True)\n\ncmds.addAttr(shortName='heelPivot', niceName='Heel Pivot', defaultValue=0.0, minValue=-10.0, maxValue=10.0 )\ncmds.setAttr(str(ikControl)+'.heelPivot',keyable=True)\n\ncmds.addAttr(shortName='ballPivot', niceName='Ball Pivot', defaultValue=0.0, minValue=-10.0, maxValue=10.0 )\ncmds.setAttr(str(ikControl)+'.ballPivot',keyable=True)\n\ncmds.addAttr(shortName='toeTap', niceName='Toe Tap', defaultValue=0.0, minValue=-10.0, maxValue=10.0 )\ncmds.setAttr(str(ikControl)+'.toeTap',keyable=True)\n\ncmds.addAttr(shortName='bank', niceName='Bank', defaultValue=0.0, minValue=-10.0, maxValue=10.0 )\ncmds.setAttr(str(ikControl)+'.bank',keyable=True)\n\n#cmds.parentConstraint('leg_IK_ctrl','leg_IK')\n\n#Make Polevector Control\ndef makesphere():\n    spherelist = []\n    spherelist.append(cmds.curve( p =[(0.78361162489122504, 0.0, -0.78361162489122371), (-1.2643170607829324e-16, 0.0, -1.1081941875543877), (-0.78361162489122427, 0.0, -0.78361162489122416), (-1.1081941875543879, 0.0, 0.0), (-0.78361162489122449, 0.0, 0.78361162489122371), (-3.3392053635905195e-16, 0.0, 1.1081941875543881), (0.78361162489122382, 0.0, 0.7836116248912246), (1.1081941875543879, 0.0, 8.8817841970012523e-16), (0.78361162489122504, 0.0, -0.78361162489122371), (-1.2643170607829324e-16, 0.0, -1.1081941875543877), (-0.78361162489122427, 0.0, -0.78361162489122416)],per = True, d=3, k=[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    spherelist.append(cmds.curve( p =[(0.78361162489122504, 0.78361162489122194, 0.0), (-1.2643170607829324e-16, 1.1081941875543748, 0.0), (-0.78361162489122427, 0.78361162489122194, 0.0), (-1.1081941875543879, 0.0, 0.0), (-0.78361162489122449, -0.78361162489122194, 0.0), (-3.3392053635905195e-16, -1.1081941875543748, 0.0), (0.78361162489122382, -0.78361162489122194, 0.0), (1.1081941875543879, 0.0, 0.0), (0.78361162489122504, 0.78361162489122194, 0.0), (-1.2643170607829324e-16, 1.1081941875543748, 0.0), (-0.78361162489122427, 0.78361162489122194, 0.0)],per = True, d=3, k=[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    spherelist.append(cmds.curve( p =[(1.2601436025374959e-16, 0.78361162489122194, -0.78361162489122371), (-6.7857323231109159e-17, 0.0, -1.1081941875543877), (-2.219791070735184e-16, -0.78361162489122194, -0.78361162489122416), (-2.4606854055572997e-16, -1.1081941875543748, 0.0), (-1.2601436025374919e-16, -0.78361162489122194, 0.78361162489122371), (6.7857323231108764e-17, 0.0, 1.1081941875543881), (2.219791070735184e-16, 0.78361162489122194, 0.7836116248912246), (2.4606854055573036e-16, 1.1081941875543748, 8.8817841970012523e-16), (1.2601436025374959e-16, 0.78361162489122194, -0.78361162489122371), (-6.7857323231109159e-17, 0.0, -1.1081941875543877), (-2.219791070735184e-16, -0.78361162489122194, -0.78361162489122416)],per = True, d=3, k=[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    for x in range(len(spherelist)-1):\n    \tcmds.makeIdentity(spherelist[x+1], apply=True, t=1, r=1, s=1, n=0)\n    \tshapeNode = cmds.listRelatives(spherelist[x+1], shapes=True)\n        cmds.parent(shapeNode, spherelist[0], add=True, s=True)\n    \tcmds.delete(spherelist[x+1])\n    return spherelist[0]\npolevector = makesphere()\ncmds.select(polevector)\npolevector = cmds.pickWalk(d='up')\npolevector = cmds.rename(polevector[0],'knee_ctrl')\nprint polevector\n#Place and activate polevector\ncmds.select(polevector)\ncmds.group(n='%s_sdk'%polevector)\npolevector_offset = cmds.group(n='%s_offset'%polevector)\npoleconstraint = cmds.pointConstraint('bind_upperLeg_jnt','bind_foot_jnt',polevector_offset,mo=False)\ncmds.delete(poleconstraint)\npoleconstraint = cmds.aimConstraint('bind_foot_jnt',polevector_offset)#,offset =[0, 0, 0],weight=1,aimVector=[1, 0, 0],upVector=[0, 1, 0],worldUpType= \"vector\",worldUpVector=[0, 1, 0],mo=0)\ncmds.delete(poleconstraint)\ncmds.select(d=True)\ncmds.select(bindchain[1],polevector_offset)\naimconstraint = cmds.aimConstraint()\ncmds.delete(aimconstraint)\ncmds.select(d=True)\ncmds.select(polevector,'leg_IK')\ncmds.poleVectorConstraint()\n\n#Create FK Controls\nfkControl = []\nfor i in range(0,(len(bindchain)-1)):\n    ctrl = cmds.circle(n=str(fkchain[i][:-4])+'_ctrl')\n    fkControl.append(ctrl[0])\n    sdkgrp = cmds.group(ctrl,n=str(fkchain[i][:-4])+'_sdk')\n    offsetgrp = cmds.group(sdkgrp,n=str(fkchain[i][:-4])+'_offset')\n    a = cmds.parentConstraint(fkchain[i],offsetgrp)\n    cmds.delete(a)\n    cmds.parentConstraint(ctrl,fkchain[i])\n    if i > 0:\n        cmds.parent(str(offsetgrp),str(previousCtrl))\n    previousCtrl = ctrl[0]\n\n#Create Set driven key for IK\ncmds.setAttr('foot_attribute_ctrl.FKIK', 1)\nfor i in range(0,len(bindchain)):\n    #bindchain parent constraint\n    cmds.setAttr(str(constraints[i][0])+'.'+fkchain[i]+'W1', 0)\n    cmds.setAttr(str(constraints[i][0])+'.'+ikchain[i]+'W0', 1)\n    cmds.setDrivenKeyframe(str(constraints[i][0])+'.'+ikchain[i]+'W0',currentDriver = 'foot_attribute_ctrl.FKIK')\n    cmds.setDrivenKeyframe(str(constraints[i][0])+'.'+fkchain[i]+'W1',currentDriver = 'foot_attribute_ctrl.FKIK')\n#fk control visibility\nfor i in fkControl:\n    cmds.setAttr(str(i)+'.visibility',0)\n    cmds.setDrivenKeyframe(str(i)+'.visibility',currentDriver = 'foot_attribute_ctrl.FKIK')\n#ik control visibility\ncmds.setAttr(str(ikControl)+'.visibility',1)\ncmds.setDrivenKeyframe(str(ikControl)+'.visibility',currentDriver = 'foot_attribute_ctrl.FKIK')\ncmds.setAttr(str(polevector)+'.visibility',1)\ncmds.setDrivenKeyframe(str(polevector)+'.visibility',currentDriver = 'foot_attribute_ctrl.FKIK')\n\n\n#Create Set driven key for FK\ncmds.setAttr('foot_attribute_ctrl.FKIK', 0)\nfor i in range(0,len(bindchain)):\n    cmds.setAttr(str(constraints[i][0])+'.'+fkchain[i]+'W1', 1)\n    cmds.setAttr(str(constraints[i][0])+'.'+ikchain[i]+'W0', 0)\n    cmds.setDrivenKeyframe(str(constraints[i][0])+'.'+ikchain[i]+'W0',currentDriver = 'foot_attribute_ctrl.FKIK')\n    cmds.setDrivenKeyframe(str(constraints[i][0])+'.'+fkchain[i]+'W1',currentDriver = 'foot_attribute_ctrl.FKIK')\n\n#fk control visibility\nfor i in fkControl:\n    cmds.setAttr(str(i)+'.visibility',1)\n    cmds.setDrivenKeyframe(str(i)+'.visibility',currentDriver = 'foot_attribute_ctrl.FKIK')\n#ik control visibility\ncmds.setAttr(str(ikControl)+'.visibility',0)\ncmds.setDrivenKeyframe(str(ikControl)+'.visibility',currentDriver = 'foot_attribute_ctrl.FKIK')\ncmds.setAttr(str(polevector)+'.visibility',0)\ncmds.setDrivenKeyframe(str(polevector)+'.visibility',currentDriver = 'foot_attribute_ctrl.FKIK')\n\ncmds.setAttr('foot_attribute_ctrl.FKIK', 1)\n\n#Create Foot Attribute Groups\nfootroll = cmds.group(n='footroll_grp',em=True)\nfootrollOffset = cmds.group(n='footroll_offset_grp')\n\ntoetap = cmds.group(n='toeTap_grp',em=True)\ntoeTapOffset = cmds.group(n='toeTap_offset_grp')\n\n\n#Make and group foot attribute IK groups.\ncmds.select(footrollOffset,toeTapOffset)\ntoepivot = cmds.group(n='toepivot_grp')\ncmds.group(n='toepivot_offset_grp')\n\nfootinner = cmds.group(n='footInner_grp')\ncmds.group(n='footInner_offset_grp')\n\nfootouter = cmds.group(n='footOuter_grp')\ncmds.group(n='footOuter_offset_grp')\n\nheelpivot = cmds.group(n='heelpivot_grp')\ncmds.group(n='heelpivot_offset_grp')\n\nankle = cmds.group(n='ankle_grp')\nankleOffset = cmds.group(n='ankle_offset_grp')\na = cmds.parentConstraint(ikchain[3],ankleOffset)\ncmds.delete(a)\n\ncmds.select(d=True)\ncmds.select(toeTapOffset,footrollOffset)\nballpivot = cmds.group(n='ballpivot_grp')\nballpivotOffset = cmds.group(n='ballPivot_offset_grp')\n\ncmds.parent('leg_IK','footroll_grp')\ncmds.parent('footroll_IK','footroll_grp')\ncmds.parent('toepivot_IK','toeTap_grp')\ncmds.parent('ankle_offset_grp','leg_IK_ctrl')\n\n\n#Set driven foot attributes\n#Foot roll 0\ncmds.setAttr(str(ikControl)+'.footRoll', 0)\ncmds.setDrivenKeyframe(str(footroll)+'.rotate',currentDriver = str(ikControl)+'.footRoll')\ncmds.setDrivenKeyframe(str(heelpivot)+'.rotate',currentDriver = str(ikControl)+'.footRoll')\ncmds.setDrivenKeyframe(str(toepivot)+'.rotate',currentDriver = str(ikControl)+'.footRoll')\n#Foot roll -10\ncmds.setAttr(str(ikControl)+'.footRoll', -10)\ncmds.rotate(0,0,-50,heelpivot)\ncmds.setDrivenKeyframe(str(heelpivot)+'.rotate',currentDriver = str(ikControl)+'.footRoll')\n#Foot roll +5\ncmds.setAttr(str(ikControl)+'.footRoll', 5)\ncmds.rotate(0,0,35,footroll)\ncmds.setDrivenKeyframe(str(footroll)+'.rotate',currentDriver = str(ikControl)+'.footRoll')\ncmds.setDrivenKeyframe(str(toepivot)+'.rotate',currentDriver = str(ikControl)+'.footRoll')\n#Foot roll +10\ncmds.setAttr(str(ikControl)+'.footRoll', 10)\ncmds.rotate(0,0,25,footroll)\ncmds.rotate(0,0,40,toepivot)\ncmds.setDrivenKeyframe(str(footroll)+'.rotate',currentDriver = str(ikControl)+'.footRoll')\ncmds.setDrivenKeyframe(str(toepivot)+'.rotate',currentDriver = str(ikControl)+'.footRoll')\ncmds.setAttr(str(ikControl)+'.footRoll', 0)\n\n#Toe pivot 0\ncmds.setAttr(str(ikControl)+'.toePivot', 0)\ncmds.setDrivenKeyframe(str(toepivot)+'.rotate',currentDriver = str(ikControl)+'.toePivot')\n#Toe pivot +10\ncmds.setAttr(str(ikControl)+'.toePivot', 10)\ncmds.rotate(0,0,-50,toepivot)\ncmds.setDrivenKeyframe(str(toepivot)+'.rotate',currentDriver = str(ikControl)+'.toePivot')\n#Toe pivot -10\ncmds.setAttr(str(ikControl)+'.toePivot', -10)\ncmds.rotate(0,0,50,toepivot)\ncmds.setDrivenKeyframe(str(toepivot)+'.rotate',currentDriver = str(ikControl)+'.toePivot')\ncmds.setAttr(str(ikControl)+'.toePivot', 0)\n\n#Heel pivot 0\ncmds.setAttr(str(ikControl)+'.heelPivot', 0)\ncmds.setDrivenKeyframe(str(heelpivot)+'.rotate',currentDriver = str(ikControl)+'.heelPivot')\n#Heel pivot +10\ncmds.setAttr(str(ikControl)+'.heelPivot', 10)\ncmds.rotate(0,0,-50,heelpivot)\ncmds.setDrivenKeyframe(str(heelpivot)+'.rotate',currentDriver = str(ikControl)+'.heelPivot')\n#Heel pivot -10\ncmds.setAttr(str(ikControl)+'.heelPivot', -10)\ncmds.rotate(0,0,50,heelpivot)\ncmds.setDrivenKeyframe(str(heelpivot)+'.rotate',currentDriver = str(ikControl)+'.heelPivot')\ncmds.setAttr(str(ikControl)+'.heelPivot', 0)\n\n#Ball pivot 0\ncmds.setAttr(str(ikControl)+'.ballPivot', 0)\ncmds.setDrivenKeyframe(str(ballpivot)+'.rotate',currentDriver = str(ikControl)+'.ballPivot')\n#Ball pivot +10\ncmds.setAttr(str(ikControl)+'.ballPivot', 10)\ncmds.rotate(0,-50,0,ballpivot)\ncmds.setDrivenKeyframe(str(ballpivot)+'.rotate',currentDriver = str(ikControl)+'.ballPivot')\n#Ball pivot -10\ncmds.setAttr(str(ikControl)+'.ballPivot', -10)\ncmds.rotate(0,50,0,ballpivot)\ncmds.setDrivenKeyframe(str(ballpivot)+'.rotate',currentDriver = str(ikControl)+'.ballPivot')\ncmds.setAttr(str(ikControl)+'.ballPivot', 0)\n\n#Toe Tap 0\ncmds.setAttr(str(ikControl)+'.toeTap', 0)\ncmds.setDrivenKeyframe(str(toetap)+'.rotate',currentDriver = str(ikControl)+'.toeTap')\n#Toe Tap +10\ncmds.setAttr(str(ikControl)+'.toeTap', 10)\ncmds.rotate(0,0,-35,toetap)\ncmds.setDrivenKeyframe(str(toetap)+'.rotate',currentDriver = str(ikControl)+'.toeTap')\n#Toe Tap -10\ncmds.setAttr(str(ikControl)+'.toeTap', -10)\ncmds.rotate(0,0,35,toetap)\ncmds.setDrivenKeyframe(str(toetap)+'.rotate',currentDriver = str(ikControl)+'.toeTap')\ncmds.setAttr(str(ikControl)+'.toeTap', 0)\n\n#Bank 0\ncmds.setAttr(str(ikControl)+'.bank', 0)\ncmds.setDrivenKeyframe(str(footinner)+'.rotate',currentDriver = str(ikControl)+'.bank')\ncmds.setDrivenKeyframe(str(footouter)+'.rotate',currentDriver = str(ikControl)+'.bank')\n#Bank +10\ncmds.setAttr(str(ikControl)+'.bank', 10)\ncmds.rotate(45,0,0,footinner)\ncmds.setDrivenKeyframe(str(footinner)+'.rotate',currentDriver = str(ikControl)+'.bank')\n#Bank -10\ncmds.setAttr(str(ikControl)+'.bank', -10)\ncmds.rotate(-45,0,0,footouter)\ncmds.setDrivenKeyframe(str(footouter)+'.rotate',currentDriver = str(ikControl)+'.bank')\ncmds.setAttr(str(ikControl)+'.bank', 0)\n\n\n#lock Attribs\nfor i in fkControl:\n    cmds.setAttr( str(i)+'.sx',lock = True, keyable = False, channelBox = False)\n    cmds.setAttr( str(i)+\".sy\",lock = True, keyable = False, channelBox = False)\n    cmds.setAttr( str(i)+\".sz\",lock = True, keyable = False, channelBox = False)\n    cmds.setAttr( str(i)+\".v\",lock = True, keyable = False, channelBox = False)\n\ncmds.setAttr( str(ikControl)+'.sx',lock = True, keyable = False, channelBox = False)\ncmds.setAttr( str(ikControl)+\".sy\",lock = True, keyable = False, channelBox = False)\ncmds.setAttr( str(ikControl)+\".sz\",lock = True, keyable = False, channelBox = False)\ncmds.setAttr( str(ikControl)+\".v\",lock = True, keyable = False, channelBox = False)\n" 
        -sourceType "python" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "AutoArm" 
        -enableBackground 0
        -align "center" 
        -label "import maya.cmds as cmds\n\ncmds.select(hi=True)\nbindchain = cmds...." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "ARM" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "pythonFamily.png" 
        -image1 "pythonFamily.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "import maya.cmds as cmds\n\ncmds.select(hi=True)\nbindchain = cmds.ls(sl=True)\n\n#Name bind joints\ncmds.rename(bindchain[0],'bind_upperArm_jnt')\ncmds.rename(bindchain[1],'bind_lowerArm_jnt')\ncmds.rename(bindchain[2],'bind_arm_end')\n#cmds.rename(bindchain[5],'bind_toe_end')\n\nbindchain = cmds.ls(sl=True)\n\n#Make FK chain\ncopy = cmds.duplicate(bindchain[0],rc=True)\nfkchain = []\nfor i in copy:\n    newname = i.replace(\"bind\",\"fk\")\n    fkchain.append(cmds.rename(i,newname[0:-1]))\n\n#Make IK chain\ncopy = cmds.duplicate(bindchain[0],rc=True)\nikchain = []\nfor i in copy:\n    newname = i.replace(\"bind\",\"ik\")\n    ikchain.append(cmds.rename(i,newname[0:-1]))\n    \n#Make IK handles\ncmds.ikHandle(n='Arm_IK',sj=ikchain[0],ee=ikchain[2],pw=0,sol='ikRPsolver',s='sticky')\n\n#Make parent Constrains\nincr = 0\nconstraints = []\nfor i in copy:\n    fkandik = [ikchain[incr],fkchain[incr]]\n    constraints.append(cmds.parentConstraint(fkandik,i[:-1]))\n    incr = incr+1\n\n#Make arm attribute control\ncmds.curve(n='arm_attribute_ctrl',d=1,p =[(-1.0, 0.0, 0.0), (-1.0, 0.0, 2.0), (1.0, 0.0, 2.0), (1.0, 0.0, 0.0), (2.0, 0.0, 0.0), (0.0, 0.0, -2.0), (-2.0, 0.0, 0.0), (-1.0, 0.0, 0.0)])\ncmds.addAttr(shortName='FKIK', niceName='FK/IK Switch', defaultValue=0.0, minValue=0.0, maxValue=1.0 )\ncmds.setAttr('arm_attribute_ctrl.FKIK',keyable=True)\ncmds.setAttr( \"arm_attribute_ctrl.tx\",lock = True, keyable = False, channelBox = False)\ncmds.setAttr( \"arm_attribute_ctrl.ty\",lock = True, keyable = False, channelBox = False)\ncmds.setAttr( \"arm_attribute_ctrl.tz\",lock = True, keyable = False, channelBox = False)\ncmds.setAttr( \"arm_attribute_ctrl.rx\",lock = True, keyable = False, channelBox = False)\ncmds.setAttr( \"arm_attribute_ctrl.ry\",lock = True, keyable = False, channelBox = False)\ncmds.setAttr( \"arm_attribute_ctrl.rz\",lock = True, keyable = False, channelBox = False)\ncmds.setAttr( \"arm_attribute_ctrl.sx\",lock = True, keyable = False, channelBox = False)\ncmds.setAttr( \"arm_attribute_ctrl.sy\",lock = True, keyable = False, channelBox = False)\ncmds.setAttr( \"arm_attribute_ctrl.sz\",lock = True, keyable = False, channelBox = False)\ncmds.setAttr( \"arm_attribute_ctrl.v\",lock = True, keyable = False, channelBox = False)\n\n#Make IK control\n\nikControl = cmds.curve(n='arm_IK_ctrl',d=1,p= [(-0.5, 0.5, 0.5 ), ( 0.5, 0.5, 0.5 ), ( 0.5, 0.5, -0.5 ), ( -0.5, 0.5, -0.5 ), ( -0.5, 0.5, 0.5 ), ( -0.5, -0.5, 0.5 ), ( -0.5, -0.5, -0.5 ), ( 0.5, -0.5, -0.5 ), ( 0.5, -0.5, 0.5 ), ( -0.5, -0.5, 0.5 ), ( 0.5, -0.5, 0.5 ), ( 0.5, 0.5, 0.5 ), ( 0.5, 0.5, -0.5 ), ( 0.5, -0.5, -0.5 ), ( -0.5, -0.5, -0.5 ), ( -0.5, 0.5, -0.5)])\ncmds.CenterPivot()\ncmds.group(n='arm_IK_ctrl_sdk')\ncmds.CenterPivot()\ncmds.group(n='arm_IK_ctrl_offset')\ncmds.CenterPivot()\na = cmds.parentConstraint('Arm_IK','arm_IK_ctrl_offset')\ncmds.delete(a)\ncmds.parentConstraint('arm_IK_ctrl','Arm_IK')\n\n#Make Polevector Control\ndef makesphere():\n    spherelist = []\n    spherelist.append(cmds.curve( p =[(0.78361162489122504, 0.0, -0.78361162489122371), (-1.2643170607829324e-16, 0.0, -1.1081941875543877), (-0.78361162489122427, 0.0, -0.78361162489122416), (-1.1081941875543879, 0.0, 0.0), (-0.78361162489122449, 0.0, 0.78361162489122371), (-3.3392053635905195e-16, 0.0, 1.1081941875543881), (0.78361162489122382, 0.0, 0.7836116248912246), (1.1081941875543879, 0.0, 8.8817841970012523e-16), (0.78361162489122504, 0.0, -0.78361162489122371), (-1.2643170607829324e-16, 0.0, -1.1081941875543877), (-0.78361162489122427, 0.0, -0.78361162489122416)],per = True, d=3, k=[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    spherelist.append(cmds.curve( p =[(0.78361162489122504, 0.78361162489122194, 0.0), (-1.2643170607829324e-16, 1.1081941875543748, 0.0), (-0.78361162489122427, 0.78361162489122194, 0.0), (-1.1081941875543879, 0.0, 0.0), (-0.78361162489122449, -0.78361162489122194, 0.0), (-3.3392053635905195e-16, -1.1081941875543748, 0.0), (0.78361162489122382, -0.78361162489122194, 0.0), (1.1081941875543879, 0.0, 0.0), (0.78361162489122504, 0.78361162489122194, 0.0), (-1.2643170607829324e-16, 1.1081941875543748, 0.0), (-0.78361162489122427, 0.78361162489122194, 0.0)],per = True, d=3, k=[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    spherelist.append(cmds.curve( p =[(1.2601436025374959e-16, 0.78361162489122194, -0.78361162489122371), (-6.7857323231109159e-17, 0.0, -1.1081941875543877), (-2.219791070735184e-16, -0.78361162489122194, -0.78361162489122416), (-2.4606854055572997e-16, -1.1081941875543748, 0.0), (-1.2601436025374919e-16, -0.78361162489122194, 0.78361162489122371), (6.7857323231108764e-17, 0.0, 1.1081941875543881), (2.219791070735184e-16, 0.78361162489122194, 0.7836116248912246), (2.4606854055573036e-16, 1.1081941875543748, 8.8817841970012523e-16), (1.2601436025374959e-16, 0.78361162489122194, -0.78361162489122371), (-6.7857323231109159e-17, 0.0, -1.1081941875543877), (-2.219791070735184e-16, -0.78361162489122194, -0.78361162489122416)],per = True, d=3, k=[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    for x in range(len(spherelist)-1):\n    \tcmds.makeIdentity(spherelist[x+1], apply=True, t=1, r=1, s=1, n=0)\n    \tshapeNode = cmds.listRelatives(spherelist[x+1], shapes=True)\n        cmds.parent(shapeNode, spherelist[0], add=True, s=True)\n    \tcmds.delete(spherelist[x+1])\n    return spherelist[0]\npolevector = makesphere()\ncmds.select(polevector)\npolevector = cmds.pickWalk(d='up')\npolevector = cmds.rename(polevector[0],'elbow_ctrl')\nprint polevector\n#Place and activate polevector\ncmds.select(polevector)\ncmds.group(n='%s_sdk'%polevector)\npolevector_offset = cmds.group(n='%s_offset'%polevector)\npoleconstraint = cmds.pointConstraint('bind_upperArm_jnt','bind_arm_end',polevector_offset,mo=False)\ncmds.delete(poleconstraint)\npoleconstraint = cmds.aimConstraint('bind_arm_end',polevector_offset)#,offset =[0, 0, 0],weight=1,aimVector=[1, 0, 0],upVector=[0, 1, 0],worldUpType= \"vector\",worldUpVector=[0, 1, 0],mo=0)\ncmds.delete(poleconstraint)\ncmds.select(d=True)\ncmds.select(bindchain[1],polevector_offset)\naimconstraint = cmds.aimConstraint()\ncmds.delete(aimconstraint)\ncmds.select(d=True)\ncmds.select(polevector,'Arm_IK')\ncmds.poleVectorConstraint()\n\n#Make FK controls\nfkControl = []\nfor i in range(0,(len(bindchain)-1)):\n    ctrl = cmds.circle(n=str(fkchain[i][:-4])+'_ctrl')\n    fkControl.append(ctrl[0])\n    sdkgrp = cmds.group(ctrl,n=str(fkchain[i][:-4])+'_sdk')\n    offsetgrp = cmds.group(sdkgrp,n=str(fkchain[i][:-4])+'_offset')\n    a = cmds.parentConstraint(fkchain[i],offsetgrp)\n    cmds.delete(a)\n    cmds.parentConstraint(ctrl,fkchain[i])\n    if i > 0:\n        cmds.parent(str(offsetgrp),str(previousCtrl))\n    previousCtrl = ctrl[0]\n\n#Create Set driven key for IK\nfor i in range(0,len(bindchain)):\n    cmds.setAttr(str(constraints[i][0])+'.'+fkchain[i]+'W1', 1)\n    cmds.setAttr(str(constraints[i][0])+'.'+ikchain[i]+'W0', 0)\n    cmds.setDrivenKeyframe(str(constraints[i][0])+'.'+ikchain[i]+'W0',currentDriver = 'arm_attribute_ctrl.FKIK')\n    cmds.setDrivenKeyframe(str(constraints[i][0])+'.'+fkchain[i]+'W1',currentDriver = 'arm_attribute_ctrl.FKIK')\n#Control Visibility\nfor i in fkControl:\n    cmds.setAttr(str(i)+'.visibility',1)\n    cmds.setDrivenKeyframe(str(i)+'.visibility',currentDriver = 'arm_attribute_ctrl.FKIK')\ncmds.setAttr(str(ikControl)+'.visibility',0)\ncmds.setDrivenKeyframe(str(ikControl)+'.visibility',currentDriver = 'arm_attribute_ctrl.FKIK')\ncmds.setAttr(str(polevector)+'.visibility',0)\ncmds.setDrivenKeyframe(str(polevector)+'.visibility',currentDriver = 'arm_attribute_ctrl.FKIK')\n\n\n\n#Create Set driven key for FK\ncmds.setAttr('arm_attribute_ctrl.FKIK', 1)\nfor i in range(0,len(bindchain)):\n    cmds.setAttr(str(constraints[i][0])+'.'+fkchain[i]+'W1', 0)\n    cmds.setAttr(str(constraints[i][0])+'.'+ikchain[i]+'W0', 1)\n    cmds.setDrivenKeyframe(str(constraints[i][0])+'.'+ikchain[i]+'W0',currentDriver = 'arm_attribute_ctrl.FKIK')\n    cmds.setDrivenKeyframe(str(constraints[i][0])+'.'+fkchain[i]+'W1',currentDriver = 'arm_attribute_ctrl.FKIK')\n#Control Visibility\nfor i in fkControl:\n    cmds.setAttr(str(i)+'.visibility',0)\n    cmds.setDrivenKeyframe(str(i)+'.visibility',currentDriver = 'arm_attribute_ctrl.FKIK')\ncmds.setAttr(str(ikControl)+'.visibility',1)\ncmds.setDrivenKeyframe(str(ikControl)+'.visibility',currentDriver = 'arm_attribute_ctrl.FKIK')\ncmds.setAttr(str(polevector)+'.visibility',1)\ncmds.setDrivenKeyframe(str(polevector)+'.visibility',currentDriver = 'arm_attribute_ctrl.FKIK')\n" 
        -sourceType "python" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Autohand tool." 
        -enableBackground 0
        -align "center" 
        -label "import maya.cmds as cmds\nimport time\nfrom maya.mel import eval\n\n..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "HAND" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "pythonFamily.png" 
        -image1 "pythonFamily.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "import maya.cmds as cmds\nimport time\nfrom maya.mel import eval\n\n\n\n\ndef lockValues(obj,t=1,r=1,s=1,v=1):\n    if t == 1:\n        cmds.setAttr(obj+'.tx',lock =1, keyable=0, channelBox = 0)\n        cmds.setAttr(obj+'.ty',lock =1, keyable=0, channelBox = 0)\n        cmds.setAttr(obj+'.tz',lock =1, keyable=0, channelBox = 0)\n    if r == 1:    \n        cmds.setAttr(obj+'.rx',lock =1, keyable=0, channelBox = 0)\n        cmds.setAttr(obj+'.ry',lock =1, keyable=0, channelBox = 0)\n        cmds.setAttr(obj+'.rz',lock =1, keyable=0, channelBox = 0)\n    if s == 1:\n        cmds.setAttr(obj+'.sx',lock =1, keyable=0, channelBox = 0)\n        cmds.setAttr(obj+'.sy',lock =1, keyable=0, channelBox = 0)\n        cmds.setAttr(obj+'.sz',lock =1, keyable=0, channelBox = 0)\n    if v == 1:\n        cmds.setAttr(obj+'.v',lock =1, keyable=0, channelBox = 0)\n\n\n\ndef tempHandRig():\n    #Make Square Curves and rotate them\n    global squareCurvesTrans\n    squareCurves = []\n    squareCurvesOffset = []\n    squareCurvesTrans = []\n    footPivotLocators = []\n    \n    fingerSquares = []\n    fingerNames = ['thumb','index','middle','pinky']\n\n    Square = cmds.curve(n='Square',d=1, p = [(-1, 0, 1), (-1, 0, -1), (1, 0, -1), (1, 0, 1), (-1, 0, 1)])\n    cmds.select(Square+'.cv[:]')\n    cmds.rotate(90,0,0)\n    \n    \n    #Create Finger Curves\n    for j in range(0,4): #### NO. OF FINGERS\n        for i in range(0,4): #### NO. OF JOINTS PER FINGER\n            currentFinger = fingerNames[j]\n            tempFingerSquare = cmds.duplicate(Square,n=currentFinger+'_joint'+str(i+1))\n            cmds.move(j*3,0,i*3,tempFingerSquare)\n            fingerSquares.append(tempFingerSquare[0])\n            squareCurves.append(tempFingerSquare[0])\n    \n        \n    \n    #Seperate curves into finger lists\n    thumbSquares = fingerSquares[0:4]\n    indexSquares = fingerSquares[4:8]\n    midSquares = fingerSquares[8:12]\n    pinkySquares = fingerSquares[12:16]\n    #Additional hand curves\n    global wristSquare\n    wristSquare = cmds.duplicate(Square,n='wristSquare')\n    rootPinkySquare = cmds.duplicate(Square,n='rootPinkySquare')\n    #Delete initial curve\n    cmds.delete(Square)\n    #Populate main list\n    squareCurves.extend([wristSquare[0],rootPinkySquare[0]])\n    \n        \n    for i in squareCurves:\n        print i\n        #Make Offsets\n        squareCurvesOffset.append(cmds.group(i,n=i+'_offset'))\n        #Set Main Colour\n        cmds.setAttr(i + '.overrideEnabled', 1)\n        cmds.setAttr(i + '.overrideColor', 17)\n        #Make mini translation controls\n        a = cmds.duplicate(i , n= i + '_trans')\n        squareCurvesTrans.append(a[0])\n        cmds.scale(0.5,0.5,0.5,a)\n        #Set mini translation control colour & scale\n        cmds.setAttr(a[0] + '.overrideEnabled', 1)\n        cmds.setAttr(a[0] + '.overrideColor', 16)\n        cmds.parent(a,[i])\n        lockValues(str(a[0]),t=0,r=1,s=1,v=1)\n    for i in fingerSquares:\n            lockValues(i,t=0,r=0,s=1,v=1)\n    \n    lockValues(wristSquare[0],t=0,r=0,s=0,v=1)\n    lockValues(rootPinkySquare[0],t=0,r=0,s=0,v=1)\n    \n    #Assign trans squares to lists\n    thumbSquaresTrans = squareCurvesTrans[0:4]\n    indexSquaresTrans = squareCurvesTrans[4:8]\n    midSquaresTrans = squareCurvesTrans[8:12]\n    pinkySquaresTrans = squareCurvesTrans[12:16]\n    \n    thumbOffsets = []\n    indexOffsets = []\n    midOffsets = []\n    pinkyOffsets = []\n    \n    for i in range(0,4):\n        temp = cmds.listRelatives(thumbSquares[i],p=1)[0]\n        thumbOffsets.append(temp)\n        temp = cmds.listRelatives(indexSquares[i],p=1)[0]\n        indexOffsets.append(temp)    \n        temp = cmds.listRelatives(midSquares[i],p=1)[0]\n        midOffsets.append(temp)\n        temp = cmds.listRelatives(pinkySquares[i],p=1)[0]\n        pinkyOffsets.append(temp)\n       \n    #Parent SquareCurve Offsets\n    for i in range(0,(len(indexSquares)-1)):\n        print i,i+1\n        #Finally, parent\n        cmds.parent(thumbOffsets[i+1],thumbSquares[i])\n        cmds.parent(indexOffsets[i+1],indexSquares[i])\n        cmds.parent(midOffsets[i+1],midSquares[i])\n        cmds.parent(pinkyOffsets[i+1],pinkySquares[i])\n    \n    \n    \n    \n    #Position wristSquare\n    cmds.move(4.5,0,-9,squareCurvesOffset[-2])\n    cmds.scale(2,2,2,squareCurvesOffset[-2])\n    cmds.move(8.5,0,-5,squareCurvesOffset[-1])\n    #Position thumb\n    cmds.move(0,0,-4, thumbOffsets[0])\n    cmds.rotate(0,-20,0, thumbOffsets[0])\n    cmds.rotate(0,20,0, thumbOffsets[1])\n    \n    \n    #Hierarchy Parenting \n    rootPinkyOffset = cmds.listRelatives(rootPinkySquare[0],p=1)[0]\n    \n    cmds.parent(pinkyOffsets[0],rootPinkySquare[0])\n    \n    cmds.parent(thumbOffsets[0],wristSquare[0])\n    cmds.parent(indexOffsets[0],wristSquare[0])\n    cmds.parent(midOffsets[0],wristSquare[0])\n    cmds.parent(rootPinkyOffset,wristSquare[0])\n    \n    '''\n    for i in range(0,len(squareCurves)):\n    CTr = cmds.xform(squareCurves[4],t=1,q=1,r=1,os=1)\n    OTr = cmds.xform(squareCurvesOffset[4],t=1,q=1,r=1,os=1)\n    cmds.xform(squareCurvesOffset[4],t=(CTr[0]+OTr[0],CTr[1]+OTr[1],CTr[2]+OTr[2]),os=1)\n    cmds.xform(squareCurves[4],t=(0,0,0),os=1)\n    ''' \n    \n    \n        \n    #Create lines\n    global hand_line_grp\n    global hand_clr_grp\n    hand_line_grp = cmds.group(em=1,n='hand_lines_grp')\n    hand_clr_grp = cmds.group(em=1,n='hand_cluster_grp') \n    \n    def addLines(list):\n        for i in range(0,(len(list))):\n            limit = len(list)-2\n            if i <= limit:\n                #Build curve & start/end clusters\n                newCurve = cmds.curve(n=list[i]+'_curve',d=1, p = [(0, 0, 0), (1, 0, 0)])\n                cmds.select(newCurve+'.cv[0]')\n                startCl = cmds.cluster(n=list[i]+'_start')\n                cmds.select(newCurve+'.cv[1]')\n                endCl = cmds.cluster(n=list[i]+'_end')\n                #Position clusters & parent\n                cmds.parentConstraint(list[i],startCl,mo=0)\n                cmds.parentConstraint(list[i+1],endCl,mo=0)\n                #Colour\n                cmds.setAttr(newCurve + '.overrideEnabled', 1)\n                cmds.setAttr(newCurve + '.overrideColor', 13)\n                #Tidy into groups\n                cmds.parent(newCurve, hand_line_grp)\n                cmds.parent(startCl, endCl, hand_clr_grp)\n    \n    \n    #Add pinky root to pinky list\n    rootPinkySquareTrans = cmds.listRelatives(rootPinkySquare[0],c=1)[1]\n    pinkySquaresTrans.insert(0,rootPinkySquareTrans)\n    \n    #Make lists for lines to join from wrist to fingers\n    global wristSquareTrans\n    global wristSquareOffset\n    wristSquareTrans = cmds.listRelatives(wristSquare[0],c=1)[1]\n    wristSquareOffset = cmds.listRelatives(wristSquare[0],p=1)[0]\n    wrist2pinky = [wristSquareTrans,pinkySquaresTrans[0]]\n    wrist2thumb = [wristSquareTrans,thumbSquaresTrans[0]]\n    wrist2index = [wristSquareTrans,indexSquaresTrans[0]]\n    wrist2mid = [wristSquareTrans,midSquaresTrans[0]]\n    \n    #all lists combined for function\n    global fingerLists\n    fingerLists = [thumbSquaresTrans,indexSquaresTrans,midSquaresTrans,pinkySquaresTrans,wrist2pinky,wrist2thumb,wrist2index,wrist2mid]\n    \n    for i in fingerLists:\n        addLines(i)\n    \n    \n    #Create tempHandRig Group\n    global tempHand_grp\n    tempHand_grp = cmds.group(em=1,n='tempHandRig_grp')\n    cmds.parent(hand_clr_grp,hand_line_grp,wristSquareOffset,tempHand_grp)\n    \n    #Cluster visibility = 0\n    cmds.setAttr(hand_clr_grp+'.visibility',0)\n    print tempHand_grp\n    \n    #Deselect everything\n    cmds.select(d=1)\n\n\n##############################################################################################################################\n###                                                 BUILD SKELETON                                                         ###\n############################################################################################################################## \n\ndef createBones():\n    cmds.select(d=1)\n    \n    def addJoints(list):\n        tempList = []\n        for i in range(0,(len(list))):\n            limit = len(list)-1\n            if i <= limit:\n                #Build curve & start/end clusters\n                listJoint = cmds.joint(n=list[i][:-12]+str(i+1)+'_jnt',p=(0,0,2))\n                jntPos = cmds.xform(list[i],t=1,q=1,ws=1)\n                cmds.move(jntPos[0],jntPos[1],jntPos[2],listJoint,pcp=1,rpr=1,oj='xyz',sao='yup')\n                #Position clusters & parent\n                tempList.append(listJoint)\n        cmds.select(d=1)\n        #Put joints into list and return\n        cmds.listRelatives(tempList[0],c=1)\n        a = cmds.listRelatives(tempList[0],ad=1)\n        incr = 0\n        for i in reversed(a):\n            tempList[incr+1] = i\n            incr = incr+1\n        return tempList\n    \n    global handJointList\n    handJointList =[]\n    \n    def buildSkeleton():\n        for i in fingerLists[0:4]:\n            handJointList.append(addJoints(i))\n        wristStartJnt = cmds.joint(n='wrist_jnt',p=(0,0,0))\n        wristEndJnt = cmds.joint('wrist_jnt',n='wrist_end',p=(0,0,2))\n        wPC = cmds.parentConstraint(wristSquareTrans,wristStartJnt,mo=0)\n        cmds.delete(wPC)\n        cmds.select(d=1)\n        for i in handJointList:\n            cmds.parent(i[0],wristStartJnt)\n            #Orient end joints\n            cmds.setAttr(i[-1]+'.jointOrientX',0)\n            cmds.setAttr(i[-1]+'.jointOrientY',0)\n            cmds.setAttr(i[-1]+'.jointOrientZ',0)\n        return wristStartJnt\n    \n    global wristStartJnt\n    wristStartJnt = buildSkeleton()\n    \n    cmds.select(wristStartJnt+'.rotateAxis')\n    cmds.rotate(0,0,90,r=1,os=1)\n    cmds.select(d=1)\n\n##############################################################################################################################\n###                                              Build Attribute Controls                                                  ###\n##############################################################################################################################\n\n\n\ndef makeControlGroups(object):\n    sdk = cmds.group(object,n=object+'_sdk')\n    offset = cmds.group(n=object+'_offset')\n    return offset,sdk\n\n    \ndef buildAttributeControls():\n    #Build main finger attribute control\n    mainAttrCtrl = mel.eval(\"curve -n finger_attr_ctrl -d 3 -p 0 0 -2 -p 5 0 -2 -p 6 0 -2 -p 7 0 0 -p 6 0 2 -p 5 0 2 -p 0 0 2 -p -5 0 2 -p -6 0 2 -p -7 0 0 -p -6 0 -2 -p -5 0 -2 -p 0 0 -2 -k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 9 -k 10 -k 10 -k 10 ;\")\n    cmds.scale(1,1,0.669,mainAttrCtrl)\n    #Set main finger attribute control colour\n    cmds.setAttr(mainAttrCtrl + '.overrideEnabled', 1)\n    cmds.setAttr(mainAttrCtrl + '.overrideColor', 17)\n    mainAttrCtrlOffset = makeControlGroups(mainAttrCtrl)[0]\n    cmds.move(4.5,0,0,mainAttrCtrlOffset)\n    \n    #Build finger attribute controls\n    tempAttrCtrl = cmds.circle(n='temp_attr_ctrl')[0]\n    cmds.select(tempAttrCtrl+'.cv[:]')\n    cmds.rotate(90,0,0)\n    cmds.select(d=1)\n    \n    fingerAttrCtrls = []\n    fingerAttrOffsets = []\n    fingerAttrSDKs = []\n    fingerAttrLocators = []\n    fingerLocPC = []\n    fingerAttrNames = ['thumb_attr_ctrl','index_attr_ctrl','mid_attr_ctrl','pinky_attr_ctrl']\n    \n    for i in range(0,4): ###No. of fingers\n        tempFingerAttrCtrl = cmds.duplicate(tempAttrCtrl,n=fingerAttrNames[i])[0]\n        fingerAttrCtrls.append(tempFingerAttrCtrl)\n        cmds.move(i*3,0,0, tempFingerAttrCtrl)\n        cmds.setAttr(tempFingerAttrCtrl + '.overrideEnabled', 1)\n        cmds.setAttr(tempFingerAttrCtrl + '.overrideColor', 16)\n        tempLoc = cmds.spaceLocator(n=fingerAttrNames[i]+'_loc')\n        fingerAttrLocators.append(tempLoc[0])\n        tempFingerGrps = makeControlGroups(tempFingerAttrCtrl)\n        fingerAttrOffsets.append(tempFingerGrps[0])\n        fingerAttrSDKs.append(tempFingerGrps[1])\n        locPC = cmds.parentConstraint(tempFingerAttrCtrl,tempLoc,mo=0)\n        fingerLocPC.append(locPC[0])\n        cmds.parent(fingerAttrOffsets[i],mainAttrCtrl)\n    cmds.delete(tempAttrCtrl)\n    \n    \n\n    #Get scale of handRig first\n    global rigScale\n    rigScale = cmds.getAttr(wristSquare[0]+'.scaleX')\n    #Position and scale accordingly to scale\n    mainAttrPC = cmds.parentConstraint(wristSquare,mainAttrCtrlOffset,mo=0)\n    cmds.delete(mainAttrPC)\n    cmds.move(0,10*rigScale,0,mainAttrCtrlOffset,r=1,os=1)\n    cmds.rotate(90,0,0,mainAttrCtrlOffset,r=1,os=1)\n    cmds.delete(fingerLocPC[:])\n    cmds.scale(1*rigScale,1*rigScale,1*rigScale,mainAttrCtrlOffset)\n    #Lock main finger attr to 5 to -5\n    #cmds.transformLimits(mainAttrCtrl,tz =(-5, 5),etz=(True,True ))\n    \n    \n    dualPC = []\n    #Set up dual parent constraint between locator and main finger control TO individual finger control\n    for i in range(0,4):\n        #locPCAttr = str(locPC2)+\".\"+str(fingerAttrCtrls[i])+\"_locW1\"\n        cmds.parent(fingerAttrOffsets[i],w=1)\n        locPC2 = cmds.parentConstraint(mainAttrCtrl,fingerAttrLocators[i],fingerAttrSDKs[i],st=[\"x\",\"y\"],sr=[\"x\",\"y\",\"z\"])[0]\n        dualPC.append(locPC2)\n        cmds.setAttr(str(locPC2)+\".\"+str(fingerAttrCtrls[i])+\"_locW1\",0)\n        #Create SDK magic for translateX\n        locPCAttr = str(dualPC[i])+\".\"+str(fingerAttrLocators[i])+\"W1\"\n        mainPCAttr = str(dualPC[i])+\".\"+str(mainAttrCtrl)+\"W0\"\n    \n    \n    \n    ####### Set SDK'S POSITIVE\n    incr = 1\n    movement = 1\n    for i in range(0,4):\n        locPCAttr = str(dualPC[i])+\".\"+str(fingerAttrLocators[i])+\"W1\"\n        mainPCAttr = str(dualPC[i])+\".\"+str(mainAttrCtrl)+\"W0\"\n        #Initial SDK\n        cmds.setAttr(locPCAttr,0)\n        cmds.setAttr(mainPCAttr,1)\n        cmds.setDrivenKeyframe(locPCAttr,currentDriver = mainAttrCtrl+'.translateX')\n        cmds.setDrivenKeyframe(mainPCAttr,currentDriver = mainAttrCtrl+'.translateX')\n        #Move\n        movement = incr*3\n        print movement\n        cmds.move(movement,0,0,mainAttrCtrl,r=1,os=1)\n        cmds.setAttr(locPCAttr,1)\n        cmds.setAttr(mainPCAttr,0)\n        cmds.setDrivenKeyframe(locPCAttr,currentDriver = mainAttrCtrl+'.translateX')\n        cmds.setDrivenKeyframe(mainPCAttr,currentDriver = mainAttrCtrl+'.translateX')\n        incr = incr+1\n        cmds.setAttr(mainAttrCtrl+\".translateX\", 0)\n    \n    \n    incr = 1\n    movement = 1\n    for i,j in zip( reversed(fingerAttrLocators), reversed(dualPC) ):\n        # now i = fingerAttrLocators\n        #     j = dualPC\n        negLocPCAttr = str(j)+\".\"+str(i)+\"W1\"\n        negMainPCAttr = str(j)+\".\"+str(mainAttrCtrl)+\"W0\"\n        print movement\n        ####### Set SDK'S (NEGATIVE)\n        #Initial SDK\n        cmds.setAttr(negLocPCAttr,0)\n        cmds.setAttr(negMainPCAttr,1)\n        cmds.setDrivenKeyframe(negLocPCAttr,currentDriver = mainAttrCtrl+'.translateX')\n        cmds.setDrivenKeyframe(negMainPCAttr,currentDriver = mainAttrCtrl+'.translateX')\n        #Move\n        movement = incr*-3\n        cmds.setAttr(mainAttrCtrl+\".translateX\", movement)\n        cmds.setAttr(negLocPCAttr,1)\n        cmds.setAttr(negMainPCAttr,0)\n        cmds.setDrivenKeyframe(negLocPCAttr,currentDriver = mainAttrCtrl+'.translateX')\n        cmds.setDrivenKeyframe(negMainPCAttr,currentDriver = mainAttrCtrl+'.translateX')\n        incr = incr+1\n        cmds.setAttr(mainAttrCtrl+\".translateX\", 0)\n    \n    \n    \n    #Lock attribs\n    lockValues(mainAttrCtrl,t=0,r=1,s=1,v=1)\n    cmds.setAttr(mainAttrCtrl+'.ty',lock =1, keyable=0, channelBox = 0)\n    \n    for i in fingerAttrCtrls:\n        lockValues(i,t=0,r=1,s=1,v=1)\n        cmds.setAttr(i+'.tx',lock =1, keyable=0, channelBox = 0)\n        cmds.setAttr(i+'.ty',lock =1, keyable=0, channelBox = 0)\n        \n    global driverLocs\n    driverLocs = []\n    #Create driver locators\n    for i in fingerAttrCtrls:\n        tempDriveLoc = cmds.spaceLocator(n=i+'_driveLoc')[0]\n        driverLocs.append(tempDriveLoc)\n        driveLocPC = cmds.parentConstraint(i,tempDriveLoc)\n        cmds.delete(driveLocPC)\n        cmds.makeIdentity(tempDriveLoc,a=1,t=1,r=1,s=1,n=0,pn=1)\n        cmds.parentConstraint(i,tempDriveLoc)\n    \n    \n    #Tidy into groups\n    global attrGrp\n    attrLocGrp = cmds.group(fingerAttrLocators,n='fingerAttribute_locators')\n    attrCtrlGrp = cmds.group(fingerAttrOffsets,n='fingerAttribute_ctrls')\n    driveLocGrp = cmds.group(driverLocs,n='driver_locators')\n    attrGrp = cmds.group(attrLocGrp,attrCtrlGrp,mainAttrCtrlOffset,driveLocGrp,n='handAttribute_grp')\n    \n    #hide Locators\n    cmds.setAttr(attrLocGrp+'.v',0)\n    cmds.setAttr(driveLocGrp+'.v',0)\n\n\n\n\n##############################################################################################################################\n###                                                 Finger Controls                                                        ###\n##############################################################################################################################\n\n\n#Seperate Small function to create circular controls \ndef makeControl(name):\n    ctrl = cmds.circle(n=name)[0]\n    groups = makeControlGroups(ctrl)\n    return ctrl,groups[0],groups[1]\n\n\n#Main function to create controls\ndef buildControls():\n    \n    #Set lists\n    fingerCtrlList = []\n    fingerCtrlSDK = []\n    fingerCtrlOffset = []\n    \n    #Divide it up into fingers\n    thumbJointList = handJointList[0]\n    indexJointList = handJointList[1]\n    midJointList = handJointList[2]\n    pinkyJointList = handJointList[3]\n    \n    #Make the controls for each item in finger lists\n    for list in handJointList:\n        for i in list[:-1]:\n            print i\n            a = makeControl(i+'_ctrl')\n            cmds.scale(rigScale,rigScale,rigScale,a[0]+'.cv[:]')\n            print a[0],a[1],a[2]\n            fingerCtrlList.append(a[0])\n            fingerCtrlSDK.append(a[2])\n            fingerCtrlOffset.append(a[1])\n            ctrlPC = cmds.parentConstraint(i,a[1])\n            cmds.delete(ctrlPC)\n            cmds.parentConstraint(a[0],i)\n    \n    global thumbCtrlSDK\n    global indexCtrlSDK\n    global midCtrlSDK\n    global pinkyCtrlSDK\n    thumbCtrlList = fingerCtrlList[0:3]\n    thumbCtrlSDK = fingerCtrlSDK[0:3]\n    thumbCtrlOffset = fingerCtrlOffset[0:3]\n    \n    indexCtrlList = fingerCtrlList[3:6]\n    indexCtrlSDK = fingerCtrlSDK[3:6]\n    indexCtrlOffset = fingerCtrlOffset[3:6]\n    \n    midCtrlList = fingerCtrlList[6:9]\n    midCtrlSDK =fingerCtrlSDK[6:9]\n    midCtrlOffset = fingerCtrlOffset[6:9]\n    \n    pinkyCtrlList = fingerCtrlList[9:13]\n    pinkyCtrlSDK = fingerCtrlSDK[9:13]\n    pinkyCtrlOffset = fingerCtrlOffset[9:13]\n    \n    \n    \n    \n    #Heirarchal Parenting\n    for i in range(0,(len(thumbCtrlList)-1)):\n        print i,i+1\n        cmds.parent(thumbCtrlOffset[i+1],thumbCtrlList[i])\n        cmds.parent(indexCtrlOffset[i+1],indexCtrlList[i])\n        cmds.parent(midCtrlOffset[i+1],midCtrlList[i])\n        cmds.parent(pinkyCtrlOffset[i+1],pinkyCtrlList[i])\n    \n    #Parent stray rootpinky \n    cmds.parent(pinkyCtrlOffset[-1],pinkyCtrlList[-2])\n    \n    #Make wrist ctrl\n    a = makeControl(wristStartJnt)\n    #Asssign to lists\n    global wristCtrlOffset\n    wristCtrlList = a[0]\n    wristCtrlSDK = a[2]\n    wristCtrlOffset = a[1]\n    #Scale Ctrl\n    cmds.select(wristCtrlList+'.cv[:]')\n    cmds.scale(2,2,2)\n    cmds.select(d=1)\n    #Parent it up\n    wristPC = cmds.parentConstraint(wristStartJnt,wristCtrlOffset,mo=0)\n    cmds.delete(wristPC)\n    cmds.parentConstraint(wristCtrlList,wristStartJnt)\n    \n    #Parent everything up to wrist\n    cmds.parent(thumbCtrlOffset[0],wristCtrlList)\n    cmds.parent(indexCtrlOffset[0],wristCtrlList)\n    cmds.parent(midCtrlOffset[0],wristCtrlList)\n    cmds.parent(pinkyCtrlOffset[0],wristCtrlList)\n    \n    #Delete tempHandRig group\n    cmds.delete(tempHand_grp)\n    \n    #move attrGrp pivot to hand and parent constrain\n    wcT = cmds.xform(wristCtrlList,t=1,q=1,ws=1)\n    cmds.xform(attrGrp,rp=(wcT),ws=1)\n    cmds.parentConstraint(wristCtrlList,attrGrp,mo=1)\n    \n    cmds.select(d=1)\n\n\n##############################################################################################################################\n###                                             SDK on finger ctrls                                                        ###\n##############################################################################################################################\n\n\n\ndef makeSDK():\n    for i in range(0,len(thumbCtrlSDK)):\n        tempMD = cmds.shadingNode('multiplyDivide',asUtility=1,n=driverLocs[0]+'_md'+str(i))\n        cmds.connectAttr(driverLocs[0]+'.translateY',tempMD+'.input1X')\n        cmds.setAttr(tempMD+'.input2X',5/rigScale)\n        cmds.connectAttr(tempMD+'.outputX',thumbCtrlSDK[i]+'.rotateZ')\n    \n    for i in range(0,len(indexCtrlSDK)):\n        tempMD = cmds.shadingNode('multiplyDivide',asUtility=1,n=driverLocs[1]+'_md'+str(i))\n        cmds.connectAttr(driverLocs[1]+'.translateY',tempMD+'.input1X')\n        cmds.setAttr(tempMD+'.input2X',5/rigScale)\n        cmds.connectAttr(tempMD+'.outputX',indexCtrlSDK[i]+'.rotateZ')\n    \n    for i in range(0,len(midCtrlSDK)):\n        tempMD = cmds.shadingNode('multiplyDivide',asUtility=1,n=driverLocs[2]+'_md'+str(i))\n        cmds.connectAttr(driverLocs[2]+'.translateY',tempMD+'.input1X')\n        cmds.setAttr(tempMD+'.input2X',5/rigScale)\n        cmds.connectAttr(tempMD+'.outputX',midCtrlSDK[i]+'.rotateZ')\n        \n    for i in range(0,len(pinkyCtrlSDK)):\n        tempMD = cmds.shadingNode('multiplyDivide',asUtility=1,n=driverLocs[3]+'_md'+str(i))\n        cmds.connectAttr(driverLocs[3]+'.translateY',tempMD+'.input1X')\n        cmds.setAttr(tempMD+'.input2X',5/rigScale)\n        cmds.connectAttr(tempMD+'.outputX',pinkyCtrlSDK[i]+'.rotateZ')\n\n \n\n\ndef GUI():\n    cmds.window(title=\"Hand Rig\")\n    \n    mainLay = cmds.rowLayout(numberOfColumns=3)\n    \n    col1 = cmds.columnLayout(parent=mainLay)       \n    \n\n    form3 = cmds.formLayout(parent=col1)     \n    img2=cmds.text('AutoHand',parent=form3)\n    cmds.formLayout(form3, e=1, attachForm=(img2,\"left\",50) )\n    \n    cmds.separator()\n    cmds.separator()\n    cmds.separator()\n    cmds.button(label=\"Temp Rig\", height=50, parent=col1, width=150,\n                command=\"tempHandRig()\")\n\n    form2 = cmds.formLayout(parent=col1)     \n    img2=cmds.image(image=\"nudgeDown.png\",  parent=form2)\n    cmds.formLayout(form2, e=1, attachForm=(img2,\"left\",68) )\n\n    cmds.button(label=\"Create Joints\", height=50,  parent=col1, width=150,\n                command=\"createBones()\")\n    \n    form1 = cmds.formLayout(parent=col1)     \n    img=cmds.image(image=\"nudgeDown.png\",  parent=form1)\n    cmds.formLayout(form1, e=1, attachForm=(img,\"left\",68) )\n\n    cmds.button(label=\"Create Controls\", height=50,  parent=col1, width=150,\n                command=\"buildAttributeControls()\\nbuildControls()\\nmakeSDK()\")\n                \n                \n    # cmds.text(manage=0, label=\"BFX WINNERS 2015 swag swag swag #butt\", parent=col3)\n    \n    cmds.showWindow()\n    \n'''    \ntempHandRig()\ncreateBones()\nbuildAttributeControls()\nbuildControls()\nmakeSDK()\n'''\n\nGUI()\n\n\n\n#thingy = cmds.ls(sl=1)[0]\n\n#cmds.scale(5,5,5,thingy+'.cv[:]')\n\n\n" 
        -sourceType "python" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Weight mover" 
        -enableBackground 0
        -align "center" 
        -label "source abWeightLifter.mel;abWeightLifter;" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "W.M" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "commandButton.png" 
        -image1 "commandButton.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "source abWeightLifter.mel;abWeightLifter;" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Weight_exporter" 
        -enableBackground 0
        -align "center" 
        -label "\n\n\n\n\nglobal string $gDoraSkinWeight_ver = \"3.60\";\n\n\n\n\n\nproc stri..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "W.E" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "commandButton.png" 
        -image1 "commandButton.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "\n\n\n\n\nglobal string $gDoraSkinWeight_ver = \"3.60\";\n\n\n\n\n\nproc string DoraSkinWeightImpExp_vtx2uv( string $vtx )\n\t{\n\tstring $ret;\n\tstring $workString[];\n\t\n\t$workString= `polyListComponentConversion -fv -tuv $vtx`;\n\t\n\t\n\t\n\t$ret= `substitute \".map\" $workString[0] \".uv\"`;\n\t\n\treturn( $ret );\n\t}\n\n\n\n\nproc string DoraSkinWeightImpExp_checkOverlapsList( string $list[] )\n\t{\n\tstring $shorteList[];\n\tstring $overlapsList[];\n\tstring $overlapsList2[];\n\tint $overlapsListN;\n\tint $i, $j, $k;\n\tstring $retString;\n\tint $overlapsCount;\n\t\n\t$shorteList = stringArrayRemoveDuplicates($list);\n\tif( size($list)==size($shorteList) )return(\"\");\n\telse\n\t\t{\n\t\t\n\t\t$overlapsListN=0;\n\t\tfor( $i=0 ; $i<(size( $list )-1) ; $i++ )\n\t\t\t{\n\t\t\tfor( $j=$i+1 ; $j<size( $list ) ; $j++ )\n\t\t\t\t{\n\t\t\t\tif( $list[$i]==$list[$j] )\n\t\t\t\t\t{\n\t\t\t\t\t$overlapsList[$overlapsListN]= $list[$i];\n\t\t\t\t\t$overlapsListN++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t$overlapsList2= stringArrayRemoveDuplicates($overlapsList);\n\t\t\n\t\t$retString=\"\";\n\t\tfor( $i=0 ; $i<size($overlapsList2) ; $i++ )\n\t\t\t{\n\t\t\t$overlapsCount= stringArrayCount( $overlapsList2[$i], $list );\n\t\t\t$retString+= ( $overlapsList2[$i] + \" (\" + $overlapsCount + \") \" );\n\t\t\tif( $i<size($overlapsList2)-1 )\n\t\t\t\t{\n\t\t\t\t$retString+= \", \";\n\t\t\t\t}\n\t\t\t}\n\t\treturn ( $retString );\n\t\t}\n\t}\n\n\n\n\nproc string DoraSkinWeightImpExp_extCheck( string $name, string $ext )\n\t{\n\tstring $ret;\n\t\n\t$ret= $name;\n\tif( size($name)<=size($ext) )\n\t\t{\n\t\t$ret= $name + $ext;\n\t\t\n\t\t}\n\telse\n\t\t{\n\t\tif( tolower(substring( $ret, size($ret)-(size($ext)-1), size($ret) )) != $ext )\n\t\t\t{\n\t\t\t$ret= $name + $ext;\n\t\t\t}\n\t\t}\n\treturn $ret;\n\t}\n\n\n\n\nproc string DoraSkinWeightImpExp_shapeName( string $obj )\n\t{\n\tstring $shape[];\t\n\n\t$shape= `listHistory $obj`;\n\t$shape= `ls -type shape $shape`;\n\t\n\tif( size($shape)==0 )return( \"\" );\n\telse return( $shape[0] );\n\t\n\n\n\t}\n\n\n\n\nproc vector DoraSkinWeightImpExp_vtx2vector( string $vtxName )\n\t{\n\tvector $vtx;\n\tfloat $workXYZf[];\n\n\t$workXYZf= `pointPosition -w $vtxName`;\n\t$vtx= <<$workXYZf[0], $workXYZf[1], $workXYZf[2]>>;\n\t\n\treturn( $vtx );\n\t}\n\n\n\n\n\nproc vector DoraSkinWeightImpExp_vtx2uvVector( string $vtxName )\n\t{\n\tvector $vtx;\n\tfloat $workXYZf[];\n\tstring $workString;\n\t\n\t$workString= DoraSkinWeightImpExp_vtx2uv( $vtxName );\n\t$workXYZf= `getAttr $workString`;\n\t$vtx= <<$workXYZf[0], $workXYZf[1], 0.0>>;\n\t\n\treturn( $vtx );\n\t}\n\n\n\n\n\nproc string DoraSkinWeightImpExp_dswAppendListGet()\n\t{\n\tstring $ret;\n\tstring $fileList[];\n\tstring $dswDir;\n\tint $i;\n\t\n\t$dswDir= (`workspace -q -fn`+\"/dsw/\");\n\t$fileList= `getFileList -folder $dswDir -filespec \"*.dsw\"`;\n\t\n\tfor( $i=0,$ret=\"\" ; $i<size( $fileList ) ; $i++ )\n\t\t{\n\t\t$ret= ($ret + \"-a \\\"\" + $fileList[$i] + \"\\\" \");\n\t\t\n\t\t}\n\t\n\treturn $ret;\n\t}\n\n\n\n\n\n\n\nproc string DoraSkinWeightImpExp_searchSC( string $meshShape )\n\t{\n\tstring $cList[];\n\t\n\t$cList= `listHistory $meshShape`;\n\t$cList= `ls -type skinCluster $cList`;\n\t\n\tif( size($cList)==0 )return( \"\" );\n\telse return( $cList[0] );\n\t\n\t}\n\n\n\n\nproc string DoraSkinWeightImpExp_simpleObjName( string $name )\n\t{\n\tstring $ret;\n\t\n\t$ret = `substitute \".*|\" $name \"\"`;\n\t\n\treturn( $ret );\n\t}\n\n\n\n\n\nglobal proc int DoraSkinWeightExport( string $dsw_name )\n\t{\n\tstring $exportFileName;\t\n\tint $fileId;\t\t\t\n\tstring $slList[];\t\t\n\tstring $shape;\t\t\t\n\tstring $sc;\t\t\t\t\n\tstring $jointList[];\t\n\tint $i,$j;\n\tint $wp[];\t\t\t\t\n\tstring $workString,$workVtx;\n\tstring $outputFileLine;\t\n\tfloat $weightList[];\t\n\tglobal string $gMainProgressBar;\n\tfloat $wpos[3];\t\t\t\n\tfloat $uv[2];\t\t\t\n\tint $noneUVCount;\t\t\n\tint $mode;\t\t\t\t\n\t\n\t\n\tif( $dsw_name==\"\")\n\t\t{\n\t\terror(\"No Export Name\");\n\t\treturn( 0 );\n\t\t}\n\t\n\t\n\t$slList= `filterExpand -sm 12`;\n\tif( size( $slList )==0 )\n\t\t{\n\t\t\n\t\t$slList= `filterExpand -sm 31`; \n\t\t$slList= `ls -fl $slList`;\n\t\tif( size( $slList )==0 )\n\t\t\t{\n\t\t\t\n\t\t\terror(\"No objects SmoothSkinMesh selected (1)\");\n\t\t\treturn( 0 );\n\t\t\t}\n\t\telse{ $mode=2; }\n\t\t}\n\telse{ $mode=1;}\n\t\n\t\n\t\n\t$shape= DoraSkinWeightImpExp_shapeName( $slList[0] );\n\t\n\t\n\t\n\t$sc= DoraSkinWeightImpExp_searchSC( $shape );\n\tif( $sc==\"\" )\n\t\t{\n\t\terror(\"No objects SmoothSkinMesh selected (2)\");\n\t\treturn( 0 );\n\t\t}\n\t\n\t\n\t\n\t\n\t\n\t$jointList= `listConnections -type \"joint\" ($sc+\".matrix\")`;\n\t\n\t\n\t\n\tfor( $i=0 ; $i<size($jointList) ; $i++ )\n\t\t{\n\t\t$jointList[$i]= DoraSkinWeightImpExp_simpleObjName( $jointList[$i] );\n\t\t}\n\t\n\t$workString= DoraSkinWeightImpExp_checkOverlapsList( $jointList );\n\tif( $workString!=\"\" )\n\t\t{\n\t\terror(\"JointName Overlaps [ \" + $workString + \"]\" );\n\t\treturn( 0 );\n\t\t}\n\t\n\t\n\tswitch( $mode )\n\t\t{\n\t\tcase 1:\n\t\t$wp= `polyEvaluate -v $shape`;\n\t\tbreak;\n\t\t\n\t\tcase 2:\n\t\t$wp[0]= size( $slList );\n\t\tbreak;\n\t\t}\n\n\n\t\n\t\n\t$exportFileName = toNativePath(`workspace -q -fn` + \"/\" + \"dsw/\" + DoraSkinWeightImpExp_extCheck($dsw_name, \".dsw\"));\n\t\n\tsysFile -makeDir `dirname( $exportFileName )`;\n\t\n\t\n\t\n\t\n\t\n\tprogressBar -edit\n\t\t-beginProgress\n\t\t-status (\"Export  [ \" + $exportFileName +\" ]\")\n\t\t-maxValue $wp[0]\n\t\t$gMainProgressBar;\n\t\n\t\n\t\n\t$fileId=`fopen $exportFileName \"w\"`;\n\t\n\tfprint $fileId (\"DoraYuki Skin Weight Format 3.00\\n\");\n\t\n\t\n\t\n\t$outputFileLine= \"\";\n\tfor( $i=0 ; $i<size($jointList) ; $i++ )\n\t\t{\n\t\t$outputFileLine+= ($jointList[$i]);\n\t\tif( $i+1 < size($jointList) )\n\t\t\t{\n\t\t\t$outputFileLine+= \",\";\n\t\t\t}\n\t\t}\n\tfprint $fileId ( $outputFileLine + \"\\n\" );\n\t\n\t\n\t$noneUVCount= 0;\n\t\n\t\n\tfor( $i=0 ; $i<$wp[0] ; $i++ )\n\t\t{\n\t\t\n\t\t\n\t\tswitch( $mode )\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t$workVtx= ($shape + \".vtx[\" + $i + \"]\");\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 2:\n\t\t\t$workVtx= $slList[$i];\n\t\t\tbreak;\n\t\t\t}\n\t\t\n\t\t$weightList= `skinPercent -q -v $sc $workVtx`;\n\t\t\n\t\t$outputFileLine= \"\";\n\t\t\n\t\tfor( $j=0 ; $j<size($weightList) ; $j++ )\n\t\t\t{\n\t\t\t$outputFileLine+= $weightList[$j];\n\t\t\tif( $j+1 < size($weightList) )\n\t\t\t\t{\n\t\t\t\t$outputFileLine+= \",\";\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t$outputFileLine+= \"|\";\n\t\t\n\t\t\n\t\t$wpos= `pointPosition -w $workVtx`;\n\t\t$outputFileLine+= ( $wpos[0] + \",\" + $wpos[1] + \",\" + $wpos[2] + \"|\" );\n\t\t\n\t\t\n\t\t$workString= DoraSkinWeightImpExp_vtx2uv($workVtx);\n\t\t\n\t\tif( $workString!=\"\" )\n\t\t\t{\n\t\t\t$uv= `getAttr $workString`;\n\t\t\t}\n\t\telse\n\t\t\t{\n\t\t\t$noneUVCount++;\n\t\t\twarning(\"noneUV Vartex[ \" + $i + \" ]\");\n\t\t\t$uv[0]=0.0;\n\t\t\t$uv[1]=0.0;\n\t\t\t}\n\t\t\n\t\t$outputFileLine+= ( $uv[0] + \",\" + $uv[1] );\n\t\t\n\t\t\n\t\tfprint $fileId ( $outputFileLine + \"\\n\");\n\t\t\n\t\t\n\t\t\n\t\tprogressBar -edit\n\t\t\t-step 1 $gMainProgressBar;\n\t\t}\n\t\n\t\n\tfclose $fileId;\n\t\n\t\n\tprogressBar -edit\n\t\t-endProgress\n\t\t$gMainProgressBar;\n\t\n\t\n\t$i= $wp[0];\n\t$wp= `polyEvaluate -v $shape`;\n\tconfirmDialog -title \"DSW Exported\" -message ( \"[ \" + $shape + \" ] Vertex : \" + $wp[0] + \"\\n\\nDSW VertexPoint : \" + $i + \"\\n\\nnoneUV VartexPoint : \" + $noneUVCount + \"\\n\\nExportDSWFile : \\n[ \"+ $exportFileName + \" ]\") -button \"OK\" -defaultButton \"OK\";\n\t\n\treturn( 1 );\n\t}\n\n\n\n\nproc int DoraSkinWeightImpExp_compDistance( vector $xyz, vector $a, vector $b, float $distance[] )\n\t{\n\t$distance[0]= abs(mag($xyz-$a));\n\t$distance[1]= abs(mag($xyz-$b));\n\t\n\tif( $distance[0] > $distance[1] )return(0);\n\telse return(1);\n\t}\n\n\n\n\n\n\n\n\nproc int DoraSkinWeightImpExp_vtxDistanceMin( vector $xyz, string $shape, int $mode, int $setF[], float $range )\n\t{\n\tint $wp[];\n\tvector $vtxA;\n\tint $minNo;\n\tint $i;\n\tfloat $dis[2];\n\tint $hitF;\n\t\n\t$minNo=-1;\n\t$wp= `polyEvaluate -v $shape`;\n\t\n\t\n\t\n\t\n\t\n\tfor( $i=0,$hitF= 0 ; $i<$wp[0] ; $i++ )\n\t\t{\n\t\t\n\t\tif( $setF[$i]==1 )continue;\n\t\t\n\t\tif( $mode==0 )$vtxA= DoraSkinWeightImpExp_vtx2vector($shape + \".vtx[\" + $i + \"]\");\n\t\telse $vtxA= DoraSkinWeightImpExp_vtx2uvVector($shape + \".vtx[\" + $i + \"]\");\n\t\t\n\t\t\n\t\t$dis[0]= abs(mag($xyz-$vtxA));\n\t\tif( $dis[0]<=$range )\n\t\t\t{\n\t\t\t$hitF=1;\n\t\t\t$minNo= $i;\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\t\n\tif( $hitF==1 )return( $minNo );\n\t\n\t\n\treturn( -1 );\n\t}\n\n\n\n\n\nproc DoraSkinWeightImpExp_weightCopy( int $an, int $bn, string $sc, string $shape )\n\t{\n\tstring $workString;\n\tstring $jointList[];\n\tfloat $weightList[];\n\tfloat $weight;\n\tint $i;\n\t\n\t\n\t\n\t\n\t\n\t\n\t$jointList= `listConnections -type \"joint\" ($sc+\".matrix\")`;\n\t\n\t\n\tfor( $i=0 ; $i<size($jointList) ; $i++ )\n\t\t{\n\t\t$jointList[$i]= DoraSkinWeightImpExp_simpleObjName( $jointList[$i] );\n\t\t}\n\t\n\t$workString= ($shape + \".vtx[\" + $an + \"]\");\n\t$weightList= `skinPercent -q -v $sc $workString`;\n\t\n\t$workString= \"\";\n\tfor( $i=0 ; $i<size($jointList); $i++ )\n\t\t{\n\t\t$weight= float($weightList[$i]);\n\t\t$workString+= ( \"-tv \" + $jointList[$i] + \" \" + $weight + \" \" );\n\t\t}\n\t\n\t\n\t\n\tif( $workString!=\"\" )\n\t\t{\n\t\t$vtxName= ($shape + \".vtx[\" + $bn + \"]\");\n\t\t$workString= (\"skinPercent \" + $workString + $sc + \" \" + $vtxName );\n\t\teval( $workString );\n\t\t\n\t\t\n\t\t}\n\t\n\t}\n\n\n\nproc string DoraSkinWeightImpExp_getParam_weightSet( string $selectJoint[], int $exist[], int $unknown[], string $joint[], string $weight[] )\n\t{\n\tstring $workString= \"\";\n\tstring $jName=\"\";\n\tstring $jWeight=\"\";\n\t\n\t\n\tfor( $i=0 ; $i<size($exist); $i++ )\n\t\t{\n\t\t$jName= $selectJoint[$exist[$i]];\n\t\t$jWeight=\" \";\n\t\t\n\t\t\n\t\tfor( $j=0 ; $j<size($joint) ; $j++ )\n\t\t\t{\n\t\t\tif( $jName==$joint[$j] )\n\t\t\t\t{\n\t\t\t\t$jWeight=$weight[$j];\n\t\t\t\t$workString+= ( \"-tv \" + $jName + \" \" + $jWeight + \" \" );\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\n\tfor( $i=0 ; $i<size($unknown); $i++ )\n\t\t{\n\t\t$workString+= ( \"-tv \" + $selectJoint[$unknown[$i]] + \" 0 \" );\n\t\t}\n\t\n\treturn( $workString );\n\t}\n\n\n\n\nglobal proc int DoraSkinWeightImport( string $dsw_name, int $importMode, int $interpolationWeight, int $interpolationMode, float $para)\n\t{\n\tglobal string $gDoraSkinWeightImpExp_jointNameNew[];\n\tstring $ImportFileName;\t\t\t\n\tint $fileId;\t\t\t\t\t\n\tstring $textLine;\t\t\t\t\n\tstring $slList[];\t\t\t\t\n\tstring $shape;\t\t\t\t\t\n\tstring $sc;\t\t\t\t\t\t\n\tstring $jointList[];\t\t\t\n\tstring $selectMeshJointList[];\t\n\tint $existJointN[];\t\t\t\t\n\tint $unknownJointN[];\t\t\t\n\tstring $weightList[];\t\t\t\n\tint $wp[];\t\t\t\t\t\t\n\tstring $vtxName;\t\t\t\t\n\tint $i, $j, $k, $l;\n\tstring $workString,$workString2;\n\tstring $pointData[];\t\t\t\n\t\n\tfloat $weight;\n\tglobal string $gMainProgressBar;\n\tstring $workXYZs[];\n\tfloat $workXYZf[];\n\tvector $workVec[2];\n\tvector $wpos[2];\n\tint $minNo;\n\tfloat $workDistance[2];\t\t\t\n\t\n\tint $weightSetF[];\t\t\t\t\n\tint $dataCount;\t\t\t\t\t\n\tint $weightSetCount;\t\t\t\n\tint $weightSet2Count;\t\t\t\n\t\n\t\n\tif( $dsw_name==\"\")\n\t\t{\n\t\treturn( 0 );\n\t\t}\n\t\n\t\n\t\n\t$slList= `filterExpand -sm 12`;\n\tif( size( $slList )==0 )\n\t\t{\n\t\terror(\"No objects SmoothSkinMesh selected (1)\");\n\t\treturn( 0 );\n\t\t}\n\t\n\t\n\t$shape= DoraSkinWeightImpExp_shapeName( $slList[0] );\n\t\n\t\n\t$sc= DoraSkinWeightImpExp_searchSC( $shape );\n\tif( $sc==\"\" )\n\t\t{\n\t\terror(\"No objects SmoothSkinMesh selected (2)\");\n\t\treturn( 0 );\n\t\t}\n\t\n\t\n\t\n\t\n\t\n\t$selectMeshJointList= `listConnections -type \"joint\" ($sc+\".matrix\")`;\n\t\n\t\n\tfor( $i=0 ; $i<size($selectMeshJointList) ; $i++ )\n\t\t{\n\t\t$selectMeshJointList[$i]= DoraSkinWeightImpExp_simpleObjName( $selectMeshJointList[$i] );\n\t\t}\n\t\n\t$workString= DoraSkinWeightImpExp_checkOverlapsList( $selectMeshJointList );\n\tif( $workString!=\"\" )\n\t\t{\n\t\terror(\"JointName Overlaps [ \" + $workString + \"]\" );\n\t\treturn( 0);\n\t\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t$importFileName = toNativePath(`workspace -q -fn` + \"/dsw/\" + $dsw_name);\n\t\n\t\n\t\n\t$wp= `polyEvaluate -v $shape`;\n\t\n\t\n\tfor( $i=0 ; $i<$wp[0] ; $i++ )$weightSetF[$i]=0;\n\t\n\t\n\t$fileId=`fopen $importFileName \"r\"`;\n\t\n\t\n\t$textLine= `fgetline $fileId`;\n\t$textLine= `substitute \"\\n\" $textLine \"\"`;\n\t\n\tif( $textLine!=\"DoraYuki Skin Weight Format 3.00\" )\n\t\t{\n\t\terror( \"No DSW Format 3.00\" );\n\t\treturn( 0 );\n\t\t}\n\t\n\t\n\t$textLine= `fgetline $fileId`;\n\t\n\t$textLine= `substitute \"\\n\" $textLine \"\"`;\n\t\n\tif($textLine==\"\" )\n\t\t{\n\t\treturn( 0 );\n\t\t}\n\t\n\t\n\ttokenizeList($textLine, $jointList);\n\t\n\t\n\tfor( $j=0 ; $j<size($jointList) ; $j++ )\n\t\t{\n\t\t$jointList[$j]= DoraSkinWeightImpExp_simpleObjName( $jointList[$j] );\n\t\t}\n\t\n\t\n\tif( `window -ex DoraSkinWeightImpExpJointNameEditWindow` == true )\n\t\t{\n\t\tfor( $i=0 ; $i<size($jointList) ; $i++ )\n\t\t\t{\n\t\t\t$jointList[$i]= $gDoraSkinWeightImpExp_jointNameNew[$i];\n\t\t\t}\n\t\t}\n\t\n\t\n\t$e=0;\n\t$u=0;\n\tfor( $s=0 ; $s<size($selectMeshJointList); $s++ )\n\t\t{\n\t\t$check=0;\n\t\tfor( $d=0 ; $d<size($jointList) ; $d++ )\n\t\t\t{\n\t\t\t\n\t\t\tif( $selectMeshJointList[$s]==$jointList[$d])\n\t\t\t\t{\n\t\t\t\t$existJointN[$e]= $s;\n\t\t\t\t$e++;\n\t\t\t\t$check=1;\n\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tif( $check==0 )\n\t\t\t{\n\t\t\t$unknownJointN[$u]=$s;\n\t\t\t$u++;\n\t\t\t}\n\t\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\tprogressBar -edit\n\t\t-beginProgress\n\t\t-status (\"Import  [ \" + $importFileName +\" ]\")\n\t\t-maxValue $wp[0]\n\t\t$gMainProgressBar;\n\t\n\t\n\t\n\tsetAttr ( $sc + \".normalizeWeights\") 0;\n\t\n\t\n\t\n\tsetAttr ( $sc + \".envelope\") 0;\n\t\n\t\n\t\n\t$dataCount=0;\n\t$weightSetCount=0;\n\t$weightSet2Count=0;\n\t\n\tswitch( $importMode )\n\t\t{\n\t\t\n\t\t\n\t\t\n\t\tcase 0:\n\t\t\n\t\tfor( $i=0 ; $i<$wp[0] ; $i++ )\n\t\t\t{\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t$textLine= `fgetline $fileId`;\n\t\t\t\n\t\t\t$textLine= `substitute \"\\n\" $textLine \"\"`;\n\t\t\t\n\t\t\t\n\t\t\tif($textLine==\"\" )break;\n\t\t\t\t\n\t\t\t\n\t\t\ttokenize( $textLine, \"|\", $pointData );\n\t\t\t\n\t\t\t\n\t\t\ttokenizeList($pointData[0], $weightList);\n\t\t\t\n\t\t\t\n\t\t\t$dataCount++;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t$workString=DoraSkinWeightImpExp_getParam_weightSet( $selectMeshJointList, $existJointN, $unknownJointN, $jointList, $weightList  );\n\t\t\t\n\t\t\t\n\t\t\tif( $workString!=\"\" )\n\t\t\t\t{\n\t\t\t\t$vtxName= ($shape + \".vtx[\" + $i + \"]\");\n\t\t\t\t\n\t\t\t\t$workString= (\"skinPercent -r false \" + $workString + $sc + \" \" + $vtxName );\n\t\t\t\teval( $workString );\n\t\t\t\t$weightSetCount++;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t$weightSetF[$i]= 1;\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tprogressBar -edit\n\t\t\t\t-step 1 $gMainProgressBar;\n\t\t\t}\n\t\t\n\t\tbreak;\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tcase 1:\n\t\t\n\t\t$textLine= `fgetline $fileId`;\n\t\twhile( $textLine!=\"\" )\n\t\t\t{\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t$textLine= `substitute \"\\n\" $textLine \"\"`;\n\t\t\t\n\t\t\ttokenize( $textLine, \"|\", $pointData );\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\ttokenizeList($pointData[0], $weightList);\n\t\t\t\n\t\t\t\n\t\t\ttokenizeList($pointData[1], $workXYZs);\n\t\t\t$wpos[0]= << float($workXYZs[0]), float($workXYZs[1]), float($workXYZs[2])>>;\n\t\t\t\n\t\t\t\n\t\t\t$dataCount++;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t$minNo= DoraSkinWeightImpExp_vtxDistanceMin( $wpos[0], $shape, 0, $weightSetF, $para);\n\t\t\t\n\t\t\tif( $minNo!=-1 )\n\t\t\t\t{\n\t\t\t\t\n\t\t\t\t$workString=DoraSkinWeightImpExp_getParam_weightSet( $selectMeshJointList, $existJointN, $unknownJointN, $jointList, $weightList  );\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif( $workString!=\"\" )\n\t\t\t\t\t{\n\t\t\t\t\t$vtxName= ($shape + \".vtx[\" + $minNo + \"]\");\n\t\t\t\t\t\n\t\t\t\t\t$workString= (\"skinPercent -r false \" + $workString + $sc + \" \" + $vtxName );\n\t\t\t\t\t\n\t\t\t\t\teval( $workString );\n\t\t\t\t\t$weightSetCount++;\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t$weightSetF[$minNo]= 1;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tprogressBar -edit\n\t\t\t\t-step 1 $gMainProgressBar;\n\t\t\t\n\t\t\t$textLine= `fgetline $fileId`;\n\t\t\t}\n\t\t\n\t\tbreak;\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tcase 2:\n\t\t\n\t\t$textLine= `fgetline $fileId`;\n\t\twhile( $textLine!=\"\" )\n\t\t\t{\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t$textLine= `substitute \"\\n\" $textLine \"\"`;\n\t\t\t\n\t\t\ttokenize( $textLine, \"|\", $pointData );\n\t\t\t\n\t\t\t\n\t\t\ttokenizeList($pointData[0], $weightList);\n\t\t\t\n\t\t\t\n\t\t\ttokenizeList($pointData[2], $workXYZs);\n\t\t\t$wpos[0]= << float($workXYZs[0]), float($workXYZs[1]), 0>>;\n\t\t\t\n\t\t\t\n\t\t\t$dataCount++;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t$minNo= DoraSkinWeightImpExp_vtxDistanceMin( $wpos[0], $shape, 1, $weightSetF, $para );\n\t\t\t\n\t\t\tif( $minNo!=-1 )\n\t\t\t\t{\n\t\t\t\t\n\t\t\t\t$workString=DoraSkinWeightImpExp_getParam_weightSet( $selectMeshJointList, $existJointN, $unknownJointN, $jointList, $weightList  );\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif( $workString!=\"\" )\n\t\t\t\t\t{\n\t\t\t\t\t$vtxName= ($shape + \".vtx[\" + $minNo + \"]\");\n\t\t\t\t\t\n\t\t\t\t\t$workString= (\"skinPercent -r false \" + $workString + $sc + \" \" + $vtxName );\n\t\t\t\t\t\n\t\t\t\t\teval( $workString );\n\t\t\t\t\t$weightSetCount++;\n\t\t\t\t\t\n\t\t\t\t\t$weightSetF[$minNo]= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tprogressBar -edit\n\t\t\t\t-step 1 $gMainProgressBar;\n\t\t\t\n\t\t\t$textLine= `fgetline $fileId`;\n\t\t\t}\n\t\tbreak;\n\n\t\t}\n\t\n\t\n\t\n\n\t\n\t\n\t\n\t\n\tif( $interpolationWeight == 1 )\n\t\t{\n\t\tswitch( $interpolationMode )\n\t\t\t{\n\t\t\t\n\t\t\tcase 1:\n\t\t\t\n\t\t\t$workString=\"\";\n\t\t\tfor( $i=0 ; $i<size($weightSetF) ; $i++ )\n\t\t\t\t{\n\t\t\t\t\n\t\t\t\tif( $weightSetF[$i]==1 )continue;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t$minNo= -1;\n\t\t\t\tfor( $j=0 ; $j<$wp[0] ; $j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tif( $i!=$j && $weightSetF[$j]==1 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\t$workVec[0]= DoraSkinWeightImpExp_vtx2vector($shape + \".vtx[\" +  $j + \"]\");\n\t\t\t\t\t\t$minNo= $j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor( ; $j<$wp[0] ; $j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tif( $i!=$j && $weightSetF[$j]==1 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t$workVec[1]= DoraSkinWeightImpExp_vtx2vector($shape + \".vtx[\" + $j + \"]\");\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( DoraSkinWeightImpExp_compDistance( DoraSkinWeightImpExp_vtx2vector($shape + \".vtx[\" + $i + \"]\"), $workVec[0], $workVec[1], $workDistance )==0 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$workVec[0]= $workVec[1];\n\t\t\t\t\t\t\t$minNo= $j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tprogressBar -edit\n\t\t\t\t\t-step 1 $gMainProgressBar;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif( $minNo == -1 )break;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tDoraSkinWeightImpExp_weightCopy( $minNo, $i, $sc, $shape );\n\t\t\t\t$weightSet2Count++;\n\t\t\t\t\n\t\t\t\t$weightSetF[$i]=2;\n\t\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\t\t\n\t\t\tcase 2:\n\t\t\t\n\t\t\t$workString=\"\";\n\t\t\tfor( $i=0 ; $i<size($weightSetF) ; $i++ )\n\t\t\t\t{\n\t\t\t\t\n\t\t\t\tif( $weightSetF[$i]==1 )continue;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t$minNo= -1;\n\t\t\t\tfor( $j=0 ; $j<$wp[0] ; $j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tif( $i!=$j && $weightSetF[$j]==1 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\t$workVec[0]= DoraSkinWeightImpExp_vtx2uvVector($shape + \".vtx[\" +  $j + \"]\");\n\t\t\t\t\t\t$minNo= $j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor( ; $j<$wp[0] ; $j++ )\n\t\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tif( $i!=$j && $weightSetF[$j]==1 )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t$workVec[1]= DoraSkinWeightImpExp_vtx2uvVector($shape + \".vtx[\" + $j + \"]\");\n\t\t\t\t\t\t\n\t\t\t\t\t\tif( DoraSkinWeightImpExp_compDistance( DoraSkinWeightImpExp_vtx2uvVector($shape + \".vtx[\" + $i + \"]\"), $workVec[0], $workVec[1], $workDistance )==0 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$workVec[0]= $workVec[1];\n\t\t\t\t\t\t\t$minNo= $j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tprogressBar -edit\n\t\t\t\t\t-step 1 $gMainProgressBar;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif( $minNo == -1 )break;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tDoraSkinWeightImpExp_weightCopy( $minNo, $i, $sc, $shape );\n\t\t\t\t$weightSet2Count++;\n\t\t\t\t\n\t\t\t\t$weightSetF[$i]=2;\n\t\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\t\n\t\n\t$workString=\"\";\n\tfor( $i=0 ; $i<$wp[0] ; $i++)\n\t\t{\n\t\t\n\t\tswitch( $weightSetF[$i]) \n\t\t\t{\n\t\t\tcase 1:\n\t\t\t$workString+= ($shape + \".vtx[\" + $i + \"] \");\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 2:\n\t\t\t$workString2= DoraSkinWeightImpExp_vtx2uv( $shape + \".vtx[\" + $i + \"] \" );\n\t\t\t$workString2= `substitute \".uv\" $workString2 \".map\"`;\n\t\t\t$workString+= ( $workString2 + \" \");\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\tif( $workString!=\"\" ){eval( \"select \" + $workString );}\n\t\n\t\n\t\n\t\n\tsetAttr ( $sc + \".envelope\") 1;\n\t\n\t\n\tskinPercent -normalize true $sc;\n\tsetAttr ( $sc + \".normalizeWeights\") 1;\n\t\n\t\n\t\n\tprogressBar -edit\n\t\t-endProgress\n\t\t$gMainProgressBar;\n\t\n\t\n\tfclose $fileId;\n\t\n\t\n\tconfirmDialog -title \"DSW Imported\" -message ( \"[ \" + $shape + \" ] Vertex : \" + $wp[0] +  \"\\n\\nDSW VertexPoint : \"+ $dataCount + \"\\n\\nSetPoint : \"+ ($weightSetCount + $weightSet2Count) + \"\\n( InterpolationPoint :\" + $weightSet2Count + \" )\" ) -button \"OK\" -defaultButton \"OK\";\n\t\n\treturn( 1 );\n\t}\n\n\n\n\nglobal proc DoraSkinWeightXYZCheck()\n\t{\n\tstring $ImportFileName;\n\tint $fileId;\n\tstring $textLine;\n\tint $wp[];\n\tint $i, $j;\n\tstring $workString;\n\tstring $workXYZs[];\n\tstring $pointData[];\n\t\n\t\n\t$importFileName = toNativePath(`workspace -q -fn` + \"/*.dsw\");\n\t$importFileName= `fileDialog -dm $importFileName`;\n\t\n\tif( $importFileName!=\"\" )\n\t\t{\n\t\t\n\t\t$workString= \"particle \";\n\t\t\n\t\t$fileId=`fopen $importFileName \"r\"`;\n\t\t\n\t\t$textLine= `fgetline $fileId`;\n\t\t$textLine= `substitute \"\\n\" $textLine \"\"`;\n\t\tswitch( $textLine )\n\t\t\t{\n\t\t\t\n\t\t\tcase \"DoraYuki Skin Weight Format 3.00\":\n\t\t\t\n\t\t\t\n\t\t\t$textLine= `fgetline $fileId`;\n\t\t\t\n\t\t\t\n\t\t\t$textLine= `fgetline $fileId`;\n\t\t\twhile( $textLine!=\"\" )\n\t\t\t\t{\n\t\t\t\t$textLine= `substitute \"\\n\" $textLine \"\"`;\n\t\t\t\ttokenize( $textLine, \"|\", $pointData );\n\t\t\t\ttokenizeList($pointData[1], $workXYZs);\n\t\t\t\t\n\t\t\t\t$workString= ( $workString + \"-p \" + $workXYZs[0] + \" \" + $workXYZs[1] + \" \" + $workXYZs[2] + \" \" );\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t$textLine= `fgetline $fileId`;\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\tbreak;\n\t\t\t}\n\t\tfclose $fileId;\n\t\t\n\t\t$workString= ( $workString + \"-c 1 -n skinWeightPoint\" );\n\t\teval( $workString );\n\t\t\n\t\taddAttr -is true -ln \"pointSize\" -at long -min 1 -max 60 -dv 8 skinWeightPointShape;\n\n\t\t}\n\t\n\t}\n\n\n\n\n\nglobal proc DoraSkinWeightFileListUpdate()\n\t{\n\tstring $dswAppendList;\n\tstring $work;\n\t\n\t\n\ttextScrollList -e -ra DoraSkinWeightImpExp_TXTSL_ExpList;\n\ttextScrollList -e -ra DoraSkinWeightImpExp_TXTSL_ImpList;\n\t\n\t$dswAppendList= DoraSkinWeightImpExp_dswAppendListGet();\n\tif( size( $dswAppendList ) != 0 )\n\t\t{\n\t\t$work= (\"textScrollList -e \" + $dswAppendList + \" DoraSkinWeightImpExp_TXTSL_ExpList\" );\n\t\teval( $work );\n\t\t$work= (\"textScrollList -e \" + $dswAppendList + \" DoraSkinWeightImpExp_TXTSL_ImpList\" );\n\t\teval( $work );\n\t\t\n\t\t\n\t\t\n\t\t$work= DoraSkinWeightImpExp_extCheck(`textField -q -text DoraSkinWeightImpExp_TXTF_ExpName`,\".dsw\");\n\t\ttextScrollList -e -selectItem $work DoraSkinWeightImpExp_TXTSL_ExpList;\n\t\t}\n\t}\n\n\n\n\n\n\n\nproc int DoraSkinWeightJointNameEdit_SetgJointName()\n\t{\n\tglobal string $gDoraSkinWeightImpExp_jointName[];\n\tglobal string $gDoraSkinWeightImpExp_jointNameNew[];\n\tstring $ImportFileName;\n\tint $fileId;\n\tstring $textLine;\n\tstring $workStringA[];\n\t\n\t\n\t\n\tclear( $gDoraSkinWeightImpExp_jointName );\n\tclear( $gDoraSkinWeightImpExp_jointNameNew );\n\t\n\t\n\t$workStringA = `textScrollList -q  -si DoraSkinWeightImpExp_TXTSL_ImpList`;\n\tif( $workStringA[0]==\"\" )return(0);\n\t$importFileName= toNativePath(`workspace -q -fn` + \"/dsw/\" + $workStringA[0]);\n\t\n\t$fileId=`fopen $importFileName \"r\"`;\n\t\n\t$textLine= `fgetline $fileId`;\n\t$textLine= `substitute \"\\n\" $textLine \"\"`;\n\t\n\tif( $textLine!=\"DoraYuki Skin Weight Format 3.00\" )return(0);\n\t\n\t\n\t$textLine= `fgetline $fileId`;\n\ttokenizeList($textLine, $gDoraSkinWeightImpExp_jointName);\n\tfclose $fileId;\n\t\n\t\n\t$gDoraSkinWeightImpExp_jointNameNew= $gDoraSkinWeightImpExp_jointName;\n\t\n\treturn(1);\n\t}\n\n\n\n\nproc string DoraSkinWeightJointNameEdit_jointEditListString()\n\t{\n\tglobal string $gDoraSkinWeightImpExp_jointName[];\n\tglobal string $gDoraSkinWeightImpExp_jointNameNew[];\n\tstring $ret;\n\t\n\t$ret=\"\";\n\tfor( $i=0 ; $i<size($gDoraSkinWeightImpExp_jointName) ; $i++ )\n\t\t{\n\t\t$ret+= ( \"-a \\\"[\" + $gDoraSkinWeightImpExp_jointName[$i] + \"] ---> [\" + $gDoraSkinWeightImpExp_jointNameNew[$i] + \"]\\\" \" );\n\t\t}\n\treturn( $ret );\n\t}\n\n\n\n\nglobal proc DoraSkinWeightJointNameEdit_listAllSelect()\n\t{\n\tint $i;\n\tint $n;\n\t\n\t$n= `textScrollList -q -ni DoraSkinWeightImpExp_TXTSL_jne_JointList`;\n\n\t\n\tfor( $i=0 ; $i<$n ; $i++ )\n\t\t{\n\t\ttextScrollList -e -sii ($i+1) DoraSkinWeightImpExp_TXTSL_jne_JointList;\n\t\t}\n\n\t}\n\n\n\n\n\nproc int DoraSkinWeightJointNameEdit_listUpdate()\n\t{\n\tstring $workString;\n\t\n\t\n\t$workString=DoraSkinWeightJointNameEdit_jointEditListString();\n\t\n\t\n\ttextScrollList -e -ra DoraSkinWeightImpExp_TXTSL_jne_JointList;\n\teval( \"textScrollList -e -showIndexedItem 1 \" + $workString + \" DoraSkinWeightImpExp_TXTSL_jne_JointList\");\n\t\n\treturn( 1 );\n\t}\n\n\n\n\n\nglobal proc int DoraSkinWeightJointNameEdit_reload()\n\t{\n\tglobal string $gDoraSkinWeightImpExp_jointNameNew[];\n\tstring $workStringA[];\n\t\n\t\n\tif( `window -ex DoraSkinWeightImpExpJointNameEditWindow` == false ||\n\t\t`window -ex DoraSkinWeightImpExpWindow` == false ){return(0);}\n\t\n\t\n\tif( DoraSkinWeightJointNameEdit_SetgJointName()==0 ){return(0);}\n\t\n\t\n\t$workStringA= `textScrollList -q  -si DoraSkinWeightImpExp_TXTSL_ImpList`;\n\t$workStringA[0]= ( $workStringA[0] + \" - \" + size( $gDoraSkinWeightImpExp_jointNameNew ) + \" joint\" );\n\t\n\ttext -e -label $workStringA[0] DoraSkinWeightImpExp_TXT_jne_dswName;\n\t\n\t\n\t\n\tDoraSkinWeightJointNameEdit_listUpdate();\n\t\n\treturn( 1 );\n\t}\n\n\n\n\n\n\nglobal proc int DoraSkinWeightJointNameEdit_jointNameUpdate()\n\t{\n\tglobal string $gDoraSkinWeightImpExp_jointNameNew[];\n\tint $selectItem[];\n\t\n\t$selectItem= `textScrollList -q -sii DoraSkinWeightImpExp_TXTSL_jne_JointList`;\n\t\n\tif( size($selectItem)<=0 ){return(0);}\n\t\n\t\n\t$selectItem[0]=$selectItem[0]-1;\n\t\n\ttextField -e -text ($gDoraSkinWeightImpExp_jointNameNew[ $selectItem[0] ] ) DoraSkinWeightImpExp_TXTF_jne_JointName;\n\t\n\treturn( 1 );\n\t}\n\n\n\n\n\n\nglobal proc int DoraSkinWeightJointNameEdit_changeJointName( int $mode, int $selectMin )\n\t{\n\tglobal string $gDoraSkinWeightImpExp_jointNameNew[];\n\tint $selectItem[];\n\tint $i;\n\tstring $search,$replace;\n\tstring $workString;\n\tint $loop; \n\tstring $slList[];\n\t\n\t\n\t$selectItem= `textScrollList -q -sii DoraSkinWeightImpExp_TXTSL_jne_JointList`;\n\t\n\tif( size($selectItem)< $selectMin ){return(0);}\n\t\n\t\n\tfor( $i=0 ; $i<size($selectItem) ; $i++ )\n\t\t{\n\t\t$selectItem[$i]=$selectItem[$i]-1;\n\t\t}\n\t\n\t\n\t$slList= `ls -sl`;\n\t$slList= `ls -fl $slList`;\n\t\n\t\n\tfor( $loop=1, $i=0 ; $i<size($selectItem) && $loop==1  ; $i++ )\n\t\t{\n\t\tswitch( $mode )\n\t\t\t{\n\t\t\tcase 1:\n\t\t\t$gDoraSkinWeightImpExp_jointNameNew[$selectItem[$i]]=`textField -q -text DoraSkinWeightImpExp_TXTF_jne_JointName`;\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 2:\n\t\t\t$workString= $gDoraSkinWeightImpExp_jointNameNew[$selectItem[0]];\n\t\t\t$gDoraSkinWeightImpExp_jointNameNew[$selectItem[0]]=$gDoraSkinWeightImpExp_jointNameNew[$selectItem[1]];\n\t\t\t$gDoraSkinWeightImpExp_jointNameNew[$selectItem[1]]=$workString;\n\t\t\t$loop=0;\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 3:\n\t\t\tif( $i < size( $slList ) )\n\t\t\t\t{\n\t\t\t\t$gDoraSkinWeightImpExp_jointNameNew[$selectItem[$i]]=$slList[$i];\n\t\t\t\t}\n\t\t\telse{$loop=0;};\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 4:\n\t\t\t$search= `textField -q -text DoraSkinWeightImpExp_TXTF_jne_search`;\n\t\t\t$replace= `textField -q -text DoraSkinWeightImpExp_TXTF_jne_replace`;\n\t\t\t$gDoraSkinWeightImpExp_jointNameNew[$selectItem[$i]]= substitute( $search, $gDoraSkinWeightImpExp_jointNameNew[$selectItem[$i]], $replace  );\n\t\t\tbreak;\n\t\t\t\n\t\t\tcase 5:\n\t\t\t$gDoraSkinWeightImpExp_jointNameNew[$selectItem[$i]]=(`textField -q -text DoraSkinWeightImpExp_TXTF_jne_prefix` + $gDoraSkinWeightImpExp_jointNameNew[$selectItem[$i]] + `textField -q -text DoraSkinWeightImpExp_TXTF_jne_suffix` );\n\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\t\n\tDoraSkinWeightJointNameEdit_listUpdate();\n\t\n\t\n\tfor( $i=0 ; $i<size($selectItem) ; $i++ )\n\t\t{\n\t\ttextScrollList -e -sii ($selectItem[$i]+1) DoraSkinWeightImpExp_TXTSL_jne_JointList;\n\t\t}\n\t\n\t\n\treturn(1);\n\t}\n\n\n\n\n\n\n\nglobal proc int DoraSkinWeightJointNameEdit()\n\t{\n\tglobal string $gDoraSkinWeightImpExp_jointNameNew[];\n\tint $i;\n\tstring $workString;\n\tstring $workStringA[];\n\t\n\t\n\tif( `window -ex DoraSkinWeightImpExpWindow` == false ){return(0);}\n\t\n\t\n\tif( DoraSkinWeightJointNameEdit_SetgJointName()==0 ){return(0);}\n\t\n\t\n\t$workString=DoraSkinWeightJointNameEdit_jointEditListString();\n\t\n\t\n\t\n\tif( `windowPref -ex DoraSkinWeightImpExpJointNameEditWindow` == true )\n\t\t{\n\t\twindowPref -r DoraSkinWeightImpExpJointNameEditWindow;\n\t\t}\n\t\t\n\tif( `window -ex DoraSkinWeightImpExpJointNameEditWindow` == true )\n\t\t{\n\t\treturn(0);\n\t\t}\n\t\n\t$workStringA= `textScrollList -q  -si DoraSkinWeightImpExp_TXTSL_ImpList`;\n\t$workStringA[0]= ( $workStringA[0] + \" - \" + size( $gDoraSkinWeightImpExp_jointNameNew ) + \" joint\" );\n\n\t\n\twindow -wh 610 450 -t \"Edit JointMap\" -mxb 0 -mnb 1 -s 0 DoraSkinWeightImpExpJointNameEditWindow;\n\t\n\t\n\tcolumnLayout;\n\t\ttext -label $workStringA[0] DoraSkinWeightImpExp_TXT_jne_dswName;\n\t\teval( \"textScrollList -ams true -showIndexedItem 1 -w 600 -h 180 \" + $workString + \" DoraSkinWeightImpExp_TXTSL_jne_JointList\");\n\t\tbutton -label \"Set JointName\" -h 20 -w 100 BTN_jne_set;\n\t\ttextField -h 20 -w 600 DoraSkinWeightImpExp_TXTF_jne_JointName;\n\t\t\t\n\t\tseparator -h 10 -w 600;\n\t\t\n\t\tbutton -label \"Swap\" -h 20 -w 40 BTN_jne_swap;\n\t\tbutton -label \"Set SelectObjectName\" -h 20 -w 130 BTN_jne_selectName;\n\t\t\n\t\tseparator -h 10 -w 600;\n\t\t\n\t\tbutton -label \"Substitution\" -h 20 -w 70 BTN_jne_substitution;\n\t\trowLayout -columnWidth3 290 20 290 -numberOfColumns 3 -h 20;\n\t\t\ttextField -w 290 -h 20 DoraSkinWeightImpExp_TXTF_jne_search;\n\t\t\ttext -label \"->\" -al \"center\" -h 20;\n\t\t\ttextField -w 290 -h 20 DoraSkinWeightImpExp_TXTF_jne_replace;\n\t\t\tsetParent ..;\n\t\t\n\t\tseparator -h 10 -w 600;\n\t\t\n\t\tbutton -label \"Add Prefix/Suffix\" -h 20 -w 100 BTN_jne_add;\n\t\trowLayout -columnWidth3 265 70 265 -numberOfColumns 3 -h 20;\n\t\t\ttextField -w 265 -h 20 DoraSkinWeightImpExp_TXTF_jne_prefix;\n\t\t\ttext -label \"+ JointName +\" -al \"center\" -h 20;\n\t\t\ttextField -w 265 -h 20 DoraSkinWeightImpExp_TXTF_jne_suffix;\n\t\t\tsetParent ..;\n\t\t\n\t\tseparator -h 10 -w 600;\n\t\t\n\t\tbutton -label \"Reset\" -h 20 -w 40 BTN_jne_reset;\n\t\n\t\n\ttextScrollList -e -sc \"DoraSkinWeightJointNameEdit_jointNameUpdate()\" DoraSkinWeightImpExp_TXTSL_jne_JointList;\n\t\n\t\n\ttextScrollList -e -dcc \"DoraSkinWeightJointNameEdit_listAllSelect()\" DoraSkinWeightImpExp_TXTSL_jne_JointList;\n\t\n\t\n\tbutton -e -c \"DoraSkinWeightJointNameEdit_changeJointName( 1, 1 )\" BTN_jne_set;\n\t\n\ttextField -edit -ec \"DoraSkinWeightJointNameEdit_changeJointName( 1, 1 )\" DoraSkinWeightImpExp_TXTF_jne_JointName;\n\t\n\t\n\tbutton -e -c \"DoraSkinWeightJointNameEdit_changeJointName( 2, 2 )\" BTN_jne_swap;\n\t\n\t\n\tbutton -e -c \"DoraSkinWeightJointNameEdit_reload()\" BTN_jne_reset;\n\t\n\t\n\tbutton -e -c \"DoraSkinWeightJointNameEdit_changeJointName( 4, 1 )\" BTN_jne_substitution;\n\t\n\t\n\tbutton -e -c \"DoraSkinWeightJointNameEdit_changeJointName( 5, 1 )\" BTN_jne_add;\n\t\n\t\n\tbutton -e -c \"DoraSkinWeightJointNameEdit_changeJointName( 3, 1 )\" BTN_jne_selectName;\n\t\n\tshowWindow DoraSkinWeightImpExpJointNameEditWindow;\n\t\n\treturn(1);\n\t}\n\n\n\n\n\n\nglobal proc DoraSkinWeightImpExp()\n\t{\n\tglobal string $gDoraSkinWeight_ver;\n\tglobal int $gDoraSkinWeightImpExp_ImpMode;\n\tstring $work, $work2;\n\tstring $dswAppendList;\n\t\n\tprint (\"Dora SkinWeight Imp/Exp \" + $gDoraSkinWeight_ver + \"\\n\" );\n\t\n\t\n\tif( `windowPref -ex DoraSkinWeightImpExpWindow` == true )\n\t\t{\n\t\twindowPref -r DoraSkinWeightImpExpWindow;\n\t\t}\n\t\t\n\tif( `window -ex DoraSkinWeightImpExpWindow` == false )\n\t\t{\n\t\twindow -wh 244 382\n\t\t       -t (\"Dora SkinWeight\" )\n\t\t       -mnb 1\n\t\t       -s 0\n\t\t       -mxb 0\n\t\t       DoraSkinWeightImpExpWindow;\n\t\t\n\t\t$gDoraSkinWeightImpExp_ImpMode= 0;\n\t\t\n\t\t\n\t\t$dswAppendList= DoraSkinWeightImpExp_dswAppendListGet();\n\t\t\n\t\tcolumnLayout;\n\t\t\n\t\ttabLayout DoraSkinWeightImpExp_TL;\n\t\t\t\n\t\t\tcolumnLayout DoraSkinWeightImpExp_ImpL;\n\t\t\t\tseparator -w 223 -h 10 -style none;\n\t\t\t\ttext -label \"DSW File List\" -h 20;\n\t\t\t\ttextScrollList -w 220 -h 80  -shi 1 DoraSkinWeightImpExp_TXTSL_ImpList;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t$work2= \"textField -e -text `textScrollList -q -si DoraSkinWeightImpExp_TXTSL_ImpList` DoraSkinWeightImpExp_TXTF_ImpName;DoraSkinWeightJointNameEdit_reload();\";\n\t\t\t\t$work= (\"textScrollList -e \" + $dswAppendList + \" -sc \\\"\" + $work2 + \"\\\" DoraSkinWeightImpExp_TXTSL_ImpList\" );\n\t\t\t\teval( $work );\n\t\t\t\t\n\t\t\t\ttextField -vis false DoraSkinWeightImpExp_TXTF_ImpName;\n\t\t\t\tseparator -h 10 -style none;\n\t\t\t\ttext -label \"Import Mode\" -h 20;\n\t\t\t\tradioCollection;\n\t\t\t\t\tradioButton -label \"Vertex Order\" -sl -h 20 DoraSkinWeightImpExp_RDOC_ImpMode1;\n\t\t\t\t\tradioButton -label \"XYZ Position\" -h 20 DoraSkinWeightImpExp_RDOC_ImpMode2;\n\t\t\t\t\tradioButton -label \"UV Position\" -h 20 DoraSkinWeightImpExp_RDOC_ImpMode3;\n\t\t\t\t\n\t\t\t\trowLayout -columnWidth2 80 100 -numberOfColumns 2 -h 20;\n\t\t\t\t\ttext -label \"Accuracy\" -h 20 -en false DoraSkinWeightImpExp_TXT_Accuracy;\n\t\t\t\t\tfloatField -value 0.001 -pre 6 -en false -w 100 -h 20 DoraSkinWeightImpExp_FFLD_Accuracy;\n\t\t\t\t\tsetParent ..;\n\t\t\t\t\n\t\t\t\tseparator -h 10 -w 220;\n\t\t\t\trowLayout -columnWidth3 100 60 60 -numberOfColumns 3 -h 20;\n\t\t\t\t\tcheckBox -label \"Interpolation\" -en true -value false -h 20 DoraSkinWeightImpExp_CKBX_Interpolation;\n\t\t\t\t\tradioCollection DoraSkinWeightImpExp_RDOC_InterpolationMode;\n\t\t\t\t\t\tradioButton -label \"XYZ\" -data 1 -en false -sl -h 20 DoraSkinWeightImpExp_RDOC_InterpolationMode1;\n\t\t\t\t\t\tradioButton -label \"UV\" -data 2 -en false -h 20 DoraSkinWeightImpExp_RDOC_InterpolationMode2;\n\t\t\t\t\tsetParent ..;\n\t\t\t\t\t\n\t\t\t\tseparator -h 10 -w 220;\n\t\t\t\tbutton -label \"Edit JointMap\" -h 20 -w 110 BTN_jne;\n\t\t\t\t\n\t\t\t\tseparator -w 223 -h 10 -style none;\n\t\t\t\tbutton -label \"Import DSW\" -h 20 -w 220 BTN_imp;\n\t\t\t\tseparator -h 10 -style none;\n\t\t\t\t\n\t\t\t\tsetParent ..;\n\t\t\t\n\t\t\tcolumnLayout DoraSkinWeightImpExp_ExpL;\n\t\t\t\tseparator -w 223 -h 10 -style none;\n\t\t\t\ttext -label \"DSW File List\" -h 20;\n\t\t\t\ttextScrollList -w 220 -h 80  -shi 1 DoraSkinWeightImpExp_TXTSL_ExpList;\n\t\t\t\tif( size( $dswAppendList ) != 0 )\n\t\t\t\t\t{\n\t\t\t\t\t$work2= \"textField -e -text `textScrollList -q -si DoraSkinWeightImpExp_TXTSL_ExpList` DoraSkinWeightImpExp_TXTF_ExpName\";\n\t\t\t\t\t$work= (\"textScrollList -e \" + $dswAppendList + \" -sc \\\"\" + $work2 + \"\\\" DoraSkinWeightImpExp_TXTSL_ExpList\" );\n\t\t\t\t\teval( $work );\n\t\t\t\t\t}\n\t\t\t\tseparator -h 10 -style none;\n\t\t\t\ttext -label \"Export Name\" -h 20;\n\t\t\t\ttextField -h 20 -w 220 DoraSkinWeightImpExp_TXTF_ExpName;\n\t\t\t\tseparator -w 223 -h 10 -style none;\n\t\t\t\tbutton -label \"Export DSW\" -w 220 -h 20 BTN_exp;\n\t\t\t\tseparator -h 10 -style none;\n\t\t\t\tsetParent ..;\n\t\t\t\n\t\t\tcolumnLayout DoraSkinWeightImpExp_etcL;\n\t\t\t\tseparator -w 223 -h 10 -style none;\n\t\t\t\tbutton -label \"Check DSW XYZ Point\" -w 220 -h 20 BTN_chkXYZ;\n\t\t\t\tseparator -h 10 -style none;\n\t\t\t\t\n\t\t\t\tsetParent ..;\n\t\t\t\n\t\t\t\n\t\t\ttabLayout -edit\n \t\t\t\t-tabLabel DoraSkinWeightImpExp_ImpL \"Import\"\n \t\t\t\t-tabLabel DoraSkinWeightImpExp_ExpL \"Export\"\n \t\t\t\t-tabLabel DoraSkinWeightImpExp_etcL \"etc\"\n \t\t\t\tDoraSkinWeightImpExp_TL;\n \t\t\t\n \t\t\t\n\t\t\tsetParent ..;\n\t\t\n\t\tformLayout FootL;\n\t\t\n\t\t\n\t\tradioButton -e -onc \"$gDoraSkinWeightImpExp_ImpMode= 0;floatField -e -en false DoraSkinWeightImpExp_FFLD_Accuracy;text -e -en false DoraSkinWeightImpExp_TXT_Accuracy;\" DoraSkinWeightImpExp_RDOC_ImpMode1;\n\t\tradioButton -e -onc \"$gDoraSkinWeightImpExp_ImpMode= 1;floatField -e -en true DoraSkinWeightImpExp_FFLD_Accuracy;text -e -en true DoraSkinWeightImpExp_TXT_Accuracy;\" DoraSkinWeightImpExp_RDOC_ImpMode2;\n\t\tradioButton -e -onc \"$gDoraSkinWeightImpExp_ImpMode= 2;floatField -e -en true DoraSkinWeightImpExp_FFLD_Accuracy;text -e -en true DoraSkinWeightImpExp_TXT_Accuracy;\" DoraSkinWeightImpExp_RDOC_ImpMode3;\n\t\t\n\t\tcheckBox -e -onc \"radioButton -e -en true DoraSkinWeightImpExp_RDOC_InterpolationMode1;radioButton -e -en true DoraSkinWeightImpExp_RDOC_InterpolationMode2;\" DoraSkinWeightImpExp_CKBX_Interpolation;\n\t\tcheckBox -e -ofc \"radioButton -e -en false DoraSkinWeightImpExp_RDOC_InterpolationMode1;radioButton -e -en false DoraSkinWeightImpExp_RDOC_InterpolationMode2;\" DoraSkinWeightImpExp_CKBX_Interpolation;\n\t\t\n\t\tbutton -edit -command \"DoraSkinWeightImport( `textField -q -text DoraSkinWeightImpExp_TXTF_ImpName`, $gDoraSkinWeightImpExp_ImpMode, `checkBox -q -value DoraSkinWeightImpExp_CKBX_Interpolation`, eval( \\\"radioButton -q -da \\\" + `radioCollection -q -sl DoraSkinWeightImpExp_RDOC_InterpolationMode`),`floatField -q -value DoraSkinWeightImpExp_FFLD_Accuracy` )\" BTN_imp;\n\t\t\n\t\tbutton -edit -command \"DoraSkinWeightExport( `textField -q -text DoraSkinWeightImpExp_TXTF_ExpName`);DoraSkinWeightFileListUpdate();\" BTN_exp;\n\t\t\n\t\tbutton -edit -command \"DoraSkinWeightXYZCheck()\" BTN_chkXYZ;\n\t\t\n\t\tbutton -edit -command \"DoraSkinWeightJointNameEdit()\" BTN_jne;\n\t\t\n\t\ttextField -edit -ec \"DoraSkinWeightExport(`textField -q -text DoraSkinWeightImpExp_TXTF_ExpName`);DoraSkinWeightFileListUpdate();\" DoraSkinWeightImpExp_TXTF_ExpName;\n\t\t\n\t\t\n\t\tshowWindow DoraSkinWeightImpExpWindow;\n\t\t}\n\t}\n\nDoraSkinWeightImpExp()" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Allows interaction with objects during playback" 
        -enableBackground 0
        -align "center" 
        -label "Interactive Playback" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.25 
        -image "interactivePlayback.png" 
        -image1 "interactivePlayback.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "InteractivePlayback" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "#IKSpline Generator. Alex Tavener 2015\n#USE: Select 1 joint and run.\n\nimport maya.cmds as cmds\n\n\ndef IKSplineGen(numOfJoints):\n    \n    jointlist = cmds.ls(sl=True)\n    startJnt = jointlist[0]\n    jointlist = cmds.duplicate(jointlist[0],rc=1)\n    \n    if len(jointlist) > 2:\n        cmds.delete(jointlist[2:])\n        jointlist = jointlist[:2]\n    \n    \n    endJnt = jointlist[1]\n    parentRadius = (cmds.getAttr(jointlist[0]+'.radius'))/2\n    \n    translates = []\n    overall = []\n    \n    for i in jointlist:\n        translates.append(cmds.xform(i,t = True, q=True,ws=True,r=True))\n    \n    \n    #convert this to tuples to be used in curve creation\n    for i in range(0,(len(translates))):\n        print i\n        overall.append((tuple(translates[i])))\n    \n    #curve creation\n    splineCurve = cmds.curve(n='spline_curve',p=overall[:],d=1)\n    \n    #rebuild for spline\n    cmds.select(d=True)\n    cmds.select(splineCurve)\n    #cmds.rebuildCurve(n = splineCurve, ch = 1, rpo = 1, rt = 0, end = 1, kr = 0, kcp = 0, kep = 0, kt = 0, s = 1, d = 2, tol = 0.01)\n    cmds.rebuildCurve(n = splineCurve, ch = 1, rpo = 1, rt = 0, end = 1, kr = 0, kcp = 0, kep = 1, kt = 0, s = 3, d = 3, tol = 0.01)\n    \n    cmds.select(splineCurve)\n    cmds.rebuildCurve(n = splineCurve, rt = 1, s=0)\n    \n    #Create clusters\n    clusterNames = ['top_cluster','mid_cluster','bot_cluster']\n    clusterList = []\n    for i in range(0,3):\n        cmds.select(splineCurve+'.cv[:]')\n        clusterList.append(cmds.cluster(n=clusterNames[i])[0])\n    \n    #Move cluster pivots to relative joints\n    midDistanceFinder = (cmds.polyCube(n='distanceFinder')[0])\n    cmds.pointConstraint(jointlist[0],jointlist[1],midDistanceFinder,mo=0)\n    midDistance = cmds.xform(midDistanceFinder,q=1,t=1)\n    cmds.delete(midDistanceFinder)\n    \n    cmds.xform(clusterList[0]+'Handle',sp=translates[0],rp=translates[0])\n    cmds.xform(clusterList[1]+'Handle',sp=midDistance,rp=midDistance)\n    cmds.xform(clusterList[2]+'Handle',sp=translates[1],rp=translates[1])\n    \n    #Apply Linear weights to curve\n    curveLength = cmds.arclen(splineCurve)\n    #top\n    cmds.select(splineCurve)\n    cmds.percent(clusterList[0],dp=translates[0],dt='linear' ,dds = curveLength/2)\n    #bottom\n    cmds.select(splineCurve)\n    cmds.percent(clusterList[2],dp=translates[1],dt='linear' ,dds = curveLength/2)\n    #mid\n    cmds.select(splineCurve)\n    cmds.percent(clusterList[1],dp=midDistance,dt='linear' ,dds = curveLength/2)\n    \n    clusterOffsets = []\n    clusterSdks = []\n    clusterCtrls = []\n    #Cluster Controls\n    for i in clusterList:\n        ctrl = cmds.circle(n=i+'_ctrl')\n        sdk = cmds.group(n=i+'_sdk')\n        offset = cmds.group(n=i+'_offset')\n        oC = cmds.orientConstraint(jointlist[0],offset)\n        cmds.delete(oC)\n        pC = cmds.pointConstraint(i+'Handle',offset)\n        cmds.delete(pC)\n        cmds.pointConstraint(ctrl,i+'Handle')\n        clusterOffsets.append(offset)\n        clusterSdks.append(sdk)\n        clusterCtrls.append(ctrl[0])\n    \n    #Control Nodes\n    blendNode = cmds.shadingNode('blendColors',asUtility = 1,n='blendSplineTranslate')\n    cmds.connectAttr(clusterCtrls[0]+'.translate', blendNode+'.color1')\n    cmds.connectAttr(clusterCtrls[2]+'.translate', blendNode+'.color2')\n    cmds.connectAttr(blendNode+'.output',clusterSdks[1]+'.translate')\n    \n    #Divide Joints\n    global newjointlist\n    newjointlist = []\n    newjointlist.append(jointlist[0])\n    \n    def divideBone(div):\n        global newjointlist\n        # Find distance each new joint will need to move relative to it's parent.\n        startJoint = jointlist[0]\n        endJoint = cmds.listRelatives(startJoint,c=1)[0]\n        distance = cmds.getAttr(endJoint+\".tx\")\n        moveDist = distance/(div+1)\n        \n        for i in range(1,div+1):\n            newJoint = cmds.insertJoint(startJoint)\n            newJoint = cmds.rename(newJoint, \"spline_\"+str(i+1)+'_jnt')\n            newjointlist.append(newJoint)\n            \n            cmds.move(moveDist, 0, 0, newJoint+\".scalePivot\", newJoint+\".rotatePivot\", r=True, os=True)\n            startJoint = newJoint\n            \n            cmds.select(newJoint)\n    \n    divideBone(numOfJoints) ####################################################   <---------------- Num of joints\n    newjointlist.append(jointlist[1])\n    cmds.select(d=True)\n    \n    #rename some naughty joints\n    start = cmds.rename(jointlist[0],'spline_1_jnt')\n    end = cmds.rename(jointlist[-1],'spline_'+str(len(newjointlist))+'_jnt')\n    jointlist[0] = start\n    jointlist[-1] = end\n    newjointlist[0] = start\n    newjointlist[-1] = end\n    \n    #IK Handle\n    cmds.select(jointlist[0],jointlist[1],splineCurve)\n    IkHandle = cmds.ikHandle(n='spline_IK', sol = 'ikSplineSolver', ccv = False, pcv = False)\n    \n    #Make Stretchy\n    curveInfo = cmds.arclen(splineCurve,ch=1)\n    \n    multiplyX = cmds.shadingNode('multiplyDivide',asUtility = 1,n='MultiplyDivideX')\n    multiplyYZ = cmds.shadingNode('multiplyDivide',asUtility = 1,n='MultiplyDivideYZ')\n    cmds.setAttr(multiplyX+'.operation', 2)\n    cmds.setAttr(multiplyYZ+'.operation', 2)\n    \n    cmds.connectAttr(curveInfo+'.arcLength',multiplyX+'.input1.input1X')\n    cmds.setAttr(multiplyX+'.input2.input2X',curveLength)\n    \n    cmds.connectAttr(curveInfo+'.arcLength',multiplyYZ+'.input2.input2X')\n    cmds.setAttr(multiplyYZ+'.input1.input1X',curveLength)\n    \n    \n    for i in newjointlist:\n        cmds.connectAttr(multiplyX+'.output.outputX',i+'.scale.scaleX')\n        cmds.connectAttr(multiplyYZ+'.output.outputX',i+'.scale.scaleY')\n        cmds.connectAttr(multiplyYZ+'.output.outputX',i+'.scale.scaleZ')\n        cmds.setAttr(i+'.radius',parentRadius)\n    \n        \n    #enable advanced twist controls\n    cmds.setAttr(IkHandle[0]+'.dTwistControlEnable', 1)\n    cmds.setAttr(IkHandle[0]+'.dWorldUpType', 4)\n    cmds.connectAttr(clusterCtrls[0]+'.worldMatrix[0]',IkHandle[0]+'.dWorldUpMatrix')\n    cmds.connectAttr(clusterCtrls[2]+'.worldMatrix[0]',IkHandle[0]+'.dWorldUpMatrixEnd')\n    \n    #un-parent the spline\n    a = cmds.listRelatives(newjointlist[0],p=1)\n    if a:\n        cmds.parent(newjointlist[0],w=True)\n    \n    #Make offset group for controls and parent to initial joint.\n    splineGrp = cmds.group(n='spline_grp',em=1)\n    pC = cmds.parentConstraint(startJnt,splineGrp)\n    cmds.delete(pC)\n    \n    splineOffset = cmds.group(n='spline_grp_offset',em=1)\n    pC = cmds.parentConstraint(startJnt,splineOffset)\n    cmds.delete(pC)\n    \n    cmds.parent(splineGrp,splineOffset)\n    \n    for i in clusterOffsets:\n        cmds.parent(i,splineGrp)\n    \n    cmds.parentConstraint(startJnt,splineOffset)\n    \n    print '# IK Spline Ribbon added successfully.'\n\n\ndef getValue(slider):\n    value = cmds.intSliderGrp(slider,q=1,v=1)\n    return value\n\n\n\n#################### GUI ####################\n\n\ndef GUI():\n    if cmds.window(\"Spline Generator\", exists=True):\n        cmds.deleteUI(\"Spline Generator\")\n    \n    cmds.window(\"Spline Generator\",title=\"IK Spline Generator\")\n    \n    cmds.frameLayout(marginHeight=5, marginWidth=5, labelVisible=False)\n    cmds.columnLayout()   \n     \n    img2=cmds.text(label = '                         IK Spline Generator')\n    cmds.separator()\n    \n    FL2 = cmds.frameLayout(marginHeight=5, marginWidth=5, labelVisible=False)\n    \n    valueSlider = cmds.intSliderGrp('jointNum',field=1, min=1, max=20, value=5, step=1, p=FL2 )\n    \n    cmds.button(label=\"Create Spline\", height=25, width=150,\n                command=\"IKSplineGen(getValue('jointNum'))\")\n        \n    cmds.showWindow()\n\nGUI()" 
        -enableBackground 0
        -align "center" 
        -label "#IKSpline Generator. Alex Tavener 2015\n#USE: Select 1 joint and ..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "SPLINE" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "pythonFamily.png" 
        -image1 "pythonFamily.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "#IKSpline Generator. Alex Tavener 2015\n#USE: Select 1 joint and run.\n\nimport maya.cmds as cmds\n\n\ndef IKSplineGen(numOfJoints):\n    \n    jointlist = cmds.ls(sl=True)\n    startJnt = jointlist[0]\n    jointlist = cmds.duplicate(jointlist[0],rc=1)\n    \n    if len(jointlist) > 2:\n        cmds.delete(jointlist[2:])\n        jointlist = jointlist[:2]\n    \n    \n    endJnt = jointlist[1]\n    parentRadius = (cmds.getAttr(jointlist[0]+'.radius'))/2\n    \n    translates = []\n    overall = []\n    \n    for i in jointlist:\n        translates.append(cmds.xform(i,t = True, q=True,ws=True,r=True))\n    \n    \n    #convert this to tuples to be used in curve creation\n    for i in range(0,(len(translates))):\n        print i\n        overall.append((tuple(translates[i])))\n    \n    #curve creation\n    splineCurve = cmds.curve(n='spline_curve',p=overall[:],d=1)\n    \n    #rebuild for spline\n    cmds.select(d=True)\n    cmds.select(splineCurve)\n    #cmds.rebuildCurve(n = splineCurve, ch = 1, rpo = 1, rt = 0, end = 1, kr = 0, kcp = 0, kep = 0, kt = 0, s = 1, d = 2, tol = 0.01)\n    cmds.rebuildCurve(n = splineCurve, ch = 1, rpo = 1, rt = 0, end = 1, kr = 0, kcp = 0, kep = 1, kt = 0, s = 3, d = 3, tol = 0.01)\n    \n    cmds.select(splineCurve)\n    cmds.rebuildCurve(n = splineCurve, rt = 1, s=0)\n    \n    #Create clusters\n    clusterNames = ['top_cluster','mid_cluster','bot_cluster']\n    clusterList = []\n    for i in range(0,3):\n        cmds.select(splineCurve+'.cv[:]')\n        clusterList.append(cmds.cluster(n=clusterNames[i])[0])\n    \n    #Move cluster pivots to relative joints\n    midDistanceFinder = (cmds.polyCube(n='distanceFinder')[0])\n    cmds.pointConstraint(jointlist[0],jointlist[1],midDistanceFinder,mo=0)\n    midDistance = cmds.xform(midDistanceFinder,q=1,t=1)\n    cmds.delete(midDistanceFinder)\n    \n    cmds.xform(clusterList[0]+'Handle',sp=translates[0],rp=translates[0])\n    cmds.xform(clusterList[1]+'Handle',sp=midDistance,rp=midDistance)\n    cmds.xform(clusterList[2]+'Handle',sp=translates[1],rp=translates[1])\n    \n    #Apply Linear weights to curve\n    curveLength = cmds.arclen(splineCurve)\n    #top\n    cmds.select(splineCurve)\n    cmds.percent(clusterList[0],dp=translates[0],dt='linear' ,dds = curveLength/2)\n    #bottom\n    cmds.select(splineCurve)\n    cmds.percent(clusterList[2],dp=translates[1],dt='linear' ,dds = curveLength/2)\n    #mid\n    cmds.select(splineCurve)\n    cmds.percent(clusterList[1],dp=midDistance,dt='linear' ,dds = curveLength/2)\n    \n    clusterOffsets = []\n    clusterSdks = []\n    clusterCtrls = []\n    #Cluster Controls\n    for i in clusterList:\n        ctrl = cmds.circle(n=i+'_ctrl')\n        sdk = cmds.group(n=i+'_sdk')\n        offset = cmds.group(n=i+'_offset')\n        oC = cmds.orientConstraint(jointlist[0],offset)\n        cmds.delete(oC)\n        pC = cmds.pointConstraint(i+'Handle',offset)\n        cmds.delete(pC)\n        cmds.pointConstraint(ctrl,i+'Handle')\n        clusterOffsets.append(offset)\n        clusterSdks.append(sdk)\n        clusterCtrls.append(ctrl[0])\n    \n    #Control Nodes\n    blendNode = cmds.shadingNode('blendColors',asUtility = 1,n='blendSplineTranslate')\n    cmds.connectAttr(clusterCtrls[0]+'.translate', blendNode+'.color1')\n    cmds.connectAttr(clusterCtrls[2]+'.translate', blendNode+'.color2')\n    cmds.connectAttr(blendNode+'.output',clusterSdks[1]+'.translate')\n    \n    #Divide Joints\n    global newjointlist\n    newjointlist = []\n    newjointlist.append(jointlist[0])\n    \n    def divideBone(div):\n        global newjointlist\n        # Find distance each new joint will need to move relative to it's parent.\n        startJoint = jointlist[0]\n        endJoint = cmds.listRelatives(startJoint,c=1)[0]\n        distance = cmds.getAttr(endJoint+\".tx\")\n        moveDist = distance/(div+1)\n        \n        for i in range(1,div+1):\n            newJoint = cmds.insertJoint(startJoint)\n            newJoint = cmds.rename(newJoint, \"spline_\"+str(i+1)+'_jnt')\n            newjointlist.append(newJoint)\n            \n            cmds.move(moveDist, 0, 0, newJoint+\".scalePivot\", newJoint+\".rotatePivot\", r=True, os=True)\n            startJoint = newJoint\n            \n            cmds.select(newJoint)\n    \n    divideBone(numOfJoints) ####################################################   <---------------- Num of joints\n    newjointlist.append(jointlist[1])\n    cmds.select(d=True)\n    \n    #rename some naughty joints\n    start = cmds.rename(jointlist[0],'spline_1_jnt')\n    end = cmds.rename(jointlist[-1],'spline_'+str(len(newjointlist))+'_jnt')\n    jointlist[0] = start\n    jointlist[-1] = end\n    newjointlist[0] = start\n    newjointlist[-1] = end\n    \n    #IK Handle\n    cmds.select(jointlist[0],jointlist[1],splineCurve)\n    IkHandle = cmds.ikHandle(n='spline_IK', sol = 'ikSplineSolver', ccv = False, pcv = False)\n    \n    #Make Stretchy\n    curveInfo = cmds.arclen(splineCurve,ch=1)\n    \n    multiplyX = cmds.shadingNode('multiplyDivide',asUtility = 1,n='MultiplyDivideX')\n    multiplyYZ = cmds.shadingNode('multiplyDivide',asUtility = 1,n='MultiplyDivideYZ')\n    cmds.setAttr(multiplyX+'.operation', 2)\n    cmds.setAttr(multiplyYZ+'.operation', 2)\n    \n    cmds.connectAttr(curveInfo+'.arcLength',multiplyX+'.input1.input1X')\n    cmds.setAttr(multiplyX+'.input2.input2X',curveLength)\n    \n    cmds.connectAttr(curveInfo+'.arcLength',multiplyYZ+'.input2.input2X')\n    cmds.setAttr(multiplyYZ+'.input1.input1X',curveLength)\n    \n    \n    for i in newjointlist:\n        cmds.connectAttr(multiplyX+'.output.outputX',i+'.scale.scaleX')\n        cmds.connectAttr(multiplyYZ+'.output.outputX',i+'.scale.scaleY')\n        cmds.connectAttr(multiplyYZ+'.output.outputX',i+'.scale.scaleZ')\n        cmds.setAttr(i+'.radius',parentRadius)\n    \n        \n    #enable advanced twist controls\n    cmds.setAttr(IkHandle[0]+'.dTwistControlEnable', 1)\n    cmds.setAttr(IkHandle[0]+'.dWorldUpType', 4)\n    cmds.connectAttr(clusterCtrls[0]+'.worldMatrix[0]',IkHandle[0]+'.dWorldUpMatrix')\n    cmds.connectAttr(clusterCtrls[2]+'.worldMatrix[0]',IkHandle[0]+'.dWorldUpMatrixEnd')\n    \n    #un-parent the spline\n    a = cmds.listRelatives(newjointlist[0],p=1)\n    if a:\n        cmds.parent(newjointlist[0],w=True)\n    \n    #Make offset group for controls and parent to initial joint.\n    splineGrp = cmds.group(n='spline_grp',em=1)\n    pC = cmds.parentConstraint(startJnt,splineGrp)\n    cmds.delete(pC)\n    \n    splineOffset = cmds.group(n='spline_grp_offset',em=1)\n    pC = cmds.parentConstraint(startJnt,splineOffset)\n    cmds.delete(pC)\n    \n    cmds.parent(splineGrp,splineOffset)\n    \n    for i in clusterOffsets:\n        cmds.parent(i,splineGrp)\n    \n    cmds.parentConstraint(startJnt,splineOffset)\n    \n    print '# IK Spline Ribbon added successfully.'\n\n\ndef getValue(slider):\n    value = cmds.intSliderGrp(slider,q=1,v=1)\n    return value\n\n\n\n#################### GUI ####################\n\n\ndef GUI():\n    if cmds.window(\"Spline Generator\", exists=True):\n        cmds.deleteUI(\"Spline Generator\")\n    \n    cmds.window(\"Spline Generator\",title=\"IK Spline Generator\")\n    \n    cmds.frameLayout(marginHeight=5, marginWidth=5, labelVisible=False)\n    cmds.columnLayout()   \n     \n    img2=cmds.text(label = '                         IK Spline Generator')\n    cmds.separator()\n    \n    FL2 = cmds.frameLayout(marginHeight=5, marginWidth=5, labelVisible=False)\n    \n    valueSlider = cmds.intSliderGrp('jointNum',field=1, min=1, max=20, value=5, step=1, p=FL2 )\n    \n    cmds.button(label=\"Create Spline\", height=25, width=150,\n                command=\"IKSplineGen(getValue('jointNum'))\")\n        \n    cmds.showWindow()\n\nGUI()" 
        -sourceType "python" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "import maya.cmds as cmds\n\nobject = cmds.ls(sl=True)\n\ndef makeControlGroups(object):\n    cmds.group(object,n=object+'_sdk')\n    cmds.group(n=object+'_offset')\n\nmakeControlGroups(object)" 
        -enableBackground 0
        -align "center" 
        -label "import maya.cmds as cmds\n\nobject = cmds.ls(sl=True)\n\ndef makeCon..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "Grps" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "pythonFamily.png" 
        -image1 "pythonFamily.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "import maya.cmds as cmds\n\nobject = cmds.ls(sl=True)[0]\n\ndef makeControlGroups(object):\n    cmds.group(object,n=object+'_sdk')\n    cmds.group(n=object+'_offset')\n\nmakeControlGroups(object)" 
        -sourceType "python" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "AbSymMesh Flip Meshes" 
        -enableBackground 0
        -align "center" 
        -label "/*\nabSymMesh v 1.91\nbrendan ross 03.10.2004\nwww.supercrumbly.com..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "Absym" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "commandButton.png" 
        -image1 "commandButton.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "/*\nabSymMesh v 1.91\nbrendan ross 03.10.2004\nwww.supercrumbly.com\n\nupdate -- 09.20.2004: \"Select Moved Verts\" button will select vertices that have been moved relative to the base mesh.\nupdate -- 3.21.2005: Added progress bar for \"Select Moved Verts\".  I love progress bars.\nupdate -- 10.12.2006: Added popupMenu to \"Revert Selected to Base\" button to revert by a given percentage.  Added $abSymProgBarThresh to adjust the number of verts included in an operation before a progress bar will be displayed (adjust higher for faster computers).\nupdate -- 10.25.2006: Added a slider to dynamically revert selected verts to base object.  The slider only works on vertex selections, not on the object level (too slow).  You can now specify alternate versions of the base mesh to revert to as well.  Improved performance of revert.\nupdate -- 12.04.2006: It should now work in Maya 8.\nupdate -- 4.12.2008: Added operations menu.  Allows you to copy, add and subtract blendshapes from one another.\nupdate -- 1.29.2009: Added limited ability to establish symmetry.\nupdate -- 9.19.2013: Added \"Attempt To Restore Symmetry\" to (new) \"Tools\" menu.\nupdate -- v. 1.91 datae: 10.28.2013: Added float field to the revert slider.  Fixed issue with duplicate menu name preventing script from loading. \n\nuse:\n\nA useful little script for building symmetrical and asymmetrical blendshapes.  Check for symmetry, mirror\nand flip polygon geometry, and much more.\n\n(ok, not much more, but it is pretty useful)\n\ndirections:\n\nIt should be fairly self explanatory, but here goes.\n\nSelect a mesh and click \"Check Symmetry\" to highlight asymmetric vertices.  \n\nTo use the selection mirror, mirror selected, flip, and revert functions, you must first select a symmetrical mesh\nand click \"Select Base Geometry.\"  You can now select a duplicate mesh with the same structure,  and you should be\nable to use all of the functions on it.  Revert, mirror, and flip work on both vertex (component) and object selections.\n\nUncheck \"Use Pivot as Origin\" to evaluate your objects using the mirror axis world origin as \nyour axis of symmetry.  \n\nThat's it.  I hope you find it useful.\n*/\n\nglobal int $abSymProgBarThresh = 800; //number of verts in an operation beyond which a progress bar is shown (set higher for faster computers)\nglobal int $abSymTable[];\n\nglobal string $abSymRevVertTable[];\nglobal vector $abSymRevPosTable[];\nglobal vector $abSymRevBasePosTable[];\nglobal int $abSymSliderDragging = false; //used to flag when the mouse is dragging a slider\n\nglobal proc string[] abCheckSym(string $obj, int $axis, float $tol, int $bTable, int $usePiv) {\n\t//$bTable is bool to use $obj to create and populate $abSymTable\n\t//which goes a little like {obj.vtx[pos mAxis 1], obj.vtx[neg mAxis 1]}\n\t\t\n\tglobal int $abSymTable[];\n\tstring $aNegVerts[];\n\tstring $aPosVerts[];\n\tstring $aNonSymVerts[];\n\tstring $aStr[];\n\tstring $vtx;\n\tstring $str;\n\tint $aPosVertsInt[];\n\tint $aNegVertsInt[];\n\tint $aInt[];\n\tint $totVtx;\n\tint $i;\n\tint $j;\n\tint $mAxisInd = $axis - 1; //mirror axis index (for xform)\n\tint $axis2Ind = ($mAxisInd + 1) % 3;\n\tint $axis3Ind = ($mAxisInd + 2) % 3;\n\tint $mod;\n\tint $prog;\n\tint $vertCounter = 0;\n\tfloat $aNegVertTrans[];\n\tfloat $aPosVertTrans[];\n\tfloat $aVtxTrans[];\n\tfloat $aVtx2Trans[];\n\tfloat $bBox[];\n\tfloat $mid;\n\tfloat $midOffset;\n\tfloat $posOffset;\n\tfloat $negOffset;\n\tfloat $flt;\n\tfloat $progNum;\n\tfloat $progDenom;\n\tfloat $test1;\n\tfloat $test2;\n\t\n\tfloat $midOffsetTol = -.0000001;\n\t\n\tif ($usePiv){\n\t\t$aVtxTrans = `xform -q -ws -t $obj`;\n\t\t$mid = $aVtxTrans[$mAxisInd];\n\t}else{\n\t\tif ($bTable){\n\t\t\t$bBox = `xform -q -ws -boundingBox $obj`;\n\t\t\t$mid = $bBox[$mAxisInd] + (($bBox[($mAxisInd+3)] - $bBox[$mAxisInd])/2);\n\t\t}else{\n\t\t\t$mid = 0; //if object isn't symmetrical, it's got to be at the origin to measure symmetry\n\t\t}\n\t}\n\t\n\tif ($bTable) clear($abSymTable);\n\t\t\n\t$aInt = `polyEvaluate -v $obj`; \n\t$totVtx = $aInt[0];\n\t\n\twaitCursor -state on;\n\tprogressWindow -title \"Working\" -progress 0 -status \"Sorting\";\n\t$progDenom = $totVtx;\n\t$flt = ceil($progDenom/50);\n\t$mod = $flt;\n\n\tfor ($i=0;$i<$totVtx;$i++){\n\t\t\n\t\t//prog win\n\t\tif (($i % $mod) == 0){ //make the progress bar a bit less resource intensive\n\t\t\t$progNum = $i;\n\t\t\t$prog = ($progNum/$progDenom)*100.0;\n\t\t\tprogressWindow -e -progress $prog;\n\t\t}\n\t\t//end prog win\n\t\t\n\t\t$vtx = $obj+\".vtx[\"+$i+\"]\";\n\t\t$aVtxTrans = `xform -q -ws -translation $vtx`;\n\t\t$midOffset = $aVtxTrans[$mAxisInd] - $mid;\n\t\tif ($midOffset >= $midOffsetTol){\n\t\t\t$aPosVerts[size($aPosVerts)] = $vtx;\n\t\t\tif ($bTable){$aPosVertsInt[size($aPosVertsInt)] = $i;}\n\t\t\t$aPosVertTrans[size($aPosVertTrans)] = $aVtxTrans[$mAxisInd];\n\t\t}else{\n\t\t\tif ($midOffset < $midOffsetTol){\n\t\t\t\t$aNegVerts[size($aNegVerts)] = $vtx;\n\t\t\t\tif ($bTable){$aNegVertsInt[size($aNegVertsInt)] = $i;}\n\t\t\t\t$aNegVertTrans[size($aNegVertTrans)] = $aVtxTrans[$mAxisInd];\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif ($bTable){$str = \"Building Symmetry Table\";}else{$str = \"Checking For Symmetry\";}\n\tprogressWindow -e -progress 0 -status $str;\n\t$progDenom = size($aPosVerts);\n\t$flt = ceil($progDenom/50);\n\t$mod = $flt;\n\t\n\t//now find nonsymverts\n\tfor ($i=0;$i<size($aPosVerts);$i++){\n\t\t\n\t\t//prog win\n\t\tif (($i % $mod) == 0){ //make the progress bar a bit less resource intensive\n\t\t\t$progNum = $i;\n\t\t\t$prog = ($progNum/$progDenom)*100.0;\n\t\t\tprogressWindow -e -progress $prog;\n\t\t}\n\t\t//end prog win\n\t\t\n\t\t$vtx = $aPosVerts[$i];\n\t\t$posOffset = ($aPosVertTrans[$i] - $mid);\n\t\tif ($posOffset < $tol){\n\t\t\t$aPosVerts[$i] = \"m\";\n\t\t\t$vertCounter ++;\n\t\t\tcontinue;\n\t\t}\n\t\tfor ($j=0;$j<size($aNegVerts);$j++){\n\t\t\tif ($aNegVerts[$j] == \"m\") continue;\n\t\t\t$negOffset = $mid - $aNegVertTrans[$j];\n\t\t\tif ($negOffset < $tol){\n\t\t\t\t$aNegVerts[$j] = \"m\";\n\t\t\t\t$vertCounter ++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (abs($posOffset - $negOffset) <= $tol){\n\t\t\t\t$aVtxTrans = `xform -q -ws -t $vtx`;\n\t\t\t\t$aVtx2Trans = `xform -q -ws -t $aNegVerts[$j]`;\n\t\t\t\t$test1 = $aVtxTrans[$axis2Ind] - $aVtx2Trans[$axis2Ind];\n\t\t\t\t$test2 = $aVtxTrans[$axis3Ind] - $aVtx2Trans[$axis3Ind];\n\t\t\t\tif (abs($test1) < $tol && abs($test2) < $tol){\n\t\t\t\t\t//match\n\t\t\t\t\tif ($bTable){\n\t\t\t\t\t\t//use this info to build symmetry table\n\t\t\t\t\t\t$abSymTable[size($abSymTable)] = $aPosVertsInt[$i];\n\t\t\t\t\t\t$abSymTable[size($abSymTable)] = $aNegVertsInt[$j];\n\t\t\t\t\t\t$vertCounter += 2;\n\t\t\t\t\t}\n\t\t\t\t\t$aPosVerts[$i] = $aNegVerts[$j] = \"m\"; //m is for match\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//now strip out \"m\" from $aPosVerts and $aNegVerts, and we'll have asymmetry\n\t$aStr = {\"m\"};\n\t$aPosVerts = stringArrayRemove($aStr, $aPosVerts);\n\t$aNegVerts = stringArrayRemove($aStr, $aNegVerts);\n\t$aNonSymVerts = stringArrayCatenate($aPosVerts, $aNegVerts);\n\t\n\tif ($bTable){\n\t\t$int = size($abSymTable) + $vertCounter;\n\t\tif ($vertCounter != $totVtx){\n\t\t\t//object is not symmetrical\n\t\t\twarning \"Base geometry is not symmetrical, not all vertices can be mirrored\";\n\t\t}else{\n\t\t\tprint \"Base geometry is symmetrical\";\n\t\t}\n\t}\n\tprogressWindow -endProgress;\n\twaitCursor -state off;\n\treturn $aNonSymVerts;\n}\n\n\nglobal proc int abGetSymVtx(int $vtxInt){\n\t//uses abSymTable, returns symmetrical vtx or -1 if failed\n\tglobal int $abSymTable[];\n\tint $mVtxInt = -1;\n\tint $i;\n\t\n\tfor ($i=0;$i<size($abSymTable);$i++){\n\t\tif ($vtxInt == $abSymTable[$i]){\n\t\t\t//match\n\t\t\tif (($i % 2) == 0){\n\t\t\t\t//even number, match is record above (it's a positive vert)\n\t\t\t\t$mVtxInt = $abSymTable[$i+1];\n\t\t\t}else{\n\t\t\t\t$mVtxInt = $abSymTable[$i-1];\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn $mVtxInt;\n}\n\n\nglobal proc abMirrorSel(string $obj, string $baseObj, string $aSelVerts[], int $axis, int $negToPos, int $flip, int $usePiv, float $tol){\n\t//$axis is 1, 2, 3 -- $negToPos is bool -- true mirrors negative (axis) to positive (axis)\n\t//$flip is bool -- if true, selVerts are flipped instead of mirrored\n\t//$usePiv is bool to use pivot on $obj as origin\n\tglobal int $abSymTable[];\n\tglobal int $abSymProgBarThresh;\n\t\n\tstring $aStr[];\n\tstring $str;\n\tstring $vtx;\n\tstring $obj;\n\tint $aPosVertsInt[];\n\tint $aNegVertsInt[];\n\tint $aZeroVertsInt[];\n\tint $mAxisInd = $axis - 1; //mirror axis index (for xform)\n\tint $axis2Ind = ($mAxisInd + 1) % 3;\n\tint $axis3Ind = ($mAxisInd + 2) % 3;\n\tint $vertNum;\n\tint $i;\n\tint $j;\n\tint $prog;\n\tint $mod;\n\tint $showProg = false;  //don't show the progress bar\n\tfloat $bBox[];\n\tfloat $baseMid;\n\tfloat $baseMidOffset;\n\tfloat $aVtxTrans[];\n\tfloat $aFlpVtxTrans[];\n\tfloat $mid; //mirror axis midpoint\n\tfloat $progNum;\n\tfloat $progDenom;\n\tfloat $flt;\n\t\n\tif ($usePiv){\n\t\t$aVtxTrans = `xform -q -ws -t $obj`;\n\t\t$mid = $aVtxTrans[$mAxisInd];\n\t\t$aVtxTrans = `xform -q -ws -t $baseObj`;\n\t\t$baseMid = $aVtxTrans[$mAxisInd];\n\t}else{\n\t\t$mid = 0;\n\t\t$bBox = `xform -q -ws -boundingBox $baseObj`;\n\t\t$baseMid = $bBox[$mAxisInd] + (($bBox[($mAxisInd+3)] - $bBox[$mAxisInd])/2);\n\t}\n\t\n\twaitCursor -state on;\n\tif (size($aSelVerts) > $abSymProgBarThresh){ //show prog if more than this many verts being mirrored\n\t\t$showProg = true;\n\t\t$str = \"Mirroring Vertices\";\n\t\tif ($flip){$str = \"Flipping Vertices\";}\n\t\tprogressWindow -title \"Working\" -progress 0 -status $str;\n\t\t$progDenom = size($aSelVerts);\n\t\t$flt = ceil($progDenom/50);\n\t\t$mod = $flt;\n\t}\n\t\t\n\t//strip out Pos verts if $negToPos is true (and vice versa)\n\t//aposverts (and anegverts) are int arrays in this proc to simplify matching\n\t//get pos neg info from base mesh\n\tfor ($i=0;$i<size($aSelVerts);$i++){\n\t\t\n\t\t//prog win\n\t\tif ($showProg){\n\t\t\tif (($i % $mod) == 0){ //make the progress bar a bit less resource intensive\n\t\t\t\t$progNum = $i;\n\t\t\t\t$prog = ($progNum/$progDenom)*50.0;\n\t\t\t\tprogressWindow -e -progress $prog;\n\t\t\t}\n\t\t}\n\t\t//end prog win\n\t\t\n\t\t$vtx = $aSelVerts[$i];\n\t\t//$aVtxTrans = `xform -q -ws -translation $vtx`;\n\t\t$vertNum = match(\"([0-9])+\", (match (\"([0-9])+\\\\]\", $vtx)));\n\t\t$aVtxTrans = `xform -q -ws -translation ($baseObj+\".vtx[\"+$vertNum+\"]\")`;\n\t\t$baseMidOffset = $aVtxTrans[$mAxisInd] - $baseMid;\n\t\tif (abs($baseMidOffset) < $tol){\n\t\t\t$aZeroVertsInt[size($aZeroVertsInt)] = $vertNum;\n\t\t\tcontinue;\n\t\t}\n\t\tif ($baseMidOffset > 0){\n\t\t\t$aPosVertsInt[size($aPosVertsInt)] = $vertNum;\n\t\t\tcontinue;\n\t\t}\n\t\tif ($baseMidOffset < 0){\n\t\t\t$aNegVertsInt[size($aNegVertsInt)] = $vertNum;\n\t\t\tcontinue;\n\t\t}\n\t}\n\t\n\tif ($negToPos){\n\t\t$aPosVertsInt = $aNegVertsInt;\n\t}\n\t\n\tif ($showProg){\n\t\t$progDenom = size($aPosVertsInt);\n\t\t$flt = ceil($progDenom/50);\n\t\t$mod = $flt;\n\t}\n\t\n\tfor ($i=0;$i<size($aPosVertsInt);$i++){\n\t\t\n\t\t//prog win\n\t\tif ($showProg){\n\t\t\tif (($i % $mod) == 0){ //make the progress bar a bit less resource intensive\n\t\t\t\t$progNum = $i;\n\t\t\t\t$prog = ($progNum/$progDenom)*50.0 + 50;\n\t\t\t\tprogressWindow -e -progress $prog;\n\t\t\t}\n\t\t}\n\t\t//end prog win\n\t\t\n\t\t$vertNum = abGetSymVtx($aPosVertsInt[$i]);\n\t\tif ($vertNum != -1){\n\t\t\tif (!$flip){ //mirror selected\n\t\t\t\t$aVtxTrans = `xform -q -ws -t ($obj+\".vtx[\"+$aPosVertsInt[$i]+\"]\")`;\n\t\t\t\t$aVtxTrans[$mAxisInd] = 2*$mid - $aVtxTrans[$mAxisInd];\n\t\t\t\txform -ws -t $aVtxTrans[0] $aVtxTrans[1] $aVtxTrans[2] ($obj+\".vtx[\"+$vertNum+\"]\");\n\t\t\t}else{ //flip selected\n\t\t\t\t$aVtxTrans = `xform -q -ws -t ($obj+\".vtx[\"+$aPosVertsInt[$i]+\"]\")`;\n\t\t\t\t$aVtxTrans[$mAxisInd] = 2*$mid - $aVtxTrans[$mAxisInd];\n\t\t\t\t$aFlpVtxTrans = `xform -q -ws -t ($obj+\".vtx[\"+$vertNum+\"]\")`;\n\t\t\t\t$aFlpVtxTrans[$mAxisInd] = 2*$mid - $aFlpVtxTrans[$mAxisInd];\n\t\t\t\txform -ws -t $aVtxTrans[0] $aVtxTrans[1] $aVtxTrans[2] ($obj+\".vtx[\"+$vertNum+\"]\");\n\t\t\t\txform -ws -t $aFlpVtxTrans[0] $aFlpVtxTrans[1] $aFlpVtxTrans[2] ($obj+\".vtx[\"+$aPosVertsInt[$i]+\"]\");\n\t\t\t}\n\t\t}\n\t}\n\tfor ($i=0;$i<size($aZeroVertsInt);$i++){ //flip middle verts too\n\t\tif ($flip){\n\t\t\t$aVtxTrans = `xform -q -ws -t ($obj+\".vtx[\"+$aZeroVertsInt[$i]+\"]\")`;\n\t\t\t$aVtxTrans[$mAxisInd] = 2*$mid - $aVtxTrans[$mAxisInd];\n\t\t\txform -ws -t $aVtxTrans[0] $aVtxTrans[1] $aVtxTrans[2] ($obj+\".vtx[\"+$aZeroVertsInt[$i]+\"]\");\n\t\t}else{\n\t\t\t$aVtxTrans = `xform -q -ws -t ($obj+\".vtx[\"+$aZeroVertsInt[$i]+\"]\")`;\n\t\t\t$aVtxTrans[$mAxisInd] = $mid;\n\t\t\txform -ws -t $aVtxTrans[0] $aVtxTrans[1] $aVtxTrans[2] ($obj+\".vtx[\"+$aZeroVertsInt[$i]+\"]\");\n\t\t}\n\t}\n\tif ($showProg){progressWindow -endProgress;}\n\twaitCursor -state off;\n}\n\n\nglobal proc abRevertSel(string $aSelVerts[], string $obj, string $baseObj, float $bias){\n\t//reverts selected verts to base -os trans -- $bias is the percentage (0-1) to revert from current verts position to the base verts position, 100 taking on the base object's vert positions (original default behaviour) \n\tglobal int $abSymProgBarThresh;\n\t\t\n\tstring $str;\n\tstring $vtx;\n\tint $vertNum;\n\tint $i;\n\tint $prog;\n\tint $mod;\n\tint $showProg = false;  //don't show the progress bar\n\tfloat $aTrans[];\n\tfloat $progNum;\n\tfloat $progDenom;\n\tfloat $flt;\n\tfloat $tol = 0;\n\tvector $vTol = <<$tol, $tol, $tol>>;\n\tvector $vBaseTrans;\n\tvector $vObjTrans;\n\t\n\tif ($bias > 1){\n\t\t$bias = 1;\n\t}else if ($bias < 0){\n\t\t$bias = 0;\n\t}\n\t$bias = 1 - $bias;\n\tif ($bias < .01) $bias = 0;\n\t\n\tif (size($aSelVerts) > $abSymProgBarThresh){ //show prog if more than this many verts being mirrored\n\t\t$showProg = true;\n\t\tprogressWindow -title \"Working\" -progress 0 -status \"Reverting Vertices\";\n\t\t$progDenom = size($aSelVerts);\n\t\t$flt = ceil($progDenom/50);\n\t\t$mod = $flt;\n\t}\n\t\n\twaitCursor -state on;\n\tfor ($i=0;$i<size($aSelVerts);$i++){\n\t\t//prog win\n\t\tif ($showProg){\n\t\t\tif (($i % $mod) == 0){ //make the progress bar a bit less resource intensive\n\t\t\t\t$progNum = $i;\n\t\t\t\t$prog = ($progNum/$progDenom)*100;\n\t\t\t\tprogressWindow -e -progress $prog;\n\t\t\t}\n\t\t}\n\t\t//end prog win\n\t\t$vtx = $aSelVerts[$i];\n\t\t$vertNum = match(\"([0-9])+\", (match (\"([0-9])+\\\\]\", $vtx)));\n\t\t$aTrans = `xform -q -os -t ($baseObj+\".vtx[\"+$vertNum+\"]\")`;\n\t\t$vBaseTrans = <<$aTrans[0], $aTrans[1], $aTrans[2]>>;\n\t\t\n\t\t//bias stuff\n\t\t$aTrans = `xform -q -os -t $vtx`;\n\t\t$vObjTrans = <<$aTrans[0], $aTrans[1], $aTrans[2]>>;\n\t\t\n\t\tif (abs($vObjTrans - $vBaseTrans) > $vTol) xform -os -t ($vBaseTrans.x+($vObjTrans.x-$vBaseTrans.x)*$bias) ($vBaseTrans.y+($vObjTrans.y-$vBaseTrans.y)*$bias) ($vBaseTrans.z+($vObjTrans.z-$vBaseTrans.z)*$bias) $vtx;\n\t\t//done\n\t}\n\t\n\tif ($showProg){progressWindow -endProgress;}\t\n\twaitCursor -state off;\n}\n\n\nglobal proc abSymInteractiveRevertToBase(){\n\t//responds to revert to base slider movement\n\t\n\tglobal string $abSymRevVertTable[];\n\tglobal vector $abSymRevPosTable[];\n\tglobal vector $abSymRevBasePosTable[];\n\tglobal int $abSymSliderDragging;\n\tglobal string $abAltSbg;\n\tglobal string $abSbg;\n\t\n\tint $i;\n\tint $firstClick = false;\n\t\n\tif ($abSymSliderDragging == false){\n\t\t$abSymSliderDragging = true;\n\t\t\n\t\t//check to see if selection is the same -- if it is, use the existing $abSymRevPosTable\n\t\t\n\t\tstring $aStr[], $selObj, $aSelVerts[], $aBaseVerts[];\n\t\tint $buildNewTables = true;\n\t\t\n\t\t$aStr = `filterExpand -sm 12`;\n\t\tif (size($aStr) == 1){\n\t\t\t$selObj = $aStr[0];\n\t\t}else{\n\t\t\t$aStr = `ls -hilite`;\n\t\t\tif (size($aStr) == 1){\n\t\t\t\t$selObj = $aStr[0];\n\t\t\t}\n\t\t}\n\t\t\n\t\t$aSelVerts = `filterExpand -sm 31`;\n\t\t\n\t\tif ($selObj != \"\" && size($aSelVerts) > 0){\n\t\t\t\n\t\t\tif (size($aSelVerts) == size($abSymRevVertTable) && size($abSymRevVertTable) == size($abSymRevBasePosTable)){\t\t\t\t\n\t\t\t\t$buildNewTables = false;\n\t\t\t\tfor ($i=0;$i<size($aSelVerts);$i++){\n\t\t\t\t\tif ($aSelVerts[$i] != $abSymRevVertTable[$i]){\n\t\t\t\t\t\t$buildNewTables = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif ($buildNewTables){\n\t\t\t\t\n\t\t\t\tabSymClearRevTables();\n\t\t\t\t\n\t\t\t\tfloat $tol = .001;\n\t\t\t\tfloat $aFlt[];\n\t\t\t\tstring $aBaseVerts[];\n\t\t\t\tvector $vector1, $vector2;\n\t\t\t\t\n\t\t\t\tstring $baseObj = ($abAltSbg != \"\") ? $abAltSbg : $abSbg;\n\t\t\t\t\n\t\t\t\t//make base verts array\n\t\t\t\tfor ($i=0;$i<size($aSelVerts);$i++){\n\t\t\t\t\t$aBaseVerts[size($aBaseVerts)] = $baseObj+(`match \"\\\\.vtx\\\\[([0-9])+]$\" $aSelVerts[$i]`);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor ($i=0;$i<size($aSelVerts);$i++){\n\t\t\t\t\t\n\t\t\t\t\t$aFlt = `xform -q -os -translation $aSelVerts[$i]`;\n\t\t\t\t\t$vector1 = <<$aFlt[0], $aFlt[1], $aFlt[2]>>;\n\t\t\t\t\t$aFlt = `xform -q -os -translation $aBaseVerts[$i]`;\n\t\t\t\t\t$vector2 = <<$aFlt[0], $aFlt[1], $aFlt[2]>>;\n\t\t\t\t\t\n\t\t\t\t\tif ((abs($vector1 - $vector2)) > <<$tol, $tol, $tol>>){\n\t\t\t\t\t\t\n\t\t\t\t\t\t$abSymRevVertTable[size($abSymRevVertTable)] = $aSelVerts[$i];\n\t\t\t\t\t\t$abSymRevPosTable[size($abSymRevPosTable)] = $vector1;\n\t\t\t\t\t\t$abSymRevBasePosTable[size($abSymRevBasePosTable)] = $vector2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tabSymClearRevTables();\n\t\t\twarning \"Select vertices on one polygon object.\";\n\t\t}\n\t\t$firstClick = true;\n\t}\n\t\n\tfloat $bias = `floatSlider -q -v rvrtFltSldr`;\n\tfloat $aObjTrans[], $aBaseTrans[];\n\tvector $vObjTrans, $vBaseTrans;\n\t\n\tif (size($abSymRevVertTable) == size($abSymRevPosTable) && size($abSymRevPosTable) == size($abSymRevBasePosTable)){\n\t\tfor ($i=0;$i<size($abSymRevVertTable);$i++){\n\t\t\t\n\t\t\t$vObjTrans = $abSymRevPosTable[$i];\n\t\t\t$vBaseTrans = $abSymRevBasePosTable[$i];\n\t\t\txform -os -t ($vBaseTrans.x+($vObjTrans.x-$vBaseTrans.x)*$bias) ($vBaseTrans.y+($vObjTrans.y-$vBaseTrans.y)*$bias) ($vBaseTrans.z+($vObjTrans.z-$vBaseTrans.z)*$bias) $abSymRevVertTable[$i];\n\t\t}\n\t}\n\t\n\tif ($firstClick) undoInfo -swf off;\n}\n\n\nglobal proc abSymEndDrag(){\n\t//called when dragging is done\n\t\n\tglobal int $abSymSliderDragging;\n\t\n\t$abSymSliderDragging = false;\n\tundoInfo -swf on;\n}\n\n\nglobal proc abSymClearRevTables(){\n\t//clears out globals associated with dragging reversion slider\n\t\n\tglobal string $abSymRevVertTable[];\n\tglobal vector $abSymRevPosTable[];\n\tglobal vector $abSymRevBasePosTable[];\n\t\n\tclear $abSymRevVertTable;\n\tclear $abSymRevPosTable;\n\tclear $abSymRevBasePosTable;\n}\n\n\nglobal proc abSymUseAlternateBase(int $useAltBase){\n\t//substitute alternate variation of this mesh as the base shape for revert commands -- $useAltBase is a boolean which determines whether to use the alternate base or to revert to original base object\n\t\n\tglobal string $abAltSbg;\n\tglobal string $abSbg;\n\t\n\tstring $aStr[];\n\tint $aInt[], $totNewVtx, $totOrigVtx;\n\t\n\t\n\tif ($useAltBase){\n\t\t$aStr = `filterExpand -sm 12`;\n\t\tif (size($aStr) == 1){\n\t\t\t\n\t\t\t$aInt = `polyEvaluate -v $abSbg`; \n\t\t\t$totOrigVtx = $aInt[0];\n\t\t\t$aInt = `polyEvaluate -v  $aStr[0]`; \n\t\t\t$totNewVtx = $aInt[0];\n\t\t\tif ($totOrigVtx = $totNewVtx){\n\t\t\t\t//number of verts match up, so accept this mesh as a usable base\n\t\t\t\t\n\t\t\t\t$abAltSbg = $aStr[0];\n\t\t\t\tabSymClearRevTables();\n\t\t\t\tmenuItem -e -label (\"Using \"+$abAltSbg+\" as Base\") abSymCurBsMnIt;\n\t\t\t\tmenuItem -e -enable true abSymSlOrigRvtBsMnIt;\n\t\t\t\tmenuItem -e -enable true abSymSlAltMvVtsMnIt;\n\t\t\t\t\n\t\t\t}else{\n\t\t\t\twarning \"The new base mesh must have the same number of vertices as the current base mesh.\";\n\t\t\t}\n\t\t}else{\n\t\t\twarning \"Select a mesh to use as a base object.\";\n\t\t}\n\t}else{\n\t\t$abAltSbg = \"\";\n\t\tabSymClearRevTables();\n\t\tmenuItem -e -label \"Using Original Base\" abSymCurBsMnIt;\n\t\tmenuItem -e -enable false abSymSlOrigRvtBsMnIt;\n\t\tmenuItem -e -enable false abSymSlAltMvVtsMnIt;\n\t\t\n\t}\n}\n\n\nglobal proc string[] abSelMovedVerts(string $obj, string $baseObj, float $tol){\n\t//select repositioned verts (as compared to the base mesh)\n\tint $aInt[];\n\tint $totVtx;\n\tint $i;\n\tint $j;\n\tfloat $tFlt;\n\tfloat $aVtxTrans[];\n\tstring $objStr = $obj+\".vtx[\";\n\tstring $baseObjStr = $baseObj+\".vtx[\";\n\tstring $aRetSel[];\n\tstring $vtx;\n\t\n\tvector $vTrans1, $vTrans2;\n\tvector $vTol = <<$tol, $tol, $tol>>;\n\t\n\t$aInt = `polyEvaluate -v $obj`; \n\t$totVtx = $aInt[0];\n\t\n\tint $mod, $prog;\n\tfloat $flt, $progNum, $progDenom;\n\tfloat $progUpdate = 50.0;\n\twaitCursor -state on;\n\tprogressWindow -title \"Working\" -progress 0 -status \"Checking Verts\";\n\t$progDenom = $totVtx;\n\t$flt = ceil($progDenom/$progUpdate);\n\t$mod = $flt;\n\t\n\tfor ($i=0;$i<$totVtx;$i++){\n\t\t\n\t\t//prog win\n\t\tif (($i % $mod) == 0){ //make the progress bar a bit less resource intensive\n\t\t\t$progNum = $i;\n\t\t\t$prog = ($progNum/$progDenom)*100.0;\n\t\t\tprogressWindow -e -progress $prog;\n\t\t}\n\t\t//end prog win\n\t\t\n\t\t$vtx = $objStr+$i+\"]\";\n\t\t$aVtxTrans = `xform -q -os -t ($baseObjStr+$i+\"]\")`;\n\t\t$vTrans1 = <<$aVtxTrans[0], $aVtxTrans[1], $aVtxTrans[2]>>;\n\t\t\n\t\t$aVtxTrans = `xform -q -os -t $vtx`;\n\t\t$vTrans2 = <<$aVtxTrans[0], $aVtxTrans[1], $aVtxTrans[2]>>;\n\t\t\n\t\tif (abs($vTrans1 - $vTrans2) > $vTol) $aRetSel[size($aRetSel)] = $vtx;\n\t}\n\t\n\tprogressWindow -endProgress;\n\twaitCursor -state off;\n\t\n\treturn $aRetSel;\n}\n\n\nglobal proc abSMServiceAddSubtractCopy(int $operation){\n\t// called by add, subtract and copy buttons in the menu -- if selection and basemesh are in order it calls abSMAddSubtractCopyMesh\n\t// operation is passed to abSMAddSubtractCopyMesh\n\t\n\tglobal string $abSbg;\n\t\n\tif ($abSbg == \"\"){\n\t\twarning \"You must select a base mesh first.\";\n\t\treturn;\n\t}\n\t\n\tstring $aSel[] = `ls -sl`;\n\t\n\tif (size($aSel) != 2){\n\t\twarning \"Select two mesh objects (source and target).\";\n\t\treturn;\n\t}\n\t\n\tstring $mesh, $aRel[];\n\t\n\tint $aInt[] = `polyEvaluate -v $abSbg`; \n\tint $baseVertNum = $aInt[0];\n\t\n\t// make sure that both objects are meshes with the correct number of verts (same as base mesh) and neither is the basemesh\n\tfor ($mesh in $aSel){\n\t\t// make sure neither mesh is the base mesh\n\t\tif ($mesh == $abSbg){\n\t\t\twarning \"The basemesh cannot be used as a source or target.  Try using revert instead.\";\n\t\t\treturn;\n\t\t}\n\t\t$aRel = `listRelatives -type mesh`;\n\t\tif (size($aRel) == 0){\n\t\t\twarning ($mesh+\" is not a mesh.  Unable to proceed.\");\n\t\t\treturn;\n\t\t}else{\n\t\t\t$aInt = `polyEvaluate -v $mesh`;\n\t\t\tif ($aInt[0] != $baseVertNum){\n\t\t\t\twarning ($mesh+\" topology doesn't match the base object.  Unable to proceed.\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// ok, it's good to go\n\tabSMAddSubtractCopyMesh($abSbg, $aSel[0], $aSel[1], $operation);\n\t\n}\n\n/* \nglobal proc abSMAddSubtractCopyMesh(string $baseMesh, string $source, string $target, int $operation){\n\t// adds or subtracts one blend ($source) from another ($target) based on operation (0 == subtract, 1 == add, 2 == copy)\n\t\n\tint $aInt[], $totVtx, $i;\n\tfloat $aBaseVtxTrans[], $aSourceVtxTrans[], $aTargetVtxTrans[], $aSourceBaseOffset[];\n\tstring $baseMeshStr = $baseMesh+\".vtx[\";\n\tstring $sourceMeshStr = $source+\".vtx[\";\n\tstring $targetMeshStr = $target+\".vtx[\";\n\t\n\t\n\t$aInt = `polyEvaluate -v $baseMesh`; \n\t$totVtx = $aInt[0];\n\t\t\n\t// get offset of source verts from baseMesh\n\tfor ($i=0;$i<$totVtx;$i++){\n\t\t\n\t\t$aBaseVtxTrans = `xform -q -os -t ($baseMeshStr+$i+\"]\")`;\n\t\t$aSourceVtxTrans = `xform -q -os -t ($sourceMeshStr+$i+\"]\")`;\n\t\t$aTargetVtxTrans = `xform -q -os -t ($targetMeshStr+$i+\"]\")`;\n\t\t$aSourceBaseOffset = {$aSourceVtxTrans[0]-$aBaseVtxTrans[0], $aSourceVtxTrans[1]-$aBaseVtxTrans[1], $aSourceVtxTrans[2]-$aBaseVtxTrans[2]};\n\t\t\n\t\tif ($operation == 0){\n\t\t\t// subtract\n\t\t\t$aTargetVtxTrans = {$aTargetVtxTrans[0]-$aSourceBaseOffset[0], $aTargetVtxTrans[1]-$aSourceBaseOffset[1], $aTargetVtxTrans[2]-$aSourceBaseOffset[2]};\n\t\t}else if ($operation  == 1){\n\t\t\t// add\n\t\t\t$aTargetVtxTrans = {$aTargetVtxTrans[0]+$aSourceBaseOffset[0], $aTargetVtxTrans[1]+$aSourceBaseOffset[1], $aTargetVtxTrans[2]+$aSourceBaseOffset[2]};\n\t\t}else if ($operation == 2){\n\t\t\t// copy\n\t\t\t$aTargetVtxTrans = $aSourceVtxTrans;\n\t\t}\n\t\t\n\t\txform -os -t $aTargetVtxTrans[0] $aTargetVtxTrans[1] $aTargetVtxTrans[2] ($targetMeshStr+$i+\"]\");\n\t}\n\t\n}\n*/\n\n\nglobal proc abSMAddSubtractCopyMesh(string $baseMesh, string $source, string $target, int $type){\n\t// adds or subtracts one blend ($source) from another ($target) based on type (0 == subtract, 1 == add, 2 == copy)\n\t// 3, 4, and 5 are mirror versions of 0, 1, and 2\n\t// 6, and 7 are like 0 and 1 but use offset from the target instead of the base (7 is same as 2)\n\t// 9 and 10 are mirror versions of 6 and 7\n\t\n\tglobal int $abSymTable[];\n\t\n\tint $aInt[], $totVtx, $i, $srcVtx, $trgVtx, $vtx, $aMSymTable[], $mirror, $operation, $offsetTableInd;\n\tint $axisSel = (`radioButtonGrp -q -select saRbGrp`) - 1; // 0 == x, 1 == y, 2 == z\n\tint $aSelAxis[] = {1, 1, 1};\n\t\n\tfloat $aBaseVtxTrans[], $aSourceVtxTrans[], $aTargetVtxTrans[], $aSourceBaseOffset[], $aOffsetTable[];\n\tstring $mSource, $aStr[], $aSelVerts[], $baseMeshStr, $sourceMeshStr, $targetMeshStr, $baseMeshStr, $sourceMeshStr, $targetMeshStr;\n\t\n\tif ($type == 7) $operation = 2;\n\t\telse $operation = $type % 3;\n\t\t\n\t$mirror = ($type == 3 || $type == 4 || $type == 5 || $type == 9 || $type == 10);\n\t\n\t// use target for base for types 6 - 10\n\tif ($type >= 6) $baseMesh = $target;\n\t\n\t$baseMeshStr = $baseMesh+\".vtx[\";\n\t$sourceMeshStr = $source+\".vtx[\";\n\t$targetMeshStr = $target+\".vtx[\";\n\t\n\t$totVtx = size($abSymTable);\n\tstring $aTest[];\n\tfor ($i=0;$i<$totVtx;$i++){\n\t\t\n\t\t$vtx = $abSymTable[$i];\n\t\t\n\t\t// if mirroring, get mirror vtx\n\t\tif ($mirror) $aMSymTable[$i] = ($i%2 == 0) ? $abSymTable[$i+1] : $abSymTable[$i-1];\n\t\t\n\t\t$aBaseVtxTrans = `xform -q -os -t ($baseMeshStr+$vtx+\"]\")`;\n\t\t$aSourceVtxTrans = `xform -q -os -t ($sourceMeshStr+$vtx+\"]\")`;\n\t\t$aTargetVtxTrans = `xform -q -os -t ($targetMeshStr+$vtx+\"]\")`;\n\t\t$aSourceBaseOffset = {$aSourceVtxTrans[0]-$aBaseVtxTrans[0], $aSourceVtxTrans[1]-$aBaseVtxTrans[1], $aSourceVtxTrans[2]-$aBaseVtxTrans[2]};\n\t\t\n\t\tif ($mirror){\n\t\t\t\n\t\t\t$aOffsetTable[size($aOffsetTable)] = $aSourceBaseOffset[0];\n\t\t\t$aOffsetTable[size($aOffsetTable)] = $aSourceBaseOffset[1];\n\t\t\t$aOffsetTable[size($aOffsetTable)] = $aSourceBaseOffset[2];\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif ($operation == 0){\n\t\t\t// subtract\n\t\t\t$aTargetVtxTrans = {$aTargetVtxTrans[0]-$aSourceBaseOffset[0], $aTargetVtxTrans[1]-$aSourceBaseOffset[1], $aTargetVtxTrans[2]-$aSourceBaseOffset[2]};\n\t\t\t\n\t\t}else if ($operation  == 1){\n\t\t\t// add\n\t\t\t$aTargetVtxTrans = {$aTargetVtxTrans[0]+$aSourceBaseOffset[0], $aTargetVtxTrans[1]+$aSourceBaseOffset[1], $aTargetVtxTrans[2]+$aSourceBaseOffset[2]};\n\t\t\t\n\t\t}else if ($operation == 2){\n\t\t\t// copy\n\t\t\t$aTargetVtxTrans = $aSourceVtxTrans;\n\t\t}\n\t\t\n\t\txform -os -t $aTargetVtxTrans[0] $aTargetVtxTrans[1] $aTargetVtxTrans[2] ($targetMeshStr+$vtx+\"]\");\n\t}\n\t\n\tif ($mirror){\n\t\t\n\t\tif ($axisSel == 0) $aSelAxis[1] = -1;\n\t\t\n\t\t// if mirroring, now we can apply the transforms to their matching verts\n\t\tfor ($i=0;$i<$totVtx;$i++){\n\t\t\t\n\t\t\t$offsetTableInd = $i*3;\n\t\t\t$vtx = $aMSymTable[$i];\n\t\t\t\n\t\t\t$aTargetVtxTrans = `xform -q -os -t ($targetMeshStr+$vtx+\"]\")`;\n\t\t\t$aSourceBaseOffset[0] = $aOffsetTable[$offsetTableInd]*$aSelAxis[0];\n\t\t\t$aSourceBaseOffset[1] = $aOffsetTable[$offsetTableInd+1]*$aSelAxis[1];\n\t\t\t$aSourceBaseOffset[2] = $aOffsetTable[$offsetTableInd+2]*$aSelAxis[2];\n\t\t\t\n\t\t\tif ($operation == 1){\n\t\t\t\t// add\n\t\t\t\t$aTargetVtxTrans = {$aTargetVtxTrans[0]-$aSourceBaseOffset[0], $aTargetVtxTrans[1]-$aSourceBaseOffset[1], $aTargetVtxTrans[2]-$aSourceBaseOffset[2]};\n\t\t\t\t\n\t\t\t}else if ($operation  == 0){\n\t\t\t\t// subtract\n\t\t\t\t$aTargetVtxTrans = {$aTargetVtxTrans[0]+$aSourceBaseOffset[0], $aTargetVtxTrans[1]+$aSourceBaseOffset[1], $aTargetVtxTrans[2]+$aSourceBaseOffset[2]};\n\t\t\t\t\n\t\t\t}else if ($operation == 2){\n\t\t\t\t// copy\n\t\t\t\t$aTargetVtxTrans = $aSourceVtxTrans;\n\t\t\t}\n\t\t\t\n\t\t\txform -os -t $aTargetVtxTrans[0] $aTargetVtxTrans[1] $aTargetVtxTrans[2] ($targetMeshStr+$vtx+\"]\");\n\t\t\t\n\t\t}\n\t}\n\t\n}\n\n\nglobal proc string[] abSelSideVerts(string $obj, string $baseObj, int $mAxisInd, int $selNeg, int $usePiv, float $tol){\n\t//selects a side of the object (located on origin) for faster mirroring (instead of having to find symmetrical verts)\n\t//$selNeg true -- select Negative side of mesh, false -- select Pos side, 2 -- select all verts\n\tint $aInt[];\n\tint $totVtx;\n\tint $i;\n\tstring $aRetSel[]; //return string of selected verts\n\tstring $vtxStr;\n\tfloat $aVtxTrans[];\n\tfloat $bBox[];\n\tfloat $baseMid;\n\tfloat $baseMidOffset;\n\t\n\t$mAxisInd -= 1; //from (1 to 3) to (0 to 2)\n\t\n\t$aInt = `polyEvaluate -v $obj`; \n\t$totVtx = $aInt[0];\n\t\n\tif ($selNeg == 2){ //return all verts\n\t\tfor ($i=0;$i<$totVtx;$i++){\n\t\t\t$vtx = $obj+\".vtx[\"+$i+\"]\";\n\t\t\t$aRetSel[size($aRetSel)] = $vtx;\n\t\t}\n\t\treturn $aRetSel;\n\t}\n\t\n\tif ($usePiv){\n\t\t$aVtxTrans = `xform -q -ws -t $baseObj`;\n\t\t$baseMid = $aVtxTrans[$mAxisInd];\n\t}else{\n\t\t$bBox = `xform -q -ws -boundingBox $baseObj`;\n\t\t$baseMid = $bBox[$mAxisInd] + (($bBox[($mAxisInd+3)] - $bBox[$mAxisInd])/2);\n\t}\n\n\tfor ($i=0;$i<$totVtx;$i++){\n\t\t$vtxStr = \".vtx[\"+$i+\"]\";\n\t\t$aVtxTrans = `xform -q -ws -translation ($baseObj+$vtxStr)`;\n\t\t$baseMidOffset = $aVtxTrans[$mAxisInd] - $baseMid;\n\t\tif (abs($baseMidOffset) < $tol){\n\t\t\t$aRetSel[size($aRetSel)] = $obj+$vtxStr;\n\t\t\tcontinue;\n\t\t}\n\t\tif ($baseMidOffset > 0 && !$selNeg){\n\t\t\t$aRetSel[size($aRetSel)] = $obj+$vtxStr;\n\t\t\tcontinue;\n\t\t}\n\t\tif ($baseMidOffset < 0 && $selNeg){\n\t\t\t$aRetSel[size($aRetSel)] = $obj+$vtxStr;\n\t\t\tcontinue;\n\t\t}\n\t}\n\treturn $aRetSel;\n}\n\n\nglobal proc string[] abSelMirror(string $obj, string $aSelVerts[]){\n\t//mirror selection (not selected)\n\tglobal int $abSymTable[];\n\tstring $aRetVerts[];\n\tstring $vtxStr;\n\tint $i;\n\tint $vertNum;\n\tint $mVertNum;\n\t\n\tif (size($abSymTable) == 0){\n\t\twarning \"No Base Geometry Selected\";\n\t\treturn $aSelVerts;\n\t}\n\twaitCursor -state on;\n\t$vtxStr = $obj+\".vtx[\";\n\tfor ($i=0;$i<size($aSelVerts);$i++){\n\t\t$vertNum = match(\"([0-9])+\", (match (\"([0-9])+\\\\]\", ($vtxStr+$aSelVerts[$i]+\"]\"))));\n\t\t$mVertNum = abGetSymVtx($vertNum);\n\t\tif ($mVertNum != -1){\n\t\t\t$aRetVerts[size($aRetVerts)] = ($vtxStr+$mVertNum+\"]\");\n\t\t}else{ //return non symverts too (zeros and others)\n\t\t\t$aRetVerts[size($aRetVerts)] = ($vtxStr+$vertNum+\"]\");\n\t\t}\n\t}\n\twaitCursor -state off;\n\treturn $aRetVerts;\n}\n\n\nglobal proc abClearSbg(){\n\t//clears sbgFld and empties $abSymTable\n\tglobal int $abSymTable[];\t\n\tglobal string $abSbg;\n\tglobal string $abAltSbg;\n\t\n\tbutton -e -enable false smBn;\n\tbutton -e -enable false smvBn;\n\tbutton -e -enable false msBn;\n\tbutton -e -enable false fsBn;\n\tbutton -e -enable false rsBn;\n\tclear($abSymTable);\n\t$abSbg = $abAltSbg = \"\";\n\ttextField -e -text \"\" sbgFld;\n}\n\n\nglobal proc abSymCtl(string $action){\n\t\n\tglobal int $abSymTable[];\n\tglobal string $abSbg;\n\tglobal string $abAltSbg;\n\t\n\tstring $sel[] = `ls -sl -fl`;\n\tstring $aStr[];\n\tstring $aSelVerts[];\n\tstring $aHiliteObj[];\n\tstring $baseObj = $abSbg;\n\tstring $revertBaseObj = ($abAltSbg != \"\") ? $abAltSbg : $abSbg;\n\tstring $str;\n\tstring $selMesh;\n\tfloat $tol = `floatField -q -value tolFltFld`;\n\tint $axisSel = `radioButtonGrp -q -select saRbGrp`;\n\tint $negToPos = `checkBox -q -value maChkBx`;\n\tint $usePiv = `checkBox -q -value upoChkBx`;\n\tint $warned = false; //set if warning has already been passed\n\tfloat $revertBias = 1;\n\t\n\tif ($action == \"rsPrBn\"){\n\t\t$revertBias = `floatField -q -value rsPrFltFld`;\n\t\t$action = \"rsBn\";\n\t}\n\t\n\t//get selection info\n\t\n\t$aStr = `filterExpand -sm 12 $sel`;\n\tif (size($aStr) > 1){\n\t\twarning \"Select one polygon object\";\n\t\t$warned = true;\n\t}else{\n\t\t$selMesh = $aStr[0]; //if an object is selected\n\t}\n\t\n\t//make sure selected components are on only one mesh\n\tif ($selMesh == \"\"){\n\t\t$aHiliteObj = `ls -hilite`;\n\t\tif (size($aHiliteObj) == 1){\n\t\t\t$selMesh = $aHiliteObj[0];\n\t\t\t$aSelVerts = `filterExpand -sm 31 $sel`;\n\t\t}else{\n\t\t\tif (size($aHiliteObj) > 1){\n\t\t\t\tclear($aSelVerts);\n\t\t\t\twarning \"Only one object can be hilited in component mode\";\n\t\t\t\t$warned = true;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tselect $selMesh; //if two objects are selected\n\t}\n\t\n\tswitch ($action){\n\t\t\n\t\tcase \"sbgBn\":\n\t\t\tif ($selMesh != \"\"){\n\t\t\t\tabCheckSym($selMesh, $axisSel, $tol, true, $usePiv);\n\t\t\t\t$abSbg = $selMesh;\n\t\t\t\ttextField -e -text $selMesh sbgFld;\n\t\t\t\tbutton -e -enable true smBn;\n\t\t\t\tbutton -e -enable true smvBn;\n\t\t\t\tbutton -e -enable true msBn;\n\t\t\t\tbutton -e -enable true fsBn;\n\t\t\t\tbutton -e -enable true rsBn;\n\t\t\t}else{\n\t\t\t\tabClearSbg();\n\t\t\t}\n\t\t\tbreak;\n\t\t\n\t\tcase \"favBn\":\n\t\t\tif ($selMesh != \"\"){\n\t\t\t\t$aSelVerts = abCheckSym($selMesh, $axisSel, $tol, false, $usePiv);\n\t\t\t\tif (size($aSelVerts) > 0){\n\t\t\t\t\tselectMode -component;\n\t\t\t\t\tselect $aSelVerts;\n\t\t\t\t\tprint (size($aSelVerts)+\" asymmetric vert(s)\");\n\t\t\t\t}else{\n\t\t\t\t\tselect $selMesh;\n\t\t\t\t\tprint ($selMesh+\" is symmetrical\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase \"smBn\":\n\t\t\tif (size($aSelVerts) > 0){\n\t\t\t\t$aSelVerts = abSelMirror ($selMesh, $aSelVerts);\n\t\t\t\tselect $aSelVerts;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase \"smvBn\":\n\t\t\tif ($selMesh != \"\"){\n\t\t\t\t$aSelVerts = abSelMovedVerts($selMesh, $baseObj, $tol);\n\t\t\t\tselect $aSelVerts;\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase \"smvAltBn\":\n\t\t\tif ($selMesh != \"\"){\n\t\t\t\t$aSelVerts = abSelMovedVerts($selMesh, $revertBaseObj, $tol);\n\t\t\t\tselect $aSelVerts;\n\t\t\t}\n\t\t\tbreak;\t\n\t\t\t\n\t\tcase \"msBn\":\n\t\t\tif (size($aSelVerts) > 0){\n\t\t\t\tabMirrorSel($selMesh, $baseObj, $aSelVerts, $axisSel, $negToPos, false, $usePiv, $tol);\n\t\t\t}else{\n\t\t\t\tif ($selMesh != \"\"){ //if object is selected, select half side verts then pass that as $aSelVerts\n\t\t\t\t\t$aSelVerts = abSelSideVerts ($selMesh, $baseObj, $axisSel, $negToPos, $usePiv, $tol);\n\t\t\t\t\tabMirrorSel($selMesh, $baseObj, $aSelVerts, $axisSel, $negToPos, false, $usePiv, $tol);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase \"fsBn\":\n\t\t\tif (size($aSelVerts) > 0){\n\t\t\t\tabMirrorSel($selMesh, $baseObj, $aSelVerts, $axisSel, $negToPos, true, $usePiv, $tol);\n\t\t\t}else{\n\t\t\t\tif ($selMesh != \"\"){ //if object is selected, select half side verts then pass that as $aSelVerts\n\t\t\t\t\t$aSelVerts = abSelSideVerts ($selMesh, $baseObj, $axisSel, $negToPos, $usePiv, $tol);\n\t\t\t\t\tabMirrorSel($selMesh, $baseObj, $aSelVerts, $axisSel, $negToPos, true, $usePiv, $tol);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\t\t\n\t\tcase \"rsBn\":\n\t\t\t\n\t\t\tif (size($aSelVerts) > 0){\n\t\t\t\tabRevertSel($aSelVerts, $selMesh, $revertBaseObj, $revertBias);\n\t\t\t}else{\n\t\t\t\tif ($selMesh != \"\"){ //if object is selected, select half side verts then pass that as $aSelVerts\n\t\t\t\t\t$aSelVerts = abSelSideVerts ($selMesh, $baseObj, $axisSel, 2, $usePiv, $tol); //2 returns all verts\n\t\t\t\t\tabRevertSel($aSelVerts, $selMesh, $revertBaseObj, $revertBias);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase \"cBn\":\n\t\t\tabClearSbg();\n\t\t\tabSymClearRevTables();\n\t\t\tdeleteUI -window abSymWin;\n\t\t\tbreak;\n\t\t\n\t\tcase \"saRbGrp\":\n\t\t\tabClearSbg();\n\t\t\tswitch ($axisSel){\n\t\t\t\tcase 1:\n\t\t\t\t\t$str = \"X\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\t$str = \"Y\";\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\t$str = \"Z\";\n\t\t\t\t\tbreak;\n\t\t\t\t\n\t\t\t}\n\t\t\t$str = \"Operate -\"+$str+\" to +\"+$str;\n\t\t\tcheckBox -e -l $str maChkBx;\n\t}\n\tsetFocus \"modelPanel1\";\n}\n\n\nglobal proc abSymMesh(){\n\t\n\tglobal int $abSymTable[];\n\tglobal string $abSbg;\n\tglobal string $abAltSbg;\n\tglobal int $abSymSliderDragging;\n\t\n\t$abSymSliderDragging = false;\n\t\n\tabSymClearRevTables();\n\t\n\tfloat $aRevertPopupVals[] = {1,2,3,4,5,1111,10,20,30,40,50,60,70,80,90}; //values that will appear in the revert popup menu (1111 is a divider bar)\n\t\n\tint $sbgBnsEn = false; //bool for enabled state of sbg dependent buttons\n\tstring $selBaseGeo;\n\t\n\tif (size($abSymTable) > 0 && `objExists $abSbg`){ //reselect object whose data is in symTable\n\t\t$selBaseGeo = $abSbg;\n\t\t$sbgBnsEn = true;\n\t}else{\n\t\tclear($abSymTable);\n\t\t$abSbg = $abAltSbg = \"\";\n\t}\n\t\n\tif (`window -exists abSymWin`){\n\t\tdeleteUI -window abSymWin;\n\t}\n\t\n\twindow -t \"abSymMesh\" -w 180 -h 474 -menuBar true abSymWin;\n\t\n\t// add menu\n\tmenu -label \"Operations\" -postMenuCommand \"global string $abSbg;string $aStr[], $str;$aStr = {\\\"abSMOpCopyMnIt\\\",\\\"abSMOpAddMnIt\\\",\\\"abSMOpSubtractMnIt\\\",\\\"abSMOpMirrCopyMnIt\\\",\\\"abSMOpMirrAddMnIt\\\",\\\"abSMOpMirrSubtractMnIt\\\",\\\"abSMOpBBaseAddMnIt\\\",\\\"abSMOpBBaseSubtractMnIt\\\",\\\"abSMOpBBaseMirrAddMnIt\\\",\\\"abSMOpBBaseMirrSubtractMnIt\\\"};for ($str in $aStr) menuItem -e -en ($abSbg != \\\"\\\" && `radioButtonGrp -q -select saRbGrp` == 1) $str;\";\n\tmenuItem -label \"Copy A to B\" -command \"abSMServiceAddSubtractCopy(2);\" abSMOpCopyMnIt;\n\tmenuItem -label \"Add A to B\" -command \"abSMServiceAddSubtractCopy(1);\" abSMOpAddMnIt;\n\tmenuItem -label \"Subtract A from B\" -command \"abSMServiceAddSubtractCopy(0);\" abSMOpSubtractMnIt;\n\tmenuItem -divider true;\n\tmenuItem -label \"Copy Mirror A to B\" -command \"abSMServiceAddSubtractCopy(5);\" abSMOpMirrCopyMnIt;\n\tmenuItem -label \"Add Mirror A to B\" -command \"abSMServiceAddSubtractCopy(4);\" abSMOpMirrAddMnIt;\n\tmenuItem -label \"Subtract Mirror A from B\" -command \"abSMServiceAddSubtractCopy(3);\" abSMOpMirrSubtractMnIt;\n\tmenuItem -divider true;\n\tmenuItem -label \"Add A to B (Use B as Base)\" -command \"abSMServiceAddSubtractCopy(7);\" abSMOpBBaseAddMnIt;\n\tmenuItem -label \"Subtract A from B (Use B as Base)\" -command \"abSMServiceAddSubtractCopy(6);\" abSMOpBBaseSubtractMnIt;\n\tmenuItem -divider true;\n\tmenuItem -label \"Add Mirror A to B (Use B as Base)\" -command \"abSMServiceAddSubtractCopy(10);\" abSMOpBBaseMirrAddMnIt;\n\tmenuItem -label \"Subtract Mirror A from B (Use B as Base)\" -command \"abSMServiceAddSubtractCopy(9);\" abSMOpBBaseMirrSubtractMnIt;\n\t\n\t\n\tmenu -label \"Tools\";\n\tmenuItem -label \"Attempt To Restore Symmetry\" -ann \"Attempt to restore X axis symmetry by matching vertices while iterating through a series of increasing radii.\" -command \"abSymmetrizeVertsUI();\";\n\t\n\t// continue with layout\n\tformLayout -numberOfDivisions 100 abSymForm;\n\t\n\tradioButtonGrp -numberOfRadioButtons 3 -l1 \"YZ\" -l2 \"XZ\" -l3 \"XY\"\n\t\t-select 1 -columnWidth3 52 52 52 -onCommand \"abSymCtl(\\\"saRbGrp\\\")\" saRbGrp;\n\tseparator sep1;\n\ttext -l \"Global Tolerance\" tolTxt;\n\t\n\tfloatField -min 0 -max 1 -value .001 tolFltFld;\n\tseparator sep2;\n\tbutton -l \"Select Base Geometry\" -command \"abSymCtl(\\\"sbgBn\\\")\" sbgBn;\n\ttextField -editable false -text $selBaseGeo sbgFld;\n\tseparator sep3;\n\tbutton -l \"Check Symmetry\" -command \"abSymCtl(\\\"favBn\\\")\" csBn;\n\tbutton -l \"Selection Mirror\" -enable $sbgBnsEn -command \"abSymCtl(\\\"smBn\\\")\" smBn;\n\tbutton -l \"Select Moved Verts\" -enable $sbgBnsEn -command \"abSymCtl(\\\"smvBn\\\")\" smvBn;\n\tseparator sep4;\n\tbutton -l \"Mirror Selected\" -enable $sbgBnsEn -command \"abSymCtl(\\\"msBn\\\")\" msBn;\n\tbutton -l \"Flip Selected\" -enable $sbgBnsEn -command \"abSymCtl(\\\"fsBn\\\")\" fsBn;\n\tbutton -l \"Revert Selected to Base\" -enable $sbgBnsEn  -command \"abSymCtl(\\\"rsBn\\\")\" rsBn;\n\t\n\tstring $tCmdStr = \"floatField -e -value ((`floatField -q -v rvrtFltValFltFld`)/100.0) rsPrFltFld;abSymCtl(\\\"rsPrBn\\\");\";\n\t\n\tfloatField -value 0 -pre 2 -min 0 -max 100 -cc $tCmdStr -ec $tCmdStr rvrtFltValFltFld;\n\tfloatSlider -value 1 -minValue 0 -maxValue 1 -dragCommand \"abSymInteractiveRevertToBase();\" -changeCommand \"abSymEndDrag();\" rvrtFltSldr;\n\t\n\tpopupMenu -button 3 -p rvrtFltSldr rsPpUpMn;\n\tmenuItem -label \"Commit Changes\" -command \"abSymClearRevTables();\";\n\tseparator sep5;\n\tcheckBox -l \"Operate -X to +X\" -value false maChkBx;\n\tcheckBox -l \"Use Pivot as Origin\" -value true upoChkBx;\n\tbutton -l \"Close\" -height 24 -command \"abSymCtl(\\\"cBn\\\")\" cBn;\n\t\n\t//hidden var field\n\tfloatField -value 1 -min 0 -max 1 -pre 2 -manage 0 rsPrFltFld;\n\t\t\n\t//revert button popup menus\n\t\n\tpopupMenu -button 3 -p rsBn rsPpUpMn;\n\t\n\tif (size($aRevertPopupVals) > 0){\n\t\t\n\t\tint $i;\n\t\tstring $cmdStr;\n\t\tfloat $flt;\n\t\t\n\t\tfor ($i=0;$i<size($aRevertPopupVals);$i++){\n\t\t\t\n\t\t\tif ($aRevertPopupVals[$i] == 1111){\n\t\t\t\t$cmdStr += \"menuItem -divider true;\";\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\t$flt = $aRevertPopupVals[$i]/100;\n\t\t\t$cmdStr += \"menuItem -label \\\"\"+$aRevertPopupVals[$i]+\"%\\\" -command \\\"floatField -e -value \"+$flt+\" rsPrFltFld;abSymCtl(\\\\\\\"rsPrBn\\\\\\\");\\\";\";\n\t\t}\n\t\t\n\t\t$cmdStr += \"menuItem -divider true;\";\n\t\teval($cmdStr);\n\t}\n\t\n\tsetParent -m rsPpUpMn;\n\t\n\tstring $baseStr;\n\tint $enableOrigRecall = false;\n\t\n\tif ($abAltSbg != \"\" && `objExists $abAltSbg`){\n\t\t$baseStr = \"Using \"+$abAltSbg+\" as Base\";\n\t\t$enableOrigRecall = true;\n\t}else{\n\t\t$baseStr = \"Using Original Base\";\n\t}\n\t\n\tmenuItem -label $baseStr abSymCurBsMnIt;\n\tmenuItem -divider true;\n\tmenuItem -label \"Use Selected as Base\" -command \"abSymUseAlternateBase(1);\" abSymSlRvtBsMnIt;\n\tmenuItem -label \"Use Original Base\" -enable $enableOrigRecall -command \"abSymUseAlternateBase(0);\" abSymSlOrigRvtBsMnIt;\n\tmenuItem -label \"Select Moved from Revert Base\" -enable $enableOrigRecall -command \"abSymCtl(\\\"smvAltBn\\\");\" abSymSlAltMvVtsMnIt;\n\tmenuItem -divider true;\n\tmenuItem -label \"Use Overshoot\" -checkBox 0 -command \"float $min,$max;if (`menuItem -q -c abSymOvrShtMnIt`){$min=-.5;$max=1.5;}else{$min=0;$max=1;}floatSlider -e -min $min -max $max rvrtFltSldr;\" abSymOvrShtMnIt;\n\tsetParent ..;\n\t\n\tint $tMarg = 7;\n\tint $lMarg = 5;\n\tint $rMarg = 5;\n\tint $ctSpc = 5; //control top space\n\tint $cbSpc = 20;\n\t\t\n\tformLayout -e\n\t\t\n\t\t-af saRbGrp \"top\" $tMarg\n\t\t-af saRbGrp \"left\" 18\n\t\t\n\t\t-af sep1 \"left\" $lMarg\n\t\t-ac sep1 \"top\" $ctSpc saRbGrp\n\t\t-af sep1 \"right\" $rMarg\n\t\t\n\t\t-af tolTxt \"left\" $lMarg\n\t\t-ac tolTxt \"top\" ($ctSpc+2) sep1\n\t\t-ac tolFltFld \"left\" $ctSpc tolTxt\n\t\t-ac tolFltFld \"top\" $ctSpc sep1\n\t\t-af tolFltFld \"right\" $rMarg\n\t\t\n\t\t-af sep2 \"left\" $lMarg\n\t\t-ac sep2 \"top\" $ctSpc tolFltFld\n\t\t-af sep2 \"right\" $rMarg\n\t\t\n\t\t-af sbgBn \"left\" $lMarg\n\t\t-ac sbgBn \"top\" $ctSpc sep2\n\t\t-af sbgBn \"right\" $rMarg\n\t\t\n\t\t-af sbgFld \"left\" $lMarg\n\t\t-ac sbgFld \"top\" $ctSpc sbgBn\n\t\t-af sbgFld \"right\" $rMarg\n\t\t\n\t\t-af sep3 \"left\" $lMarg\n\t\t-ac sep3 \"top\" $ctSpc sbgFld\n\t\t-af sep3 \"right\" $rMarg\n\t\t\n\t\t-af csBn \"left\" $lMarg\n\t\t-ac csBn \"top\" $ctSpc sep3\n\t\t-af csBn \"right\" $rMarg\n\t\t\n\t\t-af smBn \"left\" $lMarg\n\t\t-ac smBn \"top\" $ctSpc csBn\n\t\t-af smBn \"right\" $rMarg\n\t\t\n\t\t-af smvBn \"left\" $lMarg\n\t\t-ac smvBn \"top\" $ctSpc smBn\n\t\t-af smvBn \"right\" $rMarg\n\t\t\n\t\t-af sep4 \"left\" $lMarg\n\t\t-ac sep4 \"top\" $ctSpc smvBn\n\t\t-af sep4 \"right\" $rMarg\n\t\t\n\t\t-af msBn \"left\" $lMarg\n\t\t-ac msBn \"top\" $ctSpc sep4\n\t\t-af msBn \"right\" $rMarg\n\t\t\t\t\n\t\t-af fsBn \"left\" $lMarg\n\t\t-ac fsBn \"top\" $ctSpc msBn\n\t\t-af fsBn \"right\" $rMarg\n\t\t\n\t\t-af sep5 \"left\" $lMarg\n\t\t-ac sep5 \"top\" $ctSpc fsBn\n\t\t-af sep5 \"right\" $rMarg\n\t\t\n\t\t-af rsBn \"left\" $lMarg\n\t\t-ac rsBn \"top\" $ctSpc sep5\n\t\t-af rsBn \"right\" $rMarg\n\t\t\t\n\t\t-af rvrtFltSldr \"left\" $lMarg\n\t\t-ac rvrtFltSldr \"top\" ($ctSpc+4) rsBn\n\t\t-ap rvrtFltSldr \"right\" $rMarg 78\n\t\t\n\t\t-ac rvrtFltValFltFld \"left\" $lMarg rvrtFltSldr\n\t\t-ac rvrtFltValFltFld \"top\" $ctSpc rsBn\n\t\t-af rvrtFltValFltFld \"right\" $rMarg\n\t\t\n\t\t-af maChkBx \"left\" $lMarg\n\t\t-ac maChkBx \"top\" ($ctSpc+4) rvrtFltSldr\n\t\t\n\t\t-af upoChkBx \"left\" $lMarg\n\t\t-ac upoChkBx \"top\" $ctSpc maChkBx\n\t\t\n\t\t-af cBn \"left\" $lMarg\n\t\t-ac cBn \"top\" $cbSpc upoChkBx\n\t\t-af cBn \"right\" $rMarg\n\t\t\n\t\tabSymForm\n\t\t;\n\t\n\tshowWindow abSymWin;\n}\n\n\nglobal proc abSymmetrizeVertsUI(){\n\t\n\tint $lmargin = 3;\n\tint $rmargin = 3;\n\tint $tmargin = 5;\n\t\n\tif (`window -exists abSymmetrizeVertsWin`)\n\t\tdeleteUI -window abSymmetrizeVertsWin;\n\t\n\twindow -t \"Symmetrize Verts\" -w 164 -h 114 -menuBar false -minimizeButton false -maximizeButton false abSymmetrizeVertsWin;\n\t\t\n\tformLayout -numberOfDivisions 100 abSymmetrizeVertsForm;\n\t\n\ttext -l \"Iterations:\" abSymVtIterationsTxt;\n\tintField -min 10 -v 200 abSymVtIterationsIntFld; \n\t\n\ttext -l \"Start Radius:\" abSymVtStRadTxt;\n\tfloatField -precision 6 -min .00000001 -v .000001 abSymVtStRadFltFld;\n\t\n\ttext -l \"End Radius:\" abSymVtEndRadTxt;\n\tfloatField -precision 6 -min .001 -v 1 abSymVtEndRadFltFld;\n\t\n\tbutton -h 28 -l \"Symmetrize Selected Verts\" -c \"abSymmetrizeVerts(`floatField -q -v abSymVtStRadFltFld`, `floatField -q -v abSymVtEndRadFltFld`, `intField -q -v abSymVtIterationsIntFld`);\" abSymVtGoBn;\n\t\n\tformLayout -e\n\t\n\t-af abSymVtIterationsTxt \"top\" $tmargin\n\t-af abSymVtIterationsTxt \"left\" $lmargin\n\t\n\t-af abSymVtIterationsIntFld \"top\" $tmargin\n\t-ac abSymVtIterationsIntFld \"left\" $lmargin abSymVtIterationsTxt\n\t-af abSymVtIterationsIntFld \"right\" $rmargin\n\t\n\t-ac abSymVtStRadTxt \"top\" $tmargin abSymVtIterationsIntFld\n\t-af abSymVtStRadTxt \"left\" $lmargin\n\t\n\t-ac abSymVtStRadFltFld \"top\" $tmargin abSymVtIterationsIntFld\n\t-ac abSymVtStRadFltFld \"left\" $lmargin abSymVtStRadTxt\n\t-af abSymVtStRadFltFld \"right\" $rmargin\n\t\n\t-ac abSymVtEndRadTxt \"top\" $tmargin abSymVtStRadFltFld\n\t-af abSymVtEndRadTxt \"left\" $lmargin\n\t\n\t-ac abSymVtEndRadFltFld \"top\" $tmargin abSymVtStRadFltFld\n\t-ac abSymVtEndRadFltFld \"left\" $lmargin abSymVtEndRadTxt\n\t-af abSymVtEndRadFltFld \"right\" $rmargin\n\t\n\t-ac abSymVtGoBn \"top\" $tmargin abSymVtEndRadFltFld\n\t-af abSymVtGoBn \"left\" $lmargin\n\t-af abSymVtGoBn \"right\" $rmargin\n\t\n\tabSymmetrizeVertsForm\n\t;\n\t\n\tshowWindow abSymmetrizeVertsWin;\n\t\n}\n\n\nglobal proc abSymmetrizeVerts(float $startTol, float $endTol, int $iterations){\n\t// select src, targ, src, targ and this funtion will symmetrize them across the yz axis\n\t\n\tstring $aSel[], $aSelObj[], $obj, $aLfVts[], $aRtVts[], $aOriginVts[], $aTempLfVts[], $aTempRtVts[], $plural;\n\tfloat $aTrans[], $aSrcTrans[], $aDestTrans[], $tol, $t, $aOffset[];\n\tint $i, $k, $it, $match, $matchCounter;\n\t\n\t$matchCounter = 0;\n\t\n\tif ($startTol > $endTol){\n\t\twarning \"Start radius must be less than end tolerance.  Try again.\";\n\t\treturn;\n\t}\n\t\n\t$aSel = `filterExpand -sm 31`;\n\t\n\t$aSelObj = `ls -hilite`;\n\t\n\tif (size($aSelObj) != 1){\n\t\twarning \"Select asymmetrical verts on a single object and try again.\";\n\t\treturn;\n\t}\n\t\n\t$obj = $aSelObj[0];\n\t\n\t// sort verts\n\tfor ($i=0;$i<size($aSel);$i++){\n\t\t\n\t\t$aTrans = `xform -q -os -t $aSel[$i]`;\n\t\t\n\t\tif ($aTrans[0] > $startTol){\n\t\t\t\n\t\t\t$aLfVts[size($aLfVts)] = $aSel[$i];\n\t\t\t\n\t\t}else if ($aTrans[0] < (-1.0*$startTol)){\n\t\t\t\n\t\t\t$aRtVts[size($aRtVts)] = $aSel[$i];\n\t\t\t\n\t\t}else{\n\t\t\t$aOriginVts[size($aOriginVts)] = $aSel[$i];\n\t\t}\n\t}\n\t\n\tfloat $prog, $progDenom;\n\tint $numLfVts;\n\t\n\t$numLfVts = size($aLfVts);\n\twaitCursor -state on;\n\tprogressWindow -title \"Working\" -progress 0 -status \"Matched 0 Vertices\";\n\t$progDenom = float($numLfVts);\n\t\n\t\n\t// now go through verts in ever increasing tolerance\n\tfor ($it=0;$it<$iterations;$it++){\n\t\t\n\t\t//prog win\n\t\t$prog = ((float($numLfVts-(size($aLfVts))))/$progDenom)*100.0;\n\t\tprogressWindow -e -progress (int($prog));\n\t\t//end prog win\n\t\t\n\t\t\n\t\tclear($aTempLfVts);  \n\t\t\n\t\t$t = float($it)/float($iterations-1);\n\t\t$tol = $endTol*(float($t))*(float($t)) + $startTol;\n\t\t\n\t\tfor ($i=0;$i<size($aLfVts);$i++){\n\t\t\t\n\t\t\tclear($aTempRtVts);\n\t\t\t$match = false;\n\t\t\t\n\t\t\t$aSrcTrans = `xform -q -os -t $aLfVts[$i]`;\n\t\t\t$aDestTrans = $aSrcTrans;\n\t\t\t$aDestTrans[0] *= -1.0;\n\t\t\t\t\n\t\t\tfor ($k=0;$k<size($aRtVts);$k++){\n\t\t\t\t\n\t\t\t\t$aTrans = `xform -q -os -t $aRtVts[$k]`;\n\t\t\t\t\n\t\t\t\t$aOffset[0] = abs($aDestTrans[0] - $aTrans[0]);\n\t\t\t\t$aOffset[1] = abs($aDestTrans[1] - $aTrans[1]);\n\t\t\t\t$aOffset[2] = abs($aDestTrans[2] - $aTrans[2]);\n\t\t\t\t\n\t\t\t\tif (!$match && ($aOffset[0] < $tol && $aOffset[1] < $tol && $aOffset[2] < $tol)){\n\t\t\t\t\t\n\t\t\t\t\t// match\n\t\t\t\t\t$match = true;\n\t\t\t\t\t$matchCounter++;\n\t\t\t\t\t\n\t\t\t\t\txform -os -t $aDestTrans[0] $aDestTrans[1] $aDestTrans[2] $aRtVts[$k];\n\t\t\t\t\t\n\t\t\t\t\tselect -tgl $aLfVts[$i] $aRtVts[$k] ;\n\t\t\t\t\t\n\t\t\t\t\t$plural = ($matchCounter == 1) ? \"vertex\" : \"vertices\";\n\t\t\t\t\tprogressWindow -e -status (\"Matched \"+$matchCounter+\" \"+$plural);\n\t\t\t\t\t\n\t\t\t\t}else{\n\t\t\t\t\t$aTempRtVts[size($aTempRtVts)] = $aRtVts[$k];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (!$match)\n\t\t\t\t$aTempLfVts[size($aTempLfVts)] = $aLfVts[$i];\n\t\t\t\n\t\t\t$aRtVts = $aTempRtVts;\n\t\t}\n\t\t\n\t\t$aLfVts = $aTempLfVts;\n\t\t\n\t\tif (size($aLfVts) == 0 && size($aRtVts) == 0)\n\t\t\tbreak;\n\t}\n\t\n\tprogressWindow -endProgress;\n\twaitCursor -state off;\n\t\n\t//print (\"\\nfinal tolerance was: \"+$tol);\n\t\n\tif ($matchCounter > 0)\n\t\tprint (\"\\n\\nSymmetrized \"+$matchCounter+\" \"+$plural+\".\");\n\t\n}\n\nabSymMesh" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "/*___________________________________________________________________________\n|\n|   BSpiritCorrectiveShape v1.2\n|\n|   Copyright (C) 2004 Christian Breitling\n|   Last modified: Oktober 13, 2004 Germany\n|   \n|   Email: christian.breitling@gmx.de\n|   \n|\n|   This program is free software; you can redistribute it and/or\n|   modify it under the terms of the GNU General Public License\n|   as published by the Free Software Foundation; either version 2\n|   of the License, or (at your option) any later version.\n|\n|   This program is distributed in the hope that it will be useful,\n|   but WITHOUT ANY WARRANTY; without even the implied warranty of\n|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n|   GNU General Public License for more details.\n|\n|   You should have received a copy of the GNU General Public License\n|   along with this program; if not, write to the Free Software\n|   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n|\n|   The GNU GPL is also available at http://www.gnu.org/licenses/gpl.html\n|\n|____________________________________________________________________________\n\n  What CorrectiveShape is for:\n  ----------------------------\n  Create a corrective blend shape for your binded mesh. \n\n\n  How is it working: \n  ------------------\n  In general vertices in Maya behave different than normal if they are binded.\n  The rotation of a joint also affects the local space of the binded vertices.\n  Moving them in the viewport causes very funny effects. But for creating \n  corrective blend shapes normal behavior would be best. Duplicating the binded\n  mesh and applying it afterwards as blend shape causes wrong vertex behavior.\n  So the world position of the blend shape has to be translated to the local \n  space of the skinned mesh.\n\n  This is done by the following script wich uses an equitation to get the right\n  motion vector.\n\n\n  How to use it:\n  --------------  \n\n    1. Installation:\n    ----------------\n\n      - Copy this mel script in one of your script directories of Maya.\n\n\n\n    2. Normal Usage:\n    ----------------\n\n      1. Move the skinned mesh to the desired pose. You might key all important \n         handles and joints for recalling them later.\n\n      2. Duplicate it without any connections. \n         The duplicate can be translated freely [you`ll have to unlock the transformation]. \n         The original mesh mustn`t change [except you keyed the pose -> restore before calculation]. \n\n      3. Model the appropriate corrections for this pose.\n\n      4. Select the newly created corrective shape and then the original mesh [in this order].\n\n      5. run \"BSpiritCorrectiveShape\" in the command line or script editor.\n\n\n\n    3. Advanced Usage:\n    ------------------\n\n      To calculate and move only specific vertices: \n\n      1. - 3. Same procedure as above\n\n      4. Select the newly created corrective shape in \"Object Mode\". \n         Via right mouse button change to \"Vertex Mode\" and select the appropriate vertices.\n         Add the original mesh to your selection.\n\n      5. run \"BSpiritCorrectiveShape\" in the command line or script editor.\n\n\n\n\n  You will receive a perfect blend shape mesh. Assigning it is your task. \n  Don`t forget to change the input connection order. Blend shapes have to be\n  first (bottom) in the stack.\n\n  If anything could be better, nothing is functioning or you just want to write\n  me - don`t bother\n\n  Christian Breitling\n\n  christian.breitling@gmx.de\n\n_____________________________________________________________________________\n*/\n\nsource BSpiritCorrectiveShape;\n\n\n// __________________________________________________________________________________________\n// VertexPosition procedure\n// __________________________________________________________________________________________\n\n\nproc BSpiritCorrectiveShapeVectorMove( string $TweakVertexName, string $BaseModelVertexName,\n                                       float $WorldPosX,  float $WorldPosY,  float $WorldPosZ,\n                                       float $targetPosX, float $targetPosY, float $targetPosZ,\n                                       float $relPosX,    float $relPosY,    float $relPosZ ) {\n\n  float $tempPos[3];\n  float $Matrix[12];\n\n  setAttr ($TweakVertexName + \"].xVertex\") ($relPosX + 1);\n  $tempPos = `pointPosition -w $BaseModelVertexName`;\n  $Matrix[0]  = $tempPos[0]-$WorldPosX;\n  $Matrix[4]  = $tempPos[1]-$WorldPosY;\n  $Matrix[8]  = $tempPos[2]-$WorldPosZ;\n  $Matrix[3]  = $targetPosX;\n\n  setAttr ($TweakVertexName + \"].xVertex\") ($relPosX);\n  setAttr ($TweakVertexName + \"].yVertex\") ($relPosY + 1);\n  $tempPos = `pointPosition -w $BaseModelVertexName`;\n  $Matrix[1]  = $tempPos[0]-$WorldPosX;\n  $Matrix[5]  = $tempPos[1]-$WorldPosY;\n  $Matrix[9]  = $tempPos[2]-$WorldPosZ;\n  $Matrix[7]  = $targetPosY;\n\n\n  setAttr ($TweakVertexName + \"].yVertex\") ($relPosY);\n  setAttr ($TweakVertexName + \"].zVertex\") ($relPosZ + 1);\n  $tempPos = `pointPosition -w $BaseModelVertexName`;\n  $Matrix[2]  = $tempPos[0]-$WorldPosX;\n  $Matrix[6]  = $tempPos[1]-$WorldPosY;\n  $Matrix[10] = $tempPos[2]-$WorldPosZ;\n  $Matrix[11] = $targetPosZ;\n\n  float $return[3];\n  float $Denominator = \n\n  ($Matrix[0] * (($Matrix[5]*$Matrix[10]) - ($Matrix[6]*$Matrix[9]))) - \n  ($Matrix[1] * (($Matrix[4]*$Matrix[10]) - ($Matrix[6]*$Matrix[8]))) + \n  ($Matrix[2] * (($Matrix[4]*$Matrix[9] ) - ($Matrix[5]*$Matrix[8])));\n\n  if ($Denominator != 0) { \n\n    $return[0] = \n \n    (\n    ($Matrix[3] * (($Matrix[5]*$Matrix[10]) - ($Matrix[6]*$Matrix[9]  ))) - \n    ($Matrix[1] * (($Matrix[7]*$Matrix[10]) - ($Matrix[6]*$Matrix[11] ))) + \n    ($Matrix[2] * (($Matrix[7]*$Matrix[9] ) - ($Matrix[5]*$Matrix[11] )))\n    ) / $Denominator;\n\n    $return[1] = \n \n    (\n    ($Matrix[0] * (($Matrix[7]*$Matrix[10]) - ($Matrix[6]*$Matrix[11] ))) -\n    ($Matrix[3] * (($Matrix[4]*$Matrix[10]) - ($Matrix[6]*$Matrix[8]  ))) + \n    ($Matrix[2] * (($Matrix[4]*$Matrix[11]) - ($Matrix[7]*$Matrix[8]  )))\n    ) / $Denominator;\n\n    $return[2] =\n\n    (\n    ($Matrix[0] * (($Matrix[5]*$Matrix[11]) - ($Matrix[7]*$Matrix[9]  ))) - \n    ($Matrix[1] * (($Matrix[4]*$Matrix[11]) - ($Matrix[7]*$Matrix[8]  ))) + \n    ($Matrix[3] * (($Matrix[4]*$Matrix[9] ) - ($Matrix[5]*$Matrix[8]  )))\n    ) / $Denominator;\n\n    setAttr ($TweakVertexName + \"].xVertex\") ($relPosX + $return[0]);\n    setAttr ($TweakVertexName + \"].yVertex\") ($relPosY + $return[1]);\n    setAttr ($TweakVertexName + \"].zVertex\") ($relPosX + $return[2]);\n        \n  }\n}\n\n\n// __________________________________________________________________________________________\n// VertexMatrix procedure\n// __________________________________________________________________________________________\n\nproc float[] BSpiritCorrectiveShapePosition( string $BlendShapeVertexName, \n                                             string $BaseModelVertexName, \n                                             float $OffsetX, float $OffsetY, float $OffsetZ) {\n\n  float $targetPos[3];\n  float $Pos[3];\n  float $relVertexPos[3];\n\n  $targetPos = `pointPosition -w $BlendShapeVertexName`;\n  $Pos = `pointPosition -w $BaseModelVertexName`;\n  $relVertexPos = `getAttr $BaseModelVertexName`;\n\n  $targetPos[0] -= ($Pos[0]+$OffsetX);\n  $targetPos[1] -= ($Pos[1]+$OffsetY);\n  $targetPos[2] -= ($Pos[2]+$OffsetZ); \n\n  if (($targetPos[0]>0.001) || ($targetPos[0]<-0.001) || \n      ($targetPos[1]>0.001) || ($targetPos[1]<-0.001) || \n      ($targetPos[2]>0.001) || ($targetPos[2]<-0.001))\n\n    return { 1.0,\n             $Pos[0],          $Pos[1],          $Pos[2],\n             $targetPos[0],    $targetPos[1],    $targetPos[2],\n             $relVertexPos[0], $relVertexPos[1], $relVertexPos[2] };\n  \n  else \n\n    return { -1.0 };     \n\n}\n\n// __________________________________________________________________________________________\n// Main Procedure\n// __________________________________________________________________________________________\n\nglobal proc BSpiritCorrectiveShape() {\n\n// __________________________________________________________________________________________\n// Declaring main variables & Query names and selections \n// __________________________________________________________________________________________\n\n  string $SelectedVertexArray[] = `filterExpand -sm 31`;   // Vertex\n  string $SelectedItemArray[] = `ls -selection -long`;     // All - with hierarchy\n  string $SelectedMeshArray[] = `filterExpand -sm 12`;     // Polygon\n  string $BaseModel;\n  string $BlendShape;\n\n  int $SelectedVertexNumberArray[];\n  int $SelectionTrue = 0;\n  int $BREAK = 0;\n  int $FailureList = 0; // [0: Everything OK] [1: Selection is false] [2: Skin is missing] [3: User abort] [4: PolyCount not identical] [5: Nothing to Move]\n\n  int $VertexCount = `size $SelectedVertexArray`;\n  int $ItemCount = `size $SelectedItemArray`;\n  int $MeshCount = `size $SelectedMeshArray`;\n\n  if (($VertexCount > 0) && ($MeshCount == 1)) {\n\n    $SelectionTrue = 1;\n    string $Temp[];\n    $BaseModel = $SelectedItemArray[($ItemCount - 1)];   \n    tokenize $SelectedItemArray[0] \".\" $Temp;\n    $BlendShape = $Temp[0];\n    tokenize $SelectedVertexArray[0] \"[\" $Temp;\n    int $TempPrefixSize = `size $Temp[0]` + 2; \n\n    for ($i = 0; $i < ($VertexCount); $i++) {\n\n      string $TempString = $SelectedVertexArray[$i];\n      int $TempSuffixSize = `size $TempString` - 1;\n      $SelectedVertexNumberArray[$i] = `substring $TempString $TempPrefixSize $TempSuffixSize`;\n   \n    }  \n  }\n\n  else if (($MeshCount == 2) && ($ItemCount == 2)) {\n\n    $BlendShape = $SelectedItemArray[0];\n    $BaseModel = $SelectedItemArray[1];    \n\n  }\n\n  else {\n\n    $BREAK = 1;\n    $FailureList = 1;\n\n  }\n\n// __________________________________________________________________________________________\n// Finding appropriate skinClusters & tweakNode\n// __________________________________________________________________________________________\n\n\n  string $TweakNode;\n  string $Skin[];\n\n  float $Progress = 0.0;\n\n  if (! $BREAK) {\n\n    string $BaseHistory[] = `listHistory`;\n    \n    int $HistorySize = `size $BaseHistory`;\n\n    for ($i = 0; $i < $HistorySize; $i++) {\n\n      string $TempHistory = `nodeType $BaseHistory[$i]`;\n\n      if ($TempHistory == \"tweak\") \n        $TweakNode = $BaseHistory[$i];\n      else if ($TempHistory == \"skinCluster\")\n        $Skin[`size $Skin`] = $BaseHistory[$i];\n\n    }\n\n    if ($TweakNode == \"\" || $Skin[0] == \"\") {\n\n      $BREAK = 1;\n      $FailureList = 2;\n \n    }\n  }\n\n// __________________________________________________________________________________________\n// Initializing & PolyCount\n// __________________________________________________________________________________________\n\n  float $Offset[3];\n\n  int $BaseVertexCount[];\n\n  string $vertexNameArray[];\n  string $TweakVertexArray[];\n  string $BaseModellVertexNameArray[];\n\n\n  if (! $BREAK) {\n\n    progressWindow\n\n      -title \"BSpirit Corrective Shape\"\n      -progress $Progress\n      -status \"Calculating VertexMovements\"\n      -isInterruptable true\n      -min 0\n      -max 100;\n\n    float $BaseTempOffset[3];\n    float $BlendTempOffset[3];\n\n    $BaseVertexCount = `polyEvaluate -v $BaseModel`;\n    $BaseTempOffset = `getAttr ($BaseModel+\".translate\")`;\n    $BlendTempOffset = `getAttr ($BlendShape+\".translate\")`;\n\n    $Offset[0] = $BlendTempOffset[0] - $BaseTempOffset[0];\n    $Offset[1] = $BlendTempOffset[1] - $BaseTempOffset[1];\n    $Offset[2] = $BlendTempOffset[2] - $BaseTempOffset[2];\n\n\n    int $BlendVertexCount[] = `polyEvaluate -v $BlendShape`;\n\n    string $ShapeNode[] = `pickWalk -d down $BaseModel`;\n\n    if (! `connectionInfo -isDestination ($ShapeNode[0] + \".tweakLocation\")`)\n      connectAttr ($TweakNode + \".vlist[0].vertex[0]\") ($ShapeNode[0] + \".tweakLocation\");\n\n\n    if ($BaseVertexCount[0] != $BlendVertexCount[0]) {\n\n      $BREAK = 1;\n      $FailureList = 4;     \n\n    }\n  }\n\n// __________________________________________________________________________________________\n// Query VertexPosition\n// __________________________________________________________________________________________\n\n  float $targetPosArray[];\n  float $absPosArray[];\n  float $relPosArray[];\n\n  if (! $BREAK) {\n\n    if (! $SelectionTrue) {\n\n      $VertexCount = $BaseVertexCount[0];\n\n    }\n\n    for ($i = 0; $i < $VertexCount; $i++) {\n\n      if ( `progressWindow -query -isCancelled` ) {\n      \n        $BREAK = 1;\n        $FailureList = 3; \n        break;\n\n      }\n\n      int $LastProgress = $Progress;\n      $Progress = `trunc (20.0 * $i / $VertexCount + 0.5)`;\n          \n      if ($LastProgress != $Progress)\n        progressWindow -e -progress $Progress;\n\n      string $VertexAppendix;\n\n      if (! $SelectionTrue)\n        $SelectedVertexNumberArray[$i] = $i;\n\n      $VertexAppendix = \".vtx[\" + $SelectedVertexNumberArray[$i] + \"]\";\n\n      string $BaseModelVertexName = $BaseModel + $VertexAppendix;\n      string $BlendShapeVertexName = $BlendShape + $VertexAppendix;\n\n      float $PositionArray[10];\n\n      $PositionArray = `BSpiritCorrectiveShapePosition $BlendShapeVertexName $BaseModelVertexName $Offset[0] $Offset[1] $Offset[2]`;\n\n      if ($PositionArray[0] == 1) {\n\n        int $vertexArraySize = `size $vertexNameArray` * 3;\n\n        $vertexNameArray[$vertexArraySize / 3] = $BaseModelVertexName;\n        $TweakVertexArray[$vertexArraySize / 3] = $TweakNode + \".vlist[0].vertex[\" + $SelectedVertexNumberArray[$i];\n\n        $absPosArray[$vertexArraySize] = $PositionArray[1];\n        $absPosArray[$vertexArraySize + 1] = $PositionArray[2];\n        $absPosArray[$vertexArraySize + 2] = $PositionArray[3];\n\n        $targetPosArray[$vertexArraySize] = $PositionArray[4];\n        $targetPosArray[$vertexArraySize + 1] = $PositionArray[5];\n        $targetPosArray[$vertexArraySize + 2] = $PositionArray[6];\n\n        $relPosArray[$vertexArraySize] = $PositionArray[7];\n        $relPosArray[$vertexArraySize + 1] = $PositionArray[8];\n        $relPosArray[$vertexArraySize + 2] = $PositionArray[9];\n\n      }\n    }\n  }\n\n// __________________________________________________________________________________________\n// Ask user about high VertexMovements\n// __________________________________________________________________________________________\n\n  int $vertexNameArraySize = `size $vertexNameArray`;\n  int $PercentMoved;\n\n  if ($vertexNameArraySize > 0) \n    $PercentMoved = `trunc (0.5 + $vertexNameArraySize / $VertexCount * 100)`;\n\n  else {\n\n    $BREAK = 1;\n    $FailureList = 5;\n\n  } \n\n  \n  if ($PercentMoved > 50) {\n\n    if (`confirmDialog \n\n                      -title \"Moving Vertex\"\n                      -message (\"About \" + $PercentMoved +\"% vertices will be moved. Proceed?\")\n                      -button \"Proceed\" -button \"Abort\"\n                      -defaultButton \"Proceed\" -cancelButton \"Abort\"\n                      -dismissString \"Abort\"` \n \n       == \"Abort\") {\n       $BREAK = 1;\n       $FailureList = 3;\n       \n    }\n  }  \n\n\n// __________________________________________________________________________________________\n// Calculating vertexMatrix & moving\n// __________________________________________________________________________________________\n\n\n  if (! $BREAK) {\n \n    progressWindow -e -status (\"Moving \" + $vertexNameArraySize + \" vertices\");\n\n\n    for ($i = 0; $i < $vertexNameArraySize; $i++) {\n\n      if ( `progressWindow -query -isCancelled` ) {\n      \n        $BREAK = 1;\n        $FailureList = 3; \n        break;\n\n      }\n\n\n      int $LastProgress = $Progress;\n      $Progress = `trunc (20.0 + 60.0 * $i / $vertexNameArraySize + 0.5)`;\n\n      if ($LastProgress != $Progress)\n        progressWindow -e -progress $Progress;\n\n      int $ArrayPos = $i * 3;\n\n      BSpiritCorrectiveShapeVectorMove $TweakVertexArray[$ArrayPos / 3] $vertexNameArray[$ArrayPos / 3]\n                                       $absPosArray[$ArrayPos]          $absPosArray[$ArrayPos + 1]     $absPosArray[$ArrayPos + 2]\n                                       $targetPosArray[$ArrayPos]       $targetPosArray[$ArrayPos + 1]  $targetPosArray[$ArrayPos + 2]\n                                       $relPosArray[$ArrayPos]          $relPosArray[$ArrayPos + 1]     $relPosArray[$ArrayPos + 2];\n\n    }\n  }\n\n\n// __________________________________________________________________________________________\n// Duplicating baseMesh\n// __________________________________________________________________________________________\n\n\n  string $AllInputs[] = `listHistory $BaseModel`;\n  string $MutedTypes[] = {\"skinCluster\", \"blendShape\"};\n\n\n  if (! $BREAK) {\n\n    for ($i = 0; $i < `size $AllInputs`; $i++){\n      for ($z = 0; $z < `size $MutedTypes`; $z++){\n\n      if (`nodeType $AllInputs[$i]` ==  $MutedTypes[$z])\n        setAttr ($AllInputs[$i] + \".nodeState\") 1;\n \n      }\n    }\n\n    string $BlendDuplicate[] = `duplicate -rc -rr $BaseModel`;\n    string $UnlockAttributes[] = {\".tx\",\".ty\",\".tz\",\".rx\",\".ry\",\".rz\",\".sx\",\".sy\",\".sz\"};\n\n    for ($i = 0; $i < 9; $i++) {\n\n      setAttr -lock 0 ($BlendDuplicate[0] + $UnlockAttributes[$i]);\n\n    }\n     \n    select -r $BlendDuplicate[0];  \n \n  }\n\n\n// __________________________________________________________________________________________\n// Reseting baseMesh\n// __________________________________________________________________________________________\n  \n  progressWindow -e -st \"Reseting BaseMesh\";\n\n  for ($i = 0; $i < $vertexNameArraySize; $i++) {\n\n    int $LastProgress = $Progress;\n    $Progress = `trunc (80.0 + 20.0 * $i / $vertexNameArraySize + 0.5)`;\n\n    if ($LastProgress != $Progress)\n      progressWindow -e -progress $Progress;\n\n    int $ArrayPos = $i * 3;\n\n    setAttr ($TweakVertexArray[$ArrayPos / 3] + \"].xVertex\") $relPosArray[$ArrayPos];\n    setAttr ($TweakVertexArray[$ArrayPos / 3] + \"].yVertex\") $relPosArray[$ArrayPos + 1];\n    setAttr ($TweakVertexArray[$ArrayPos / 3] + \"].zVertex\") $relPosArray[$ArrayPos + 2];\n\n  }\n\n\n  for ($i = 0; $i < `size $AllInputs`; $i++){\n    for ($z = 0; $z < `size $MutedTypes`; $z++){\n\n    if (`nodeType $AllInputs[$i]` ==  $MutedTypes[$z])\n      setAttr ($AllInputs[$i] + \".nodeState\") 0;\n \n    }\n  }\n\n  progressWindow -endProgress;\n\n// __________________________________________________________________________________________\n// Feedback to user\n// __________________________________________________________________________________________\n\n  if ($FailureList != 0) {\n\n    string $Feedback;\n    switch ($FailureList) {\n\n      case 1:\n        $Feedback = \"Wrong number of objects selected!\";\n        break;\n      case 2:\n        $Feedback = \"Second mesh has no skinCluster!\";\n        break;\n      case 3:\n        $Feedback = \"Procedure aborted by user!\";\n        break;\n      case 4:\n        $Feedback = \"Not identical amount of vertices!\";\n        break;\n      case 5:\n        $Feedback = \"Nothing to move!\";\n        break;\n    }\n\n    confirmDialog   -title \"Failure - Procedure aborted\" \n                    -message $Feedback\n                    -button \"OK\";\n\n  }\n}\n\nBSpiritCorrectiveShape" 
        -enableBackground 0
        -align "center" 
        -label "/*______________________________________________________________..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "BLING" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "commandButton.png" 
        -image1 "commandButton.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "/*___________________________________________________________________________\n|\n|   BSpiritCorrectiveShape v1.2\n|\n|   Copyright (C) 2004 Christian Breitling\n|   Last modified: Oktober 13, 2004 Germany\n|   \n|   Email: christian.breitling@gmx.de\n|   \n|\n|   This program is free software; you can redistribute it and/or\n|   modify it under the terms of the GNU General Public License\n|   as published by the Free Software Foundation; either version 2\n|   of the License, or (at your option) any later version.\n|\n|   This program is distributed in the hope that it will be useful,\n|   but WITHOUT ANY WARRANTY; without even the implied warranty of\n|   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n|   GNU General Public License for more details.\n|\n|   You should have received a copy of the GNU General Public License\n|   along with this program; if not, write to the Free Software\n|   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.\n|\n|   The GNU GPL is also available at http://www.gnu.org/licenses/gpl.html\n|\n|____________________________________________________________________________\n\n  What CorrectiveShape is for:\n  ----------------------------\n  Create a corrective blend shape for your binded mesh. \n\n\n  How is it working: \n  ------------------\n  In general vertices in Maya behave different than normal if they are binded.\n  The rotation of a joint also affects the local space of the binded vertices.\n  Moving them in the viewport causes very funny effects. But for creating \n  corrective blend shapes normal behavior would be best. Duplicating the binded\n  mesh and applying it afterwards as blend shape causes wrong vertex behavior.\n  So the world position of the blend shape has to be translated to the local \n  space of the skinned mesh.\n\n  This is done by the following script wich uses an equitation to get the right\n  motion vector.\n\n\n  How to use it:\n  --------------  \n\n    1. Installation:\n    ----------------\n\n      - Copy this mel script in one of your script directories of Maya.\n\n\n\n    2. Normal Usage:\n    ----------------\n\n      1. Move the skinned mesh to the desired pose. You might key all important \n         handles and joints for recalling them later.\n\n      2. Duplicate it without any connections. \n         The duplicate can be translated freely [you`ll have to unlock the transformation]. \n         The original mesh mustn`t change [except you keyed the pose -> restore before calculation]. \n\n      3. Model the appropriate corrections for this pose.\n\n      4. Select the newly created corrective shape and then the original mesh [in this order].\n\n      5. run \"BSpiritCorrectiveShape\" in the command line or script editor.\n\n\n\n    3. Advanced Usage:\n    ------------------\n\n      To calculate and move only specific vertices: \n\n      1. - 3. Same procedure as above\n\n      4. Select the newly created corrective shape in \"Object Mode\". \n         Via right mouse button change to \"Vertex Mode\" and select the appropriate vertices.\n         Add the original mesh to your selection.\n\n      5. run \"BSpiritCorrectiveShape\" in the command line or script editor.\n\n\n\n\n  You will receive a perfect blend shape mesh. Assigning it is your task. \n  Don`t forget to change the input connection order. Blend shapes have to be\n  first (bottom) in the stack.\n\n  If anything could be better, nothing is functioning or you just want to write\n  me - don`t bother\n\n  Christian Breitling\n\n  christian.breitling@gmx.de\n\n_____________________________________________________________________________\n*/\n\nsource BSpiritCorrectiveShape;\n\n\n// __________________________________________________________________________________________\n// VertexPosition procedure\n// __________________________________________________________________________________________\n\n\nproc BSpiritCorrectiveShapeVectorMove( string $TweakVertexName, string $BaseModelVertexName,\n                                       float $WorldPosX,  float $WorldPosY,  float $WorldPosZ,\n                                       float $targetPosX, float $targetPosY, float $targetPosZ,\n                                       float $relPosX,    float $relPosY,    float $relPosZ ) {\n\n  float $tempPos[3];\n  float $Matrix[12];\n\n  setAttr ($TweakVertexName + \"].xVertex\") ($relPosX + 1);\n  $tempPos = `pointPosition -w $BaseModelVertexName`;\n  $Matrix[0]  = $tempPos[0]-$WorldPosX;\n  $Matrix[4]  = $tempPos[1]-$WorldPosY;\n  $Matrix[8]  = $tempPos[2]-$WorldPosZ;\n  $Matrix[3]  = $targetPosX;\n\n  setAttr ($TweakVertexName + \"].xVertex\") ($relPosX);\n  setAttr ($TweakVertexName + \"].yVertex\") ($relPosY + 1);\n  $tempPos = `pointPosition -w $BaseModelVertexName`;\n  $Matrix[1]  = $tempPos[0]-$WorldPosX;\n  $Matrix[5]  = $tempPos[1]-$WorldPosY;\n  $Matrix[9]  = $tempPos[2]-$WorldPosZ;\n  $Matrix[7]  = $targetPosY;\n\n\n  setAttr ($TweakVertexName + \"].yVertex\") ($relPosY);\n  setAttr ($TweakVertexName + \"].zVertex\") ($relPosZ + 1);\n  $tempPos = `pointPosition -w $BaseModelVertexName`;\n  $Matrix[2]  = $tempPos[0]-$WorldPosX;\n  $Matrix[6]  = $tempPos[1]-$WorldPosY;\n  $Matrix[10] = $tempPos[2]-$WorldPosZ;\n  $Matrix[11] = $targetPosZ;\n\n  float $return[3];\n  float $Denominator = \n\n  ($Matrix[0] * (($Matrix[5]*$Matrix[10]) - ($Matrix[6]*$Matrix[9]))) - \n  ($Matrix[1] * (($Matrix[4]*$Matrix[10]) - ($Matrix[6]*$Matrix[8]))) + \n  ($Matrix[2] * (($Matrix[4]*$Matrix[9] ) - ($Matrix[5]*$Matrix[8])));\n\n  if ($Denominator != 0) { \n\n    $return[0] = \n \n    (\n    ($Matrix[3] * (($Matrix[5]*$Matrix[10]) - ($Matrix[6]*$Matrix[9]  ))) - \n    ($Matrix[1] * (($Matrix[7]*$Matrix[10]) - ($Matrix[6]*$Matrix[11] ))) + \n    ($Matrix[2] * (($Matrix[7]*$Matrix[9] ) - ($Matrix[5]*$Matrix[11] )))\n    ) / $Denominator;\n\n    $return[1] = \n \n    (\n    ($Matrix[0] * (($Matrix[7]*$Matrix[10]) - ($Matrix[6]*$Matrix[11] ))) -\n    ($Matrix[3] * (($Matrix[4]*$Matrix[10]) - ($Matrix[6]*$Matrix[8]  ))) + \n    ($Matrix[2] * (($Matrix[4]*$Matrix[11]) - ($Matrix[7]*$Matrix[8]  )))\n    ) / $Denominator;\n\n    $return[2] =\n\n    (\n    ($Matrix[0] * (($Matrix[5]*$Matrix[11]) - ($Matrix[7]*$Matrix[9]  ))) - \n    ($Matrix[1] * (($Matrix[4]*$Matrix[11]) - ($Matrix[7]*$Matrix[8]  ))) + \n    ($Matrix[3] * (($Matrix[4]*$Matrix[9] ) - ($Matrix[5]*$Matrix[8]  )))\n    ) / $Denominator;\n\n    setAttr ($TweakVertexName + \"].xVertex\") ($relPosX + $return[0]);\n    setAttr ($TweakVertexName + \"].yVertex\") ($relPosY + $return[1]);\n    setAttr ($TweakVertexName + \"].zVertex\") ($relPosX + $return[2]);\n        \n  }\n}\n\n\n// __________________________________________________________________________________________\n// VertexMatrix procedure\n// __________________________________________________________________________________________\n\nproc float[] BSpiritCorrectiveShapePosition( string $BlendShapeVertexName, \n                                             string $BaseModelVertexName, \n                                             float $OffsetX, float $OffsetY, float $OffsetZ) {\n\n  float $targetPos[3];\n  float $Pos[3];\n  float $relVertexPos[3];\n\n  $targetPos = `pointPosition -w $BlendShapeVertexName`;\n  $Pos = `pointPosition -w $BaseModelVertexName`;\n  $relVertexPos = `getAttr $BaseModelVertexName`;\n\n  $targetPos[0] -= ($Pos[0]+$OffsetX);\n  $targetPos[1] -= ($Pos[1]+$OffsetY);\n  $targetPos[2] -= ($Pos[2]+$OffsetZ); \n\n  if (($targetPos[0]>0.001) || ($targetPos[0]<-0.001) || \n      ($targetPos[1]>0.001) || ($targetPos[1]<-0.001) || \n      ($targetPos[2]>0.001) || ($targetPos[2]<-0.001))\n\n    return { 1.0,\n             $Pos[0],          $Pos[1],          $Pos[2],\n             $targetPos[0],    $targetPos[1],    $targetPos[2],\n             $relVertexPos[0], $relVertexPos[1], $relVertexPos[2] };\n  \n  else \n\n    return { -1.0 };     \n\n}\n\n// __________________________________________________________________________________________\n// Main Procedure\n// __________________________________________________________________________________________\n\nglobal proc BSpiritCorrectiveShape() {\n\n// __________________________________________________________________________________________\n// Declaring main variables & Query names and selections \n// __________________________________________________________________________________________\n\n  string $SelectedVertexArray[] = `filterExpand -sm 31`;   // Vertex\n  string $SelectedItemArray[] = `ls -selection -long`;     // All - with hierarchy\n  string $SelectedMeshArray[] = `filterExpand -sm 12`;     // Polygon\n  string $BaseModel;\n  string $BlendShape;\n\n  int $SelectedVertexNumberArray[];\n  int $SelectionTrue = 0;\n  int $BREAK = 0;\n  int $FailureList = 0; // [0: Everything OK] [1: Selection is false] [2: Skin is missing] [3: User abort] [4: PolyCount not identical] [5: Nothing to Move]\n\n  int $VertexCount = `size $SelectedVertexArray`;\n  int $ItemCount = `size $SelectedItemArray`;\n  int $MeshCount = `size $SelectedMeshArray`;\n\n  if (($VertexCount > 0) && ($MeshCount == 1)) {\n\n    $SelectionTrue = 1;\n    string $Temp[];\n    $BaseModel = $SelectedItemArray[($ItemCount - 1)];   \n    tokenize $SelectedItemArray[0] \".\" $Temp;\n    $BlendShape = $Temp[0];\n    tokenize $SelectedVertexArray[0] \"[\" $Temp;\n    int $TempPrefixSize = `size $Temp[0]` + 2; \n\n    for ($i = 0; $i < ($VertexCount); $i++) {\n\n      string $TempString = $SelectedVertexArray[$i];\n      int $TempSuffixSize = `size $TempString` - 1;\n      $SelectedVertexNumberArray[$i] = `substring $TempString $TempPrefixSize $TempSuffixSize`;\n   \n    }  \n  }\n\n  else if (($MeshCount == 2) && ($ItemCount == 2)) {\n\n    $BlendShape = $SelectedItemArray[0];\n    $BaseModel = $SelectedItemArray[1];    \n\n  }\n\n  else {\n\n    $BREAK = 1;\n    $FailureList = 1;\n\n  }\n\n// __________________________________________________________________________________________\n// Finding appropriate skinClusters & tweakNode\n// __________________________________________________________________________________________\n\n\n  string $TweakNode;\n  string $Skin[];\n\n  float $Progress = 0.0;\n\n  if (! $BREAK) {\n\n    string $BaseHistory[] = `listHistory`;\n    \n    int $HistorySize = `size $BaseHistory`;\n\n    for ($i = 0; $i < $HistorySize; $i++) {\n\n      string $TempHistory = `nodeType $BaseHistory[$i]`;\n\n      if ($TempHistory == \"tweak\") \n        $TweakNode = $BaseHistory[$i];\n      else if ($TempHistory == \"skinCluster\")\n        $Skin[`size $Skin`] = $BaseHistory[$i];\n\n    }\n\n    if ($TweakNode == \"\" || $Skin[0] == \"\") {\n\n      $BREAK = 1;\n      $FailureList = 2;\n \n    }\n  }\n\n// __________________________________________________________________________________________\n// Initializing & PolyCount\n// __________________________________________________________________________________________\n\n  float $Offset[3];\n\n  int $BaseVertexCount[];\n\n  string $vertexNameArray[];\n  string $TweakVertexArray[];\n  string $BaseModellVertexNameArray[];\n\n\n  if (! $BREAK) {\n\n    progressWindow\n\n      -title \"BSpirit Corrective Shape\"\n      -progress $Progress\n      -status \"Calculating VertexMovements\"\n      -isInterruptable true\n      -min 0\n      -max 100;\n\n    float $BaseTempOffset[3];\n    float $BlendTempOffset[3];\n\n    $BaseVertexCount = `polyEvaluate -v $BaseModel`;\n    $BaseTempOffset = `getAttr ($BaseModel+\".translate\")`;\n    $BlendTempOffset = `getAttr ($BlendShape+\".translate\")`;\n\n    $Offset[0] = $BlendTempOffset[0] - $BaseTempOffset[0];\n    $Offset[1] = $BlendTempOffset[1] - $BaseTempOffset[1];\n    $Offset[2] = $BlendTempOffset[2] - $BaseTempOffset[2];\n\n\n    int $BlendVertexCount[] = `polyEvaluate -v $BlendShape`;\n\n    string $ShapeNode[] = `pickWalk -d down $BaseModel`;\n\n    if (! `connectionInfo -isDestination ($ShapeNode[0] + \".tweakLocation\")`)\n      connectAttr ($TweakNode + \".vlist[0].vertex[0]\") ($ShapeNode[0] + \".tweakLocation\");\n\n\n    if ($BaseVertexCount[0] != $BlendVertexCount[0]) {\n\n      $BREAK = 1;\n      $FailureList = 4;     \n\n    }\n  }\n\n// __________________________________________________________________________________________\n// Query VertexPosition\n// __________________________________________________________________________________________\n\n  float $targetPosArray[];\n  float $absPosArray[];\n  float $relPosArray[];\n\n  if (! $BREAK) {\n\n    if (! $SelectionTrue) {\n\n      $VertexCount = $BaseVertexCount[0];\n\n    }\n\n    for ($i = 0; $i < $VertexCount; $i++) {\n\n      if ( `progressWindow -query -isCancelled` ) {\n      \n        $BREAK = 1;\n        $FailureList = 3; \n        break;\n\n      }\n\n      int $LastProgress = $Progress;\n      $Progress = `trunc (20.0 * $i / $VertexCount + 0.5)`;\n          \n      if ($LastProgress != $Progress)\n        progressWindow -e -progress $Progress;\n\n      string $VertexAppendix;\n\n      if (! $SelectionTrue)\n        $SelectedVertexNumberArray[$i] = $i;\n\n      $VertexAppendix = \".vtx[\" + $SelectedVertexNumberArray[$i] + \"]\";\n\n      string $BaseModelVertexName = $BaseModel + $VertexAppendix;\n      string $BlendShapeVertexName = $BlendShape + $VertexAppendix;\n\n      float $PositionArray[10];\n\n      $PositionArray = `BSpiritCorrectiveShapePosition $BlendShapeVertexName $BaseModelVertexName $Offset[0] $Offset[1] $Offset[2]`;\n\n      if ($PositionArray[0] == 1) {\n\n        int $vertexArraySize = `size $vertexNameArray` * 3;\n\n        $vertexNameArray[$vertexArraySize / 3] = $BaseModelVertexName;\n        $TweakVertexArray[$vertexArraySize / 3] = $TweakNode + \".vlist[0].vertex[\" + $SelectedVertexNumberArray[$i];\n\n        $absPosArray[$vertexArraySize] = $PositionArray[1];\n        $absPosArray[$vertexArraySize + 1] = $PositionArray[2];\n        $absPosArray[$vertexArraySize + 2] = $PositionArray[3];\n\n        $targetPosArray[$vertexArraySize] = $PositionArray[4];\n        $targetPosArray[$vertexArraySize + 1] = $PositionArray[5];\n        $targetPosArray[$vertexArraySize + 2] = $PositionArray[6];\n\n        $relPosArray[$vertexArraySize] = $PositionArray[7];\n        $relPosArray[$vertexArraySize + 1] = $PositionArray[8];\n        $relPosArray[$vertexArraySize + 2] = $PositionArray[9];\n\n      }\n    }\n  }\n\n// __________________________________________________________________________________________\n// Ask user about high VertexMovements\n// __________________________________________________________________________________________\n\n  int $vertexNameArraySize = `size $vertexNameArray`;\n  int $PercentMoved;\n\n  if ($vertexNameArraySize > 0) \n    $PercentMoved = `trunc (0.5 + $vertexNameArraySize / $VertexCount * 100)`;\n\n  else {\n\n    $BREAK = 1;\n    $FailureList = 5;\n\n  } \n\n  \n  if ($PercentMoved > 50) {\n\n    if (`confirmDialog \n\n                      -title \"Moving Vertex\"\n                      -message (\"About \" + $PercentMoved +\"% vertices will be moved. Proceed?\")\n                      -button \"Proceed\" -button \"Abort\"\n                      -defaultButton \"Proceed\" -cancelButton \"Abort\"\n                      -dismissString \"Abort\"` \n \n       == \"Abort\") {\n       $BREAK = 1;\n       $FailureList = 3;\n       \n    }\n  }  \n\n\n// __________________________________________________________________________________________\n// Calculating vertexMatrix & moving\n// __________________________________________________________________________________________\n\n\n  if (! $BREAK) {\n \n    progressWindow -e -status (\"Moving \" + $vertexNameArraySize + \" vertices\");\n\n\n    for ($i = 0; $i < $vertexNameArraySize; $i++) {\n\n      if ( `progressWindow -query -isCancelled` ) {\n      \n        $BREAK = 1;\n        $FailureList = 3; \n        break;\n\n      }\n\n\n      int $LastProgress = $Progress;\n      $Progress = `trunc (20.0 + 60.0 * $i / $vertexNameArraySize + 0.5)`;\n\n      if ($LastProgress != $Progress)\n        progressWindow -e -progress $Progress;\n\n      int $ArrayPos = $i * 3;\n\n      BSpiritCorrectiveShapeVectorMove $TweakVertexArray[$ArrayPos / 3] $vertexNameArray[$ArrayPos / 3]\n                                       $absPosArray[$ArrayPos]          $absPosArray[$ArrayPos + 1]     $absPosArray[$ArrayPos + 2]\n                                       $targetPosArray[$ArrayPos]       $targetPosArray[$ArrayPos + 1]  $targetPosArray[$ArrayPos + 2]\n                                       $relPosArray[$ArrayPos]          $relPosArray[$ArrayPos + 1]     $relPosArray[$ArrayPos + 2];\n\n    }\n  }\n\n\n// __________________________________________________________________________________________\n// Duplicating baseMesh\n// __________________________________________________________________________________________\n\n\n  string $AllInputs[] = `listHistory $BaseModel`;\n  string $MutedTypes[] = {\"skinCluster\", \"blendShape\"};\n\n\n  if (! $BREAK) {\n\n    for ($i = 0; $i < `size $AllInputs`; $i++){\n      for ($z = 0; $z < `size $MutedTypes`; $z++){\n\n      if (`nodeType $AllInputs[$i]` ==  $MutedTypes[$z])\n        setAttr ($AllInputs[$i] + \".nodeState\") 1;\n \n      }\n    }\n\n    string $BlendDuplicate[] = `duplicate -rc -rr $BaseModel`;\n    string $UnlockAttributes[] = {\".tx\",\".ty\",\".tz\",\".rx\",\".ry\",\".rz\",\".sx\",\".sy\",\".sz\"};\n\n    for ($i = 0; $i < 9; $i++) {\n\n      setAttr -lock 0 ($BlendDuplicate[0] + $UnlockAttributes[$i]);\n\n    }\n     \n    select -r $BlendDuplicate[0];  \n \n  }\n\n\n// __________________________________________________________________________________________\n// Reseting baseMesh\n// __________________________________________________________________________________________\n  \n  progressWindow -e -st \"Reseting BaseMesh\";\n\n  for ($i = 0; $i < $vertexNameArraySize; $i++) {\n\n    int $LastProgress = $Progress;\n    $Progress = `trunc (80.0 + 20.0 * $i / $vertexNameArraySize + 0.5)`;\n\n    if ($LastProgress != $Progress)\n      progressWindow -e -progress $Progress;\n\n    int $ArrayPos = $i * 3;\n\n    setAttr ($TweakVertexArray[$ArrayPos / 3] + \"].xVertex\") $relPosArray[$ArrayPos];\n    setAttr ($TweakVertexArray[$ArrayPos / 3] + \"].yVertex\") $relPosArray[$ArrayPos + 1];\n    setAttr ($TweakVertexArray[$ArrayPos / 3] + \"].zVertex\") $relPosArray[$ArrayPos + 2];\n\n  }\n\n\n  for ($i = 0; $i < `size $AllInputs`; $i++){\n    for ($z = 0; $z < `size $MutedTypes`; $z++){\n\n    if (`nodeType $AllInputs[$i]` ==  $MutedTypes[$z])\n      setAttr ($AllInputs[$i] + \".nodeState\") 0;\n \n    }\n  }\n\n  progressWindow -endProgress;\n\n// __________________________________________________________________________________________\n// Feedback to user\n// __________________________________________________________________________________________\n\n  if ($FailureList != 0) {\n\n    string $Feedback;\n    switch ($FailureList) {\n\n      case 1:\n        $Feedback = \"Wrong number of objects selected!\";\n        break;\n      case 2:\n        $Feedback = \"Second mesh has no skinCluster!\";\n        break;\n      case 3:\n        $Feedback = \"Procedure aborted by user!\";\n        break;\n      case 4:\n        $Feedback = \"Not identical amount of vertices!\";\n        break;\n      case 5:\n        $Feedback = \"Nothing to move!\";\n        break;\n    }\n\n    confirmDialog   -title \"Failure - Procedure aborted\" \n                    -message $Feedback\n                    -button \"OK\";\n\n  }\n}\n\nBSpiritCorrectiveShape" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "import maya.cmds as cmds\n\na=cmds.skinCluster(q=1,weightedInfluence=1)\ncmds.select(a)" 
        -enableBackground 0
        -align "center" 
        -label "import maya.cmds as cmds\n\na=cmds.skinCluster(q=1,weightedInfluen..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "SelJnts" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "pythonFamily.png" 
        -image1 "pythonFamily.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "import maya.cmds as cmds\n\na=cmds.skinCluster(q=1,weightedInfluence=1)\ncmds.select(a)" 
        -sourceType "python" 
        -doubleClickCommand "import maya.cmds as cmds\n\na=cmds.skinCluster(q=1,weightedInfluence=1)\ncmds.select(a)\n\nmirrorList = []\nincr = 0\n\nfor i in a:\n    if 'LT' in i:\n        mirrorList.append('R'+i[1:])\n\ncmds.select(d=1)\n\nfor i in mirrorList:\n    cmds.select(i,add=1)\n" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Makes what is essentially a constraint to a vertex." 
        -enableBackground 0
        -align "center" 
        -label "// Copyright (C) 2000-2001 Michael Bazhutkin - Copyright (C) 200..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "RIVET" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "commandButton.png" 
        -image1 "commandButton.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "// Copyright (C) 2000-2001 Michael Bazhutkin - Copyright (C) 2000 studio Klassika\n// www.geocites.com/bazhutkin\n// bazhutkin@mail.ru\n//\n//  Rivet (button) 1.0\n//  Script File\n//  MODIFY THIS AT YOUR OWN RISK\n//\n//  Creation Date:  April 13, 2001\n//\n//\n//  Description:\n//\tUse \"Rivet\" to constrain locator to polygon or NURBS surfaces\n//\tSelect two edges on polygon object\n//\tor select one point on NURBS surface and call rivet\n//\tParent your rivets and buttons to this locator\n\nglobal proc string rivet ( )\n{\n\nstring $nameObject;\nstring $namePOSI;\n\nstring $parts[];\nstring $list[] = `filterExpand -sm 32`;\nint $size = size($list);\nif ($size > 0)\n{\n\tif ($size != 2)\n\t{\terror(\"No two edges selected\");\n\t\treturn \"\";\n\t}\n\n\ttokenize($list[0],\".\",$parts);\n\t$nameObject = $parts[0];\n\ttokenize($list[0],\"[]\",$parts);\n\tfloat $e1 = $parts[1];\n\ttokenize($list[1],\"[]\",$parts);\n\tfloat $e2 = $parts[1];\n\n\tstring $nameCFME1 = `createNode curveFromMeshEdge -n \"rivetCurveFromMeshEdge1\"`;\n\t\tsetAttr \".ihi\" 1;\n\t\tsetAttr \".ei[0]\"  $e1;\n\tstring $nameCFME2 = `createNode curveFromMeshEdge -n \"rivetCurveFromMeshEdge2\"`;\n\t\tsetAttr \".ihi\" 1;\n\t\tsetAttr \".ei[0]\"  $e2;\n\tstring $nameLoft = `createNode loft -n \"rivetLoft1\"`;\n\t\tsetAttr -s 2 \".ic\";\n\t\tsetAttr \".u\" yes;\n\t\tsetAttr \".rsn\" yes;\n\n\t$namePOSI = `createNode pointOnSurfaceInfo -n \"rivetPointOnSurfaceInfo1\"`;\n\t\tsetAttr \".turnOnPercentage\" 1;\n\t\tsetAttr \".parameterU\" 0.5;\n\t\tsetAttr \".parameterV\" 0.5;\n\n\tconnectAttr -f ($nameLoft + \".os\") ($namePOSI + \".is\");\n\tconnectAttr ($nameCFME1 + \".oc\") ($nameLoft + \".ic[0]\");\n\tconnectAttr ($nameCFME2 + \".oc\") ($nameLoft + \".ic[1]\");\n\tconnectAttr ($nameObject + \".w\") ($nameCFME1 + \".im\");\n\tconnectAttr ($nameObject + \".w\") ($nameCFME2 + \".im\");\n}\nelse\n{\t$list = `filterExpand -sm 41`;\n\t$size = size($list);\n\n\tif ($size > 0)\n\t{\n\t\tif ($size != 1)\n\t\t{\terror(\"No one point selected\");\n\t\t\treturn \"\";\n\t\t}\n\t\ttokenize($list[0],\".\",$parts);\n\t\t$nameObject = $parts[0];\n\t\ttokenize($list[0],\"[]\",$parts);\n\t\tfloat $u = $parts[1];\n\t\tfloat $v = $parts[2];\n\t\t$namePOSI = `createNode pointOnSurfaceInfo -n \"rivetPointOnSurfaceInfo1\"`;\n\t\t\t\tsetAttr \".turnOnPercentage\" 0;\n\t\t\t\tsetAttr \".parameterU\" $u;\n\t\t\t\tsetAttr \".parameterV\" $v;\n\t\tconnectAttr -f ($nameObject + \".ws\") ($namePOSI + \".is\");\n\t}\n\telse\n\t{\terror(\"No edges or point selected\");\n\t\treturn \"\";\n\t}\n}\n\nstring $nameLocator = `createNode transform -n \"rivet1\"`;\ncreateNode locator -n ($nameLocator + \"Shape\") -p $nameLocator;\n\nstring $nameAC = `createNode aimConstraint -p $nameLocator -n ($nameLocator + \"_rivetAimConstraint1\")`;\n\tsetAttr \".tg[0].tw\" 1;\n\tsetAttr \".a\" -type \"double3\" 0 1 0;\n\tsetAttr \".u\" -type \"double3\" 0 0 1;\n\tsetAttr -k off \".v\";\n\tsetAttr -k off \".tx\";\n\tsetAttr -k off \".ty\";\n\tsetAttr -k off \".tz\";\n\tsetAttr -k off \".rx\";\n\tsetAttr -k off \".ry\";\n\tsetAttr -k off \".rz\";\n\tsetAttr -k off \".sx\";\n\tsetAttr -k off \".sy\";\n\tsetAttr -k off \".sz\";\n\nconnectAttr ($namePOSI + \".position\") ($nameLocator + \".translate\");\nconnectAttr ($namePOSI + \".n\") ($nameAC + \".tg[0].tt\");\nconnectAttr ($namePOSI + \".tv\") ($nameAC + \".wu\");\nconnectAttr ($nameAC + \".crx\") ($nameLocator + \".rx\");\nconnectAttr ($nameAC + \".cry\") ($nameLocator + \".ry\");\nconnectAttr ($nameAC + \".crz\") ($nameLocator + \".rz\");\n\nselect -r $nameLocator;\nreturn ($nameLocator);\n\n}\n\nrivet;" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Joints on Curve" 
        -enableBackground 0
        -align "center" 
        -label "/////////////////////////////// nnJointsOnCurve ////////////////..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "JOC" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "commandButton.png" 
        -image1 "commandButton.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "/////////////////////////////// nnJointsOnCurve /////////////////////////////////\n\n//                              Scripted by -Nilesh Jadhav\n//                                                         27-07-2010\n/////////////////////////////////////////////////////////////////////////////////////\n// -------------- This script generates joint chain on selected Curve ---------------\n//////////////////////////////////////////////////////////////////////////////////////\n//\n////////////////////////// UI Designing for nnJointOnCurve /////////////////////////\n\nif (`window -exists curveJoint`)\ndeleteUI \"curveJoint\";\n    \n    window -t \"nnJointsOnCurve\" -w 200 -h 200 -mnb 1 -mxb 0 -s 1 curveJoint;\n\ncolumnLayout -adj 1 -columnAttach \"both\" 1 -rowSpacing 10 -columnWidth 250;\n\n    intFieldGrp -l\"Number of Joints\" numberInt;\n    checkBoxGrp -l\"Rebuild the Curve\" rebuildCheck;\n    text -l \"Select the Curve and press the Button\" -fn \"smallBoldLabelFont\" ;\n    button -l\"<< Add Joint Chain on Curve >>\" -h 30 -c (\"nnJointsOnCurve()\") goButton;\n    text -l\"Scripted by - Nilesh Jadhav\" -bgc 1 1 1;\n\nshowWindow curveJoint;\n\n\n\n/////////////////////////////////////  Procedure ////////////////////////////////////////////////\n\nglobal proc nnJointsOnCurve()\n{\n\n    string $sel []=`ls -sl`;\n    string $curve =$sel [0];\n    string $check =`checkBoxGrp -q -v1 rebuildCheck`;\nif ($check==1 )\n{\nrebuildCurve -rt 0 -s 25;\n\n}\nelse\n{\n}\n    string $lcr []=`spaceLocator`;\n    string $loc =$lcr [0];\n\n    string $path =`pathAnimation  -stu 1 -etu 1000 -f on  $curve $loc `; \n    int $numbers []=`intFieldGrp -q -v numberInt`;\n\n    float $locPos []=`xform -q -ws  -t $loc`;\n    int $divFacter =1000 / $numbers [0];\n\nselect -cl;\n$i=`currentTime -q`;\n            for ($i=1; $i<1000; $i=$i+$divFacter) //--------- Loop to make joint chain\n                {\n\n\n\n        currentTime $i;\n        float $lcPos []=`xform -q  -ws -t locator1`;\n\n        string $joints =`joint -a -p $lcPos [0] $lcPos [1] $lcPos [2]`;\n\n}\nstring $selJoint []=`ls -sl`;\nstring $jnt =$selJoint [0]; \n\n\n    $i =1;\n            for ( $i=1; $i<$numbers[0]+1; $i++) //--------- loop for getting 1st joint\n                {\n                    pickWalk -d up;\n                }    \n    \n    joint -e -oj xyz -secondaryAxisOrient yup -ch -zso;\n\n\ndelete $path;\ndelete $loc;\ncurrentTime -e 1;\n}\n" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Select the surface(s) or component(s)." 
        -enableBackground 0
        -align "center" 
        -label "Prune Small Weights" 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "PSW" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.25 
        -image "menuIconSkinning.png" 
        -image1 "menuIconSkinning.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "PruneSmallWeights" 
        -sourceType "mel" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "Mirrors controls" 
        -enableBackground 0
        -align "center" 
        -label "import maya.cmds as cmds\n\nsl = cmds.ls(sl=True)\nmirrorList = []\n..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "MIrror" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.2 
        -image "pythonFamily.png" 
        -image1 "pythonFamily.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "import maya.cmds as cmds\n\nsl = cmds.ls(sl=True)\nmirrorList = []\nrotValues = []\n\nprefix = 'LT'\nreplaceWith = 'RT'\n\nlength = len(prefix)\n\n\nincr = 0\nfor i in sl:\n    rotValues.append(cmds.xform(i,q=True,ro=True))\n    mirrorList.append(replaceWith+str(sl[0][length:]))\n    #print i, 'rots =', rotValues[incr]\n    cmds.xform(replaceWith+str(sl[incr][length:]),ro=rotValues[incr])\n    print 'set', mirrorList[incr],'to',rotValues[incr]\n    incr = incr+1\n" 
        -sourceType "python" 
        -commandRepeatable 1
        -flat 1
    ;
    shelfButton
        -enableCommandRepeat 1
        -enable 1
        -width 35
        -height 35
        -manage 1
        -visible 1
        -preventOverride 0
        -annotation "import maya.cmds as cmds\n\nsl = cmds.ls(sl=1)\n\nincr = 1\nfor i in sl:\n    attrs = cmds.listAttr()\n    for j in attrs:\n        while 'divider'+str(incr) in j:\n            print j\n            incr += 1\n    print 'made new divider'+str(incr)\n    cmds.addAttr(i, ln = \"divider\"+str(incr), nn = \"---\", at = \"enum\", en = \"---:\")\n    cmds.setAttr(i+'.divider'+str(incr), e = 1, keyable = False,channelBox=True)\n" 
        -enableBackground 0
        -align "center" 
        -label "import maya.cmds as cmds\n\nsl = cmds.ls(sl=1)\n\nincr = 1\nfor i in ..." 
        -labelOffset 0
        -rotation 0
        -flipX 0
        -flipY 0
        -useAlpha 1
        -font "plainLabelFont" 
        -imageOverlayLabel "Divider" 
        -overlayLabelColor 0.8 0.8 0.8 
        -overlayLabelBackColor 0 0 0 0.5 
        -image "pythonFamily.png" 
        -image1 "pythonFamily.png" 
        -style "iconOnly" 
        -marginWidth 1
        -marginHeight 1
        -command "import maya.cmds as cmds\n\nsl = cmds.ls(sl=1)\n\nincr = 1\nfor i in sl:\n    attrs = cmds.listAttr()\n    for j in attrs:\n        while 'divider'+str(incr) in j:\n            print j\n            incr += 1\n    print 'made new divider'+str(incr)\n    cmds.addAttr(i, ln = \"divider\"+str(incr), nn = \"---\", at = \"enum\", en = \"---:\")\n    cmds.setAttr(i+'.divider'+str(incr), e = 1, keyable = False,channelBox=True)\n" 
        -sourceType "python" 
        -commandRepeatable 1
        -flat 1
    ;

} 
